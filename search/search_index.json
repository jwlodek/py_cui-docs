{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"py_cui A py thon library for creating c ommand line u ser i nterfaces. What is py_cui? py_cui is a python library meant to simplify writing command line user interfaces in python. It relies on the curses module, which is traditionally a unix-specific python module, however, I was able to use the windows-curses module to run py_cui on windows. The main advantage py_cui has over traditional command line user interfaces is that it relies on widgets and a grid layout manager like most traditional Graphical User Interfaces. You may define a grid size, and then drop predefined widgets onto it into specific grid locations. Widgets can also be stretched accross multiple grid rows and columns. If you've ever made a Tkinter GUI, you will feel right at home. Writing a PyCUI Basic usage of py_cui starts with creating a PyCUI object, and specifiying it's grid size. Keep in mind that grid cell height and width will be measured in terminal characters, not pixels, so there is a lower limit on legal grid size, and heights will be smaller values than widths. Create this object with: root = py_cui.PyCUI(7, 9) The above line will create a UI with 7 rows and 9 columns. Then, add widgets with the different add commands: label = root.add_label('Label Text', 0, 0) button = root.add_button('Button Text', 1, 2, column_span=2, command=my_function) ... Finally, start the CUI with root.start() py_cui has support for custom key bindings for both the overview mode and focused mode, popup windows and prompts, color rendering rules, and several useful widgets. For more details on writing py_cui based interfaces, be sure to check on the examples and the documentation here . Using a PyCUI There are some basic rules that apply to all py_cui based interfaces. There are three key operating modes - overview mode, focus mode, and popup mode. Overview Mode Overview mode is the main control view of the interface. In this mode you use the arrow keys to move between widgets, and you may select widgets with the Enter key. By default, you may also press buttons in this mode, unless auto_focus_buttons is set to false when the CUI was created. Focus Mode When in focus mode, you enter into a particular widget (For example a text box.). Each widget has some predefined basic controls, such as arrow keys to scroll in a ScrollMenu . You may also add keybindings to functions for each particular widget. These keybindings will only apply to a widget if it is in focus mode. Enter focus mode by navigating to a widget in overview mode and hitting the Enter key. Return to overview mode from focus mode by pressing Escape . Popup Mode Popup mode simply displays a popup over the rest of the UI. Each popup type behaves slightly differently. For example, you may exit an info popup mode by pressing Space , Enter , or Escape , while a loading popup will remain onscreen until whatever operation is being run is terminated.","title":"Home"},{"location":"#py_cui","text":"A py thon library for creating c ommand line u ser i nterfaces.","title":"py_cui"},{"location":"#what-is-py_cui","text":"py_cui is a python library meant to simplify writing command line user interfaces in python. It relies on the curses module, which is traditionally a unix-specific python module, however, I was able to use the windows-curses module to run py_cui on windows. The main advantage py_cui has over traditional command line user interfaces is that it relies on widgets and a grid layout manager like most traditional Graphical User Interfaces. You may define a grid size, and then drop predefined widgets onto it into specific grid locations. Widgets can also be stretched accross multiple grid rows and columns. If you've ever made a Tkinter GUI, you will feel right at home.","title":"What is py_cui?"},{"location":"#writing-a-pycui","text":"Basic usage of py_cui starts with creating a PyCUI object, and specifiying it's grid size. Keep in mind that grid cell height and width will be measured in terminal characters, not pixels, so there is a lower limit on legal grid size, and heights will be smaller values than widths. Create this object with: root = py_cui.PyCUI(7, 9) The above line will create a UI with 7 rows and 9 columns. Then, add widgets with the different add commands: label = root.add_label('Label Text', 0, 0) button = root.add_button('Button Text', 1, 2, column_span=2, command=my_function) ... Finally, start the CUI with root.start() py_cui has support for custom key bindings for both the overview mode and focused mode, popup windows and prompts, color rendering rules, and several useful widgets. For more details on writing py_cui based interfaces, be sure to check on the examples and the documentation here .","title":"Writing a PyCUI"},{"location":"#using-a-pycui","text":"There are some basic rules that apply to all py_cui based interfaces. There are three key operating modes - overview mode, focus mode, and popup mode. Overview Mode Overview mode is the main control view of the interface. In this mode you use the arrow keys to move between widgets, and you may select widgets with the Enter key. By default, you may also press buttons in this mode, unless auto_focus_buttons is set to false when the CUI was created. Focus Mode When in focus mode, you enter into a particular widget (For example a text box.). Each widget has some predefined basic controls, such as arrow keys to scroll in a ScrollMenu . You may also add keybindings to functions for each particular widget. These keybindings will only apply to a widget if it is in focus mode. Enter focus mode by navigating to a widget in overview mode and hitting the Enter key. Return to overview mode from focus mode by pressing Escape . Popup Mode Popup mode simply displays a popup over the rest of the UI. Each popup type behaves slightly differently. For example, you may exit an info popup mode by pressing Space , Enter , or Escape , while a loading popup will remain onscreen until whatever operation is being run is terminated.","title":"Using a PyCUI"},{"location":"about/","text":"About csplit Primary Author Jakub Wlodek Created on August 12, 2019 Contributing Authors Maciej Wlodek License BSD 3-Clause License Copyright (c) 2019, Jakub Wlodek All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"About"},{"location":"about/#about-csplit","text":"","title":"About csplit"},{"location":"about/#primary-author","text":"Jakub Wlodek Created on August 12, 2019","title":"Primary Author"},{"location":"about/#contributing-authors","text":"Maciej Wlodek","title":"Contributing Authors"},{"location":"about/#license","text":"BSD 3-Clause License Copyright (c) 2019, Jakub Wlodek All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"developers/","text":"Documentation for py_cui Developers This page contains information on writing new widgets and popups, as well as anything else required for developers and contributors for py_cui. Adding a new Widget We will walk through the steps of adding a new widget to py_cui (in this case a scroll menu) in order to demonstrate this process. Step One - Extend the Widget Class Your first step when writing a new widget is to create a class in py_cui/widgets.py that extends the base Widget class. For our ScrollMenu example: class ScrollMenu(Widget): def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) def draw(self): super().draw() The handle_key_press and draw functions must be extended for your new widget. You may leave the handle_key_press as above, if you don't require any keybindings for the widget. The draw function must extended, as the base class does no drawing itself, instead just setting up color rules. Step Two - Add additional class variables Next, add any variables that your widget may require on top of the base Widget class variables. In our case, it will be the selected item index, a list of menu items, and an integer representing the top item visible (in case the menu scrolls down). We also add some functions for getting and setting these variables. def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) self.top_view = 0 self.selected_item = 0 self.view_items = [] def clear(self): \"\"\" Clears all items from the Scroll Menu \"\"\" self.view_items = [] self.selected_item = 0 self.top_view = 0 def add_item_list(self, item_list): for item in item_list: self.add_item(item) def remove_selected_item(self): if len(self.view_items) == 0: return del self.view_items[self.selected_item] if self.selected_item >= len(self.view_items): self.selected_item = self.selected_item - 1 def get_item_list(self): return self.view_items def get(self): if len(self.view_items) > 0: return self.view_items[self.selected_item] return None Step 3 - Add Key Bindings Next, add any default key bindings you wish to have for the widget when in focus mode. In the case of the scroll menu, we wish for the arrow keys to scroll up and down, so we extend the handle_key_press function: def scroll_up(self): if self.selected: if self.top_view > 0: self.top_view = self.top_view - 1 if self.selected_item > 0: self.selected_item = self.selected_item - 1 def scroll_down(self): if self.selected: if self.selected_item < len(self.view_items) - 1: self.selected_item = self.selected_item + 1 if self.selected_item > self.top_view + self.height - (2 * self.pady) - 3: self.top_view = self.top_view + 1 def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) if key_pressed == py_cui.keys.KEY_UP_ARROW: self.scroll_up() if key_pressed == py_cui.keys.KEY_DOWN_ARROW: self.scroll_down() Note that the way default key bindings are added are simply if statements, which happen after the super() call. The scroll_up() and scroll_down() functions simply contain the logic for editing the viewport for the menu. Step 4 - implement the Draw function In the draw function, you must use the self.renderer object to render your widget to the screen. In our case, we want a border around the menu widget, and we also want to draw menu items that are within our viewport. The key renderer functions we will use are: self.renderer.draw_border(self) which will draw a border around the widget space, and self.renderer.draw_text(self, text, y_position) which will draw the text in the y_position. For our scroll menu, we would write the following: def draw(self): super().draw() # sets the color mode self.renderer.set_color_mode(self.color) # draws border around widget self.renderer.draw_border(self) # will store the current y-position counter = self.pady + 1 line_counter = 0 for line in self.view_items: # Until we reach viewport start, increment counter if line_counter < self.top_view: line_counter = line_counter + 1 else: if counter >= self.height - self.pady - 1: break if line_counter == self.selected_item: self.renderer.draw_text(self, line, self.start_y + counter, selected=True) else: self.renderer.draw_text(self, line, self.start_y + counter) counter = counter + 1 line_counter = line_counter + 1 # reset default colors self.renderer.unset_color_mode(self.color) # reset cursor should be called at the end of every draw function self.renderer.reset_cursor(self) Step 5 - add a function to __init__.py to add the widget Finally, add a function to __init__.py that will add the widget to the CUI. In our case we write the following: def add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0): id = 'Widget{}'.format(len(self.widgets.keys())) new_scroll_menu = widgets.ScrollMenu(id, title, self.grid, row, column, row_span, column_span, padx, pady) self.widgets[id] = new_scroll_menu if self.selected_widget is None: self.set_selected_widget(id) return new_scroll_menu The function must: * Create an id titled 'Widget####' where #### is replaced with the number of widget * Add the widget to the PyCUI widgets dict with the ID as a key * If there is no selected widget, make this new widget the selected one * Return a reference to the widget That's it! Your widget is now ready to be added to the CUI! Adding a new Popup This documentation section is incomplete. Feel free to expand me . Working on the renderer This documentation section is incomplete. Feel free to expand me . Working on color rules This documentation section is incomplete. Feel free to expand me .","title":"For py_cui developers"},{"location":"developers/#documentation-for-py_cui-developers","text":"This page contains information on writing new widgets and popups, as well as anything else required for developers and contributors for py_cui.","title":"Documentation for py_cui Developers"},{"location":"developers/#adding-a-new-widget","text":"We will walk through the steps of adding a new widget to py_cui (in this case a scroll menu) in order to demonstrate this process. Step One - Extend the Widget Class Your first step when writing a new widget is to create a class in py_cui/widgets.py that extends the base Widget class. For our ScrollMenu example: class ScrollMenu(Widget): def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) def draw(self): super().draw() The handle_key_press and draw functions must be extended for your new widget. You may leave the handle_key_press as above, if you don't require any keybindings for the widget. The draw function must extended, as the base class does no drawing itself, instead just setting up color rules. Step Two - Add additional class variables Next, add any variables that your widget may require on top of the base Widget class variables. In our case, it will be the selected item index, a list of menu items, and an integer representing the top item visible (in case the menu scrolls down). We also add some functions for getting and setting these variables. def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) self.top_view = 0 self.selected_item = 0 self.view_items = [] def clear(self): \"\"\" Clears all items from the Scroll Menu \"\"\" self.view_items = [] self.selected_item = 0 self.top_view = 0 def add_item_list(self, item_list): for item in item_list: self.add_item(item) def remove_selected_item(self): if len(self.view_items) == 0: return del self.view_items[self.selected_item] if self.selected_item >= len(self.view_items): self.selected_item = self.selected_item - 1 def get_item_list(self): return self.view_items def get(self): if len(self.view_items) > 0: return self.view_items[self.selected_item] return None Step 3 - Add Key Bindings Next, add any default key bindings you wish to have for the widget when in focus mode. In the case of the scroll menu, we wish for the arrow keys to scroll up and down, so we extend the handle_key_press function: def scroll_up(self): if self.selected: if self.top_view > 0: self.top_view = self.top_view - 1 if self.selected_item > 0: self.selected_item = self.selected_item - 1 def scroll_down(self): if self.selected: if self.selected_item < len(self.view_items) - 1: self.selected_item = self.selected_item + 1 if self.selected_item > self.top_view + self.height - (2 * self.pady) - 3: self.top_view = self.top_view + 1 def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) if key_pressed == py_cui.keys.KEY_UP_ARROW: self.scroll_up() if key_pressed == py_cui.keys.KEY_DOWN_ARROW: self.scroll_down() Note that the way default key bindings are added are simply if statements, which happen after the super() call. The scroll_up() and scroll_down() functions simply contain the logic for editing the viewport for the menu. Step 4 - implement the Draw function In the draw function, you must use the self.renderer object to render your widget to the screen. In our case, we want a border around the menu widget, and we also want to draw menu items that are within our viewport. The key renderer functions we will use are: self.renderer.draw_border(self) which will draw a border around the widget space, and self.renderer.draw_text(self, text, y_position) which will draw the text in the y_position. For our scroll menu, we would write the following: def draw(self): super().draw() # sets the color mode self.renderer.set_color_mode(self.color) # draws border around widget self.renderer.draw_border(self) # will store the current y-position counter = self.pady + 1 line_counter = 0 for line in self.view_items: # Until we reach viewport start, increment counter if line_counter < self.top_view: line_counter = line_counter + 1 else: if counter >= self.height - self.pady - 1: break if line_counter == self.selected_item: self.renderer.draw_text(self, line, self.start_y + counter, selected=True) else: self.renderer.draw_text(self, line, self.start_y + counter) counter = counter + 1 line_counter = line_counter + 1 # reset default colors self.renderer.unset_color_mode(self.color) # reset cursor should be called at the end of every draw function self.renderer.reset_cursor(self) Step 5 - add a function to __init__.py to add the widget Finally, add a function to __init__.py that will add the widget to the CUI. In our case we write the following: def add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0): id = 'Widget{}'.format(len(self.widgets.keys())) new_scroll_menu = widgets.ScrollMenu(id, title, self.grid, row, column, row_span, column_span, padx, pady) self.widgets[id] = new_scroll_menu if self.selected_widget is None: self.set_selected_widget(id) return new_scroll_menu The function must: * Create an id titled 'Widget####' where #### is replaced with the number of widget * Add the widget to the PyCUI widgets dict with the ID as a key * If there is no selected widget, make this new widget the selected one * Return a reference to the widget That's it! Your widget is now ready to be added to the CUI!","title":"Adding a new Widget"},{"location":"developers/#adding-a-new-popup","text":"This documentation section is incomplete. Feel free to expand me .","title":"Adding a new Popup"},{"location":"developers/#working-on-the-renderer","text":"This documentation section is incomplete. Feel free to expand me .","title":"Working on the renderer"},{"location":"developers/#working-on-color-rules","text":"This documentation section is incomplete. Feel free to expand me .","title":"Working on color rules"},{"location":"examples/","text":"py_cui Examples There are several examples of simple py_cui programs you can find in the examples directory of the github repository. In addition, a larger python module pyautogit was written with py_cui , and is available for download using pip or from github. In this section of the documentation we will explain the source code for some of the supplied examples in more detail. Hello py_cui! As is tradition with programming, we start with our Hello World example. Here we simply create a PyCUI object with a grid size of 3 x 3, and we add a Label into the center grid space. This is the most basic py_cui you can create. # Import the lib import py_cui # create the CUI object. Will have a 3 by 3 grid with indexes from 0,0 to 2,2 root = py_cui.PyCUI(3,3) # Add a label to the center of the CUI in the 1,1 grid position root.add_label('Hello py_cui!!!', 1, 1) # Start/Render the CUI root.start() Simple Todo List A simple usage of py_cui for creating a terminal todo list. We use keybindings to get control of each of our lists as well as our text entry import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Keybindings for controlling our CUI. # We bind the enter key for each of the widgets self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Popups Example This example will demonstrate the usage for using all supported popups. # imports import py_cui import time import os import threading # We will need the threading library when we want to use the loading popups class PopupExample: def __init__(self, master): # This is a reference to our top level CUI object self.master = master # buttons for control - each simply spawns the linked popup self.show_message_popup = self.master.add_button('Show Message Popup', 0, 0, command=self.show_message) self.show_yes_no_popup = self.master.add_button('Show Yes No Popup', 1, 0, command=self.show_yes_no) self.show_loading_icon_popup = self.master.add_button('Show Loading Icon Popup', 2, 0, command=self.show_loading_icon) self.show_loading_bar_popup = self.master.add_button('Show Loading Bar Popup', 0,1, command = self.show_loading_bar) self.show_text_box_popup = self.master.add_button('Show Text Box Popup', 1,1, command = self.show_text_box) self.show_menu_popup = self.master.add_button('Show Scroll Menu Popup', 2,1, command = self.show_menu_popup_fun) def show_message(self): \"\"\" Displays a simple message popup \"\"\" self.master.show_message_popup('Hello!', 'This is a message popup. You can also spawn warnings and errors.') ################################################ # YES NO POPUP def quit_cui(self, to_quit): # THis is the function given to the yes no popup. The to_quit parameter will be true if y is pressed, or False if n is pressed if to_quit: exit() else: self.master.show_message_popup('Cancelled', 'The quit operation was cancelled.') def show_yes_no(self): \"\"\" Displays a yes no popup asking if the user would like to quit \"\"\" # For the yes/no popup, the 'command' parameter must take a function that requires a single boolean parameter self.master.show_yes_no_popup('Are you sure you want to quit?', self.quit_cui) ################################################ ################################################ # TEXTBOX POPUP def reset_title(self, new_title): self.master.title = new_title def show_text_box(self): \"\"\" Displays a textbox popup asking the user for a new window title \"\"\" # A textbox popup requires a prompt and a function reference. The function must take a single string parameter that will return # whatever is within the text box when the ENTER key is pressed self.master.show_text_box_popup('Please enter a new window title', self.reset_title) ################################################ ################################################ # SCROLL MENU POPUP def change_button_color(self, new_color): \"\"\" Function called when ENTER pressed in menu popup. Takes string as parameter \"\"\" color = py_cui.WHITE_ON_BLACK if new_color == \"RED\": color = py_cui.RED_ON_BLACK elif new_color == \"CYAN\": color = py_cui.CYAN_ON_BLACK elif new_color == \"MAGENTA\": color = py_cui.MAGENTA_ON_BLACK for key in self.master.widgets.keys(): if isinstance(self.master.widgets[key], py_cui.widgets.Button): self.master.widgets[key].color = color def show_menu_popup_fun(self): \"\"\" Opens scroll menu for selecting button colors \"\"\" # Spawning a menu popup must recieve a list of strings as menu options, and a function reference that takes a string parameter menu_choices = ['RED', 'CYAN', 'MAGENTA'] self.master.show_menu_popup('Please select a new button color', menu_choices, self.change_button_color) ################################################ def show_loading_icon(self): \"\"\" Function that shows the usage for spwaning a loading icon popup \"\"\" # The loading popup will remain onscreen until the stop loading function is called. Call this before a large operation, and call # stop after the operation is finished. Note that for these long operations, you must use a different thread # to not block the draw calls. self.master.show_loading_icon_popup('Please Wait', 'Loading') operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def show_loading_bar(self): \"\"\" Function that shows the usage for spawning a loading bar popup \"\"\" self.master.show_loading_bar_popup('Incrementing a counter...', 100) operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def long_operation(self): \"\"\" A simple function that demonstrates a long callback operation performed while loading popup is open \"\"\" counter = 0 for i in range(0, 100): time.sleep(0.1) counter= counter +1 self.master.status_bar.set_text(str(counter)) # When using a bar indicator, we will increment the completed counter. Will be ignored for loading icon popup self.master.increment_loading_bar() # This is what stops the loading popup and reenters overview mode self.master.stop_loading_popup() # Create the CUI, pass it to the wrapper object, and start it root = py_cui.PyCUI(3, 2) root.set_title('CUI Popups Example') s = PopupExample(root) root.start() Other examples Other examples are available in the examples directory in the repository on github. For a larger example of a project using py_cui , see pyautogit .","title":"Examples"},{"location":"examples/#py_cui-examples","text":"There are several examples of simple py_cui programs you can find in the examples directory of the github repository. In addition, a larger python module pyautogit was written with py_cui , and is available for download using pip or from github. In this section of the documentation we will explain the source code for some of the supplied examples in more detail.","title":"py_cui Examples"},{"location":"examples/#hello-py_cui","text":"As is tradition with programming, we start with our Hello World example. Here we simply create a PyCUI object with a grid size of 3 x 3, and we add a Label into the center grid space. This is the most basic py_cui you can create. # Import the lib import py_cui # create the CUI object. Will have a 3 by 3 grid with indexes from 0,0 to 2,2 root = py_cui.PyCUI(3,3) # Add a label to the center of the CUI in the 1,1 grid position root.add_label('Hello py_cui!!!', 1, 1) # Start/Render the CUI root.start()","title":"Hello py_cui!"},{"location":"examples/#simple-todo-list","text":"A simple usage of py_cui for creating a terminal todo list. We use keybindings to get control of each of our lists as well as our text entry import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Keybindings for controlling our CUI. # We bind the enter key for each of the widgets self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start()","title":"Simple Todo List"},{"location":"examples/#popups-example","text":"This example will demonstrate the usage for using all supported popups. # imports import py_cui import time import os import threading # We will need the threading library when we want to use the loading popups class PopupExample: def __init__(self, master): # This is a reference to our top level CUI object self.master = master # buttons for control - each simply spawns the linked popup self.show_message_popup = self.master.add_button('Show Message Popup', 0, 0, command=self.show_message) self.show_yes_no_popup = self.master.add_button('Show Yes No Popup', 1, 0, command=self.show_yes_no) self.show_loading_icon_popup = self.master.add_button('Show Loading Icon Popup', 2, 0, command=self.show_loading_icon) self.show_loading_bar_popup = self.master.add_button('Show Loading Bar Popup', 0,1, command = self.show_loading_bar) self.show_text_box_popup = self.master.add_button('Show Text Box Popup', 1,1, command = self.show_text_box) self.show_menu_popup = self.master.add_button('Show Scroll Menu Popup', 2,1, command = self.show_menu_popup_fun) def show_message(self): \"\"\" Displays a simple message popup \"\"\" self.master.show_message_popup('Hello!', 'This is a message popup. You can also spawn warnings and errors.') ################################################ # YES NO POPUP def quit_cui(self, to_quit): # THis is the function given to the yes no popup. The to_quit parameter will be true if y is pressed, or False if n is pressed if to_quit: exit() else: self.master.show_message_popup('Cancelled', 'The quit operation was cancelled.') def show_yes_no(self): \"\"\" Displays a yes no popup asking if the user would like to quit \"\"\" # For the yes/no popup, the 'command' parameter must take a function that requires a single boolean parameter self.master.show_yes_no_popup('Are you sure you want to quit?', self.quit_cui) ################################################ ################################################ # TEXTBOX POPUP def reset_title(self, new_title): self.master.title = new_title def show_text_box(self): \"\"\" Displays a textbox popup asking the user for a new window title \"\"\" # A textbox popup requires a prompt and a function reference. The function must take a single string parameter that will return # whatever is within the text box when the ENTER key is pressed self.master.show_text_box_popup('Please enter a new window title', self.reset_title) ################################################ ################################################ # SCROLL MENU POPUP def change_button_color(self, new_color): \"\"\" Function called when ENTER pressed in menu popup. Takes string as parameter \"\"\" color = py_cui.WHITE_ON_BLACK if new_color == \"RED\": color = py_cui.RED_ON_BLACK elif new_color == \"CYAN\": color = py_cui.CYAN_ON_BLACK elif new_color == \"MAGENTA\": color = py_cui.MAGENTA_ON_BLACK for key in self.master.widgets.keys(): if isinstance(self.master.widgets[key], py_cui.widgets.Button): self.master.widgets[key].color = color def show_menu_popup_fun(self): \"\"\" Opens scroll menu for selecting button colors \"\"\" # Spawning a menu popup must recieve a list of strings as menu options, and a function reference that takes a string parameter menu_choices = ['RED', 'CYAN', 'MAGENTA'] self.master.show_menu_popup('Please select a new button color', menu_choices, self.change_button_color) ################################################ def show_loading_icon(self): \"\"\" Function that shows the usage for spwaning a loading icon popup \"\"\" # The loading popup will remain onscreen until the stop loading function is called. Call this before a large operation, and call # stop after the operation is finished. Note that for these long operations, you must use a different thread # to not block the draw calls. self.master.show_loading_icon_popup('Please Wait', 'Loading') operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def show_loading_bar(self): \"\"\" Function that shows the usage for spawning a loading bar popup \"\"\" self.master.show_loading_bar_popup('Incrementing a counter...', 100) operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def long_operation(self): \"\"\" A simple function that demonstrates a long callback operation performed while loading popup is open \"\"\" counter = 0 for i in range(0, 100): time.sleep(0.1) counter= counter +1 self.master.status_bar.set_text(str(counter)) # When using a bar indicator, we will increment the completed counter. Will be ignored for loading icon popup self.master.increment_loading_bar() # This is what stops the loading popup and reenters overview mode self.master.stop_loading_popup() # Create the CUI, pass it to the wrapper object, and start it root = py_cui.PyCUI(3, 2) root.set_title('CUI Popups Example') s = PopupExample(root) root.start()","title":"Popups Example"},{"location":"examples/#other-examples","text":"Other examples are available in the examples directory in the repository on github. For a larger example of a project using py_cui , see pyautogit .","title":"Other examples"},{"location":"functions/","text":"Module py_cui {#py_cui} A python library for creating command line based user interfaces. @author: Jakub Wlodek @created: 12-Aug-2019 Sub-modules py_cui.colors py_cui.errors py_cui.grid py_cui.keybinding py_cui.popups py_cui.renderer py_cui.statusbar py_cui.widget_set py_cui.widgets Functions Function fit_text {#py_cui.fit_text} def fit_text(width, text, center=False) Helper function to fit text within a given width. Used to fix issue with status/title bar text being too long and crashing the CUI Parameters width :\u2002 int : width of window in characters text :\u2002 str : input text center :\u2002 Boolean : flag to center text Returns text fixed depending on width : Classes Class PyCUI {#py_cui.PyCUI} class PyCUI(num_rows, num_cols, auto_focus_buttons=True, exit_key=113) Main user interface class for py_cui. To create a user interface, you must first create an instance of this class, and then add cells + widgets to it. Attributes cursor_x , cursor_y :\u2002 int : absolute position of the cursor in the CUI py_cui.grid :\u2002 Grid : The main layout manager for the CUI cells :\u2002 list of py_cui.cell.Cell : list of cells in the grid title_bar :\u2002 StatusBar : a status bar object that gets drawn at the top of the CUI status_bar :\u2002 StatusBar : a status bar object that gets drawn at the bottom of the CUI keybindings :\u2002 list of py_cui.keybinding.KeyBinding : list of keybindings to check against in the main CUI loop height , width :\u2002 int : height of the terminal in characters, width of terminal in characters exit_key :\u2002 key_code : a key code for a key that exits the CUI Methods start() starts the CUI once all of the widgets have been added. Note that you cannot add more widgets once this has been run add_status_bar(text : str, foreground_color : color, background_color : color) function that adds a status bar widget to the CUI Methods Method add_block_label {#py_cui.PyCUI.add_block_label} def add_block_label(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new label to the CUI grid Method add_button {#py_cui.PyCUI.add_button} def add_button(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, command=None) Function that adds a new button to the CUI grid Method add_checkbox_menu {#py_cui.PyCUI.add_checkbox_menu} def add_checkbox_menu(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, checked_char='X') Function that adds a new checkbox menu to the CUI grid Method add_key_command {#py_cui.PyCUI.add_key_command} def add_key_command(self, key, command) Function that adds a keybinding to the CUI when in overview mode Method add_label {#py_cui.PyCUI.add_label} def add_label(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new label to the CUI grid Method add_scroll_menu {#py_cui.PyCUI.add_scroll_menu} def add_scroll_menu(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new scroll menu to the CUI grid Method add_text_block {#py_cui.PyCUI.add_text_block} def add_text_block(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, initial_text='') Function that adds a new text box to the CUI grid Method add_text_box {#py_cui.PyCUI.add_text_box} def add_text_box(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, initial_text='') Function that adds a new text box to the CUI grid Method apply_widget_set {#py_cui.PyCUI.apply_widget_set} def apply_widget_set(self, new_widget_set) Function that can be used to replace all widgets in a py_cui with those of a different widget set Method check_if_neighbor_exists {#py_cui.PyCUI.check_if_neighbor_exists} def check_if_neighbor_exists(self, row, column, row_span, col_span, direction) Function that checks if widget has neighbor in specified cell. Used for navigating CUI Method close_popup {#py_cui.PyCUI.close_popup} def close_popup(self) Closes the popup, and resets focus Method display_window_warning {#py_cui.PyCUI.display_window_warning} def display_window_warning(self, stdscr, error_info) Function that prints some basic error info if there is an error with the CUI Method draw {#py_cui.PyCUI.draw} def draw(self, stdscr) Main CUI draw loop called by start() Method draw_status_bars {#py_cui.PyCUI.draw_status_bars} def draw_status_bars(self, stdscr, height, width) Draws status bar and title bar Method draw_widgets {#py_cui.PyCUI.draw_widgets} def draw_widgets(self) Function that draws all of the widgets to the screen Method get_widget_set {#py_cui.PyCUI.get_widget_set} def get_widget_set(self) Gets widget set object from current widgets. Method handle_key_presses {#py_cui.PyCUI.handle_key_presses} def handle_key_presses(self, key_pressed) Function that handles all main loop key presses. Method increment_loading_bar {#py_cui.PyCUI.increment_loading_bar} def increment_loading_bar(self) Increments progress bar if loading bar popup is open Method initialize_colors {#py_cui.PyCUI.initialize_colors} def initialize_colors(self) Function for initialzing curses colors. Called when CUI is first created. Method initialize_widget_renderer {#py_cui.PyCUI.initialize_widget_renderer} def initialize_widget_renderer(self) Function that creates the renderer object that will draw each widget Method lose_focus {#py_cui.PyCUI.lose_focus} def lose_focus(self) Function that forces py_cui out of focus mode. After popup is called, focus is lost Method refresh_height_width {#py_cui.PyCUI.refresh_height_width} def refresh_height_width(self, height, width) Function that updates the height and width of the CUI based on terminal window size Method set_selected_widget {#py_cui.PyCUI.set_selected_widget} def set_selected_widget(self, widget_id) Function that sets the selected cell for the CUI Parameters cell_title :\u2002 str : the title of the cell Method set_status_bar_text {#py_cui.PyCUI.set_status_bar_text} def set_status_bar_text(self, text) Sets the status bar text when in overview mode Method set_title {#py_cui.PyCUI.set_title} def set_title(self, title) Sets the title bar text Method show_error_popup {#py_cui.PyCUI.show_error_popup} def show_error_popup(self, title, text) Shows an error popup Method show_loading_bar_popup {#py_cui.PyCUI.show_loading_bar_popup} def show_loading_bar_popup(self, title, num_items) Shows loading bar popup. Use 'increment_loading_bar' to show progress Method show_loading_icon_popup {#py_cui.PyCUI.show_loading_icon_popup} def show_loading_icon_popup(self, title, message) Shows a loading icon popup Method show_menu_popup {#py_cui.PyCUI.show_menu_popup} def show_menu_popup(self, title, menu_items, command, run_command_if_none=False) Shows a yes/no popup. The 'command' parameter must be a function with a single boolean parameter Method show_message_popup {#py_cui.PyCUI.show_message_popup} def show_message_popup(self, title, text) Shows a message popup Method show_text_box_popup {#py_cui.PyCUI.show_text_box_popup} def show_text_box_popup(self, title, command) Shows a yes/no popup. The 'command' parameter must be a function with a single boolean parameter Method show_warning_popup {#py_cui.PyCUI.show_warning_popup} def show_warning_popup(self, title, text) Shows a warning popup Method show_yes_no_popup {#py_cui.PyCUI.show_yes_no_popup} def show_yes_no_popup(self, title, command) Shows a yes/no popup. The 'command' parameter must be a function with a single boolean parameter Method start {#py_cui.PyCUI.start} def start(self) Function that starts the CUI Method stop {#py_cui.PyCUI.stop} def stop(self, callback=None) Function that stops the CUI, and fires the callback function. Callback must be a no arg method Method stop_loading_popup {#py_cui.PyCUI.stop_loading_popup} def stop_loading_popup(self) Leaves loading state, and closes popup. Must be called by user to escape loading. Module py_cui.colors {#py_cui.colors} File containing all error types for py_cui @author: Jakub Wlodek @created: 12-Aug-2019 Classes Class ColorRule {#py_cui.colors.ColorRule} class ColorRule(regex, color, rule_type, match_type, region, include_whitespace) Methods Method check_match {#py_cui.colors.ColorRule.check_match} def check_match(self, line) Checks if the color rule matches a line Method generate_fragments {#py_cui.colors.ColorRule.generate_fragments} def generate_fragments(self, widget, line, render_text) Method generate_fragments_regex {#py_cui.colors.ColorRule.generate_fragments_regex} def generate_fragments_regex(self, widget, render_text) Splits text into fragments based on regular expression Method split_text_on_region {#py_cui.colors.ColorRule.split_text_on_region} def split_text_on_region(self, widget, render_text) Splits text into fragments based on region Module py_cui.errors {#py_cui.errors} File containing all error types for py_cui @author: Jakub Wlodek @created: 12-Aug-2019 Classes Class PyCUIError {#py_cui.errors.PyCUIError} class PyCUIError(*args, **kwargs) General error Ancestors (in MRO) builtins.Exception builtins.BaseException Class PyCUIMissingChildError {#py_cui.errors.PyCUIMissingChildError} class PyCUIMissingChildError(*args, **kwargs) Error for when child widget is None or invalid Ancestors (in MRO) builtins.Exception builtins.BaseException Class PyCUIMissingParentError {#py_cui.errors.PyCUIMissingParentError} class PyCUIMissingParentError(*args, **kwargs) Error for when parent widget is None or invalid Ancestors (in MRO) builtins.Exception builtins.BaseException Class PyCUIOutOfBoundsError {#py_cui.errors.PyCUIOutOfBoundsError} class PyCUIOutOfBoundsError(*args, **kwargs) Error for when widget or text goes off of the py_cui grid Ancestors (in MRO) builtins.Exception builtins.BaseException Module py_cui.grid {#py_cui.grid} File containing the Grid Class. The grid is currently the only supported layout manager for py_cui @author: Jakub Wlodek @created: 12-Aug-2019 Classes Class Grid {#py_cui.grid.Grid} class Grid(num_rows, num_columns, height, width) Methods Method set_num_cols {#py_cui.grid.Grid.set_num_cols} def set_num_cols(self, num_columns) Sets the grid column size Method set_num_rows {#py_cui.grid.Grid.set_num_rows} def set_num_rows(self, num_rows) Sets the grid row size Method update_grid_height_width {#py_cui.grid.Grid.update_grid_height_width} def update_grid_height_width(self, height, width) Update grid height and width. Allows for on-the-fly size editing Module py_cui.keybinding {#py_cui.keybinding} File containing constants and helper functions for dealing with keys @author: Jakub Wlodek @created: 12-Aug-2019 Functions Function get_ascii_from_char {#py_cui.keybinding.get_ascii_from_char} def get_ascii_from_char(char) Function get_char_from_ascii {#py_cui.keybinding.get_char_from_ascii} def get_char_from_ascii(key_num) Module py_cui.popups {#py_cui.popups} File containing classes for all popups used by py_cui @author: Jakub Wlodek @created: 12-Aug-2019 Classes Class LoadingBarPopup {#py_cui.popups.LoadingBarPopup} class LoadingBarPopup(root, title, num_items, color, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame Attributes root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup Methods handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class Ancestors (in MRO) py_cui.popups.Popup Class LoadingIconPopup {#py_cui.popups.LoadingIconPopup} class LoadingIconPopup(root, title, message, color, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame Attributes root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup Methods handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class Ancestors (in MRO) py_cui.popups.Popup Class MenuPopup {#py_cui.popups.MenuPopup} class MenuPopup(root, items, title, color, command, renderer, run_command_if_none) A scroll menu widget. Allows for creating a scrollable list of items of which one is selectable. Analogous to a RadioButton Constructor for popup class Ancestors (in MRO) py_cui.popups.Popup Methods Method draw {#py_cui.popups.MenuPopup.draw} def draw(self) Overrides base class draw function Method get {#py_cui.popups.MenuPopup.get} def get(self) Function that gets the selected item from the scroll menu Returns item :\u2002 str : selected item, or None if there are no items in the menu Method handle_key_press {#py_cui.popups.MenuPopup.handle_key_press} def handle_key_press(self, key_pressed) Override of base handle key press function Method scroll_down {#py_cui.popups.MenuPopup.scroll_down} def scroll_down(self) Function that scrolls the view down in the scroll menu Method scroll_up {#py_cui.popups.MenuPopup.scroll_up} def scroll_up(self) Function that scrolls the view up in the scroll menu Class MessagePopup {#py_cui.popups.MessagePopup} class MessagePopup(root, title, text, color, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame Attributes root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup Methods handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class Ancestors (in MRO) py_cui.popups.Popup Class Popup {#py_cui.popups.Popup} class Popup(root, title, text, color, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame Attributes root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup Methods handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class Descendants py_cui.popups.MessagePopup py_cui.popups.YesNoPopup py_cui.popups.TextBoxPopup py_cui.popups.MenuPopup py_cui.popups.LoadingIconPopup py_cui.popups.LoadingBarPopup Methods Method draw {#py_cui.popups.Popup.draw} def draw(self) Must be implemented by subclass Method handle_key_press {#py_cui.popups.Popup.handle_key_press} def handle_key_press(self, key_pressed) Must be implemented by subclass Class TextBoxPopup {#py_cui.popups.TextBoxPopup} class TextBoxPopup(root, title, color, command, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame Attributes root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup Methods handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class Ancestors (in MRO) py_cui.popups.Popup Methods Method clear {#py_cui.popups.TextBoxPopup.clear} def clear(self) Clears the text in the textbox Method draw {#py_cui.popups.TextBoxPopup.draw} def draw(self) Override of base draw function Method erase_char {#py_cui.popups.TextBoxPopup.erase_char} def erase_char(self) Erases character at textbox cursor Method get {#py_cui.popups.TextBoxPopup.get} def get(self) Gets value of the text in the textbox Method handle_key_press {#py_cui.popups.TextBoxPopup.handle_key_press} def handle_key_press(self, key_pressed) Override of base handle key press function Method insert_char {#py_cui.popups.TextBoxPopup.insert_char} def insert_char(self, key_pressed) Inserts char at cursor position. Internal use only Method jump_to_end {#py_cui.popups.TextBoxPopup.jump_to_end} def jump_to_end(self) Jumps to the end to the textbox Method jump_to_start {#py_cui.popups.TextBoxPopup.jump_to_start} def jump_to_start(self) Jumps to the start of the textbox Method move_left {#py_cui.popups.TextBoxPopup.move_left} def move_left(self) Shifts the cursor the the left. Internal use only Method move_right {#py_cui.popups.TextBoxPopup.move_right} def move_right(self) Shifts the cursor the the right. Internal use only Method set_text {#py_cui.popups.TextBoxPopup.set_text} def set_text(self, text) Sets the value of the text. Overwrites existing text Class YesNoPopup {#py_cui.popups.YesNoPopup} class YesNoPopup(root, title, text, color, command, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame Attributes root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup Methods handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class Ancestors (in MRO) py_cui.popups.Popup Module py_cui.renderer {#py_cui.renderer} File containing the py_cui renderer. It is used to draw all of the onscreen widgets and items. @author: Jakub Wlodek @created: 12-Aug-2019 Classes Class Renderer {#py_cui.renderer.Renderer} class Renderer(root, stdscr) Main renderer class used for drawing widgets to the terminal. Has helper functions for drawing the borders, cursor, and text required for the cui. All of the functions supplied by the renderer class should only be used internally. Methods Method draw_blank_row {#py_cui.renderer.Renderer.draw_blank_row} def draw_blank_row(self, widget, y) Internal function for drawing a blank row Method draw_border {#py_cui.renderer.Renderer.draw_border} def draw_border(self, widget, fill=True, with_title=True) Draws border around widget Parameters fill :\u2002 bool : a flag that tells the renderer if the widget is filling its grid space, or not (ex. Textbox vs textblock) with_title :\u2002 bool : flag that tells whether or not to draw widget title Method draw_border_bottom {#py_cui.renderer.Renderer.draw_border_bottom} def draw_border_bottom(self, widget, y) Internal function for drawing bottom of border Method draw_border_top {#py_cui.renderer.Renderer.draw_border_top} def draw_border_top(self, widget, y, with_title) Internal function for drawing top of border Method draw_cursor {#py_cui.renderer.Renderer.draw_cursor} def draw_cursor(self, cursor_y, cursor_x) Draws the cursor at a particular location Method draw_text {#py_cui.renderer.Renderer.draw_text} def draw_text(self, widget, line, y, centered=False, bordered=True, selected=False, start_pos=0) Function that draws widget text. Parameters widget :\u2002 Widget : The widget being drawn line :\u2002 str : the line of text being drawn y :\u2002 int : the terminal row (top down) on which to draw the text centered :\u2002 bool : flag to set if the text should be centered bordered :\u2002 bool : a flag to set if the text should be bordered start_pos :\u2002 int : position to start rendering the text from. Method generate_text_color_fragments {#py_cui.renderer.Renderer.generate_text_color_fragments} def generate_text_color_fragments(self, widget, line, render_text) Function that applies color rules to text, dividing them if match is found Method get_render_text {#py_cui.renderer.Renderer.get_render_text} def get_render_text(self, widget, line, centered, bordered, start_pos) Internal function that computes the scope of the text that should be drawn Method reset_cursor {#py_cui.renderer.Renderer.reset_cursor} def reset_cursor(self, widget, fill=True) Positions the cursor at the bottom right of the selected widget Parameters widget :\u2002 Widget : widget for which to reset cursor fill :\u2002 bool : a flag that tells the renderer if the widget is filling its grid space, or not (ex. Textbox vs textblock) Method set_bold {#py_cui.renderer.Renderer.set_bold} def set_bold(self) Sets bold draw mode Method set_color_mode {#py_cui.renderer.Renderer.set_color_mode} def set_color_mode(self, color_mode) Sets the output color mode Method set_color_rules {#py_cui.renderer.Renderer.set_color_rules} def set_color_rules(self, color_rules) Sets current color rules Method unset_bold {#py_cui.renderer.Renderer.unset_bold} def unset_bold(self) Unsets bold draw mode Method unset_color_mode {#py_cui.renderer.Renderer.unset_color_mode} def unset_color_mode(self, color_mode) Unsets the output color mode Module py_cui.statusbar {#py_cui.statusbar} File containing class for the status bar TODO: File can probably be abstracted away - probably doesn't need a class @author: Jakub Wlodek @created: 12-Aug-2019 Classes Class StatusBar {#py_cui.statusbar.StatusBar} class StatusBar(text, color) Very simple class representing a status bar Attributes text :\u2002 str : status bar text color :\u2002 py_cui.COLOR : color to display the statusbar Constructor for statusbar Methods Method set_text {#py_cui.statusbar.StatusBar.set_text} def set_text(self, text) Sets the statusbar text Module py_cui.widget_set {#py_cui.widget_set} File containing class that abstracts a collection of widgets. It can be used to swap between collections of widgets in a py_cui @Author: Jakub Wlodek @Created 05-Oct-2019 Classes Class WidgetSet {#py_cui.widget_set.WidgetSet} class WidgetSet(num_rows, num_cols) Methods Method add_block_label {#py_cui.widget_set.WidgetSet.add_block_label} def add_block_label(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new label to the CUI grid Method add_button {#py_cui.widget_set.WidgetSet.add_button} def add_button(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, command=None) Function that adds a new button to the CUI grid Method add_checkbox_menu {#py_cui.widget_set.WidgetSet.add_checkbox_menu} def add_checkbox_menu(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, checked_char='X') Function that adds a new checkbox menu to the CUI grid Method add_key_command {#py_cui.widget_set.WidgetSet.add_key_command} def add_key_command(self, key, command) Function that adds a keybinding to the CUI when in overview mode Method add_label {#py_cui.widget_set.WidgetSet.add_label} def add_label(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new label to the CUI grid Method add_scroll_menu {#py_cui.widget_set.WidgetSet.add_scroll_menu} def add_scroll_menu(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Method add_text_block {#py_cui.widget_set.WidgetSet.add_text_block} def add_text_block(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, initial_text='') Function that adds a new text box to the CUI grid Method add_text_box {#py_cui.widget_set.WidgetSet.add_text_box} def add_text_box(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, initial_text='') Function that adds a new text box to the CUI grid Method set_selected_widget {#py_cui.widget_set.WidgetSet.set_selected_widget} def set_selected_widget(self, widget_id) Function that sets the selected cell for the CUI Parameters cell_title :\u2002 str : the title of the cell Module py_cui.widgets {#py_cui.widgets} File contatining all core widget classes for py_cui. Widgets are the basic building blocks of a user interface made with py_cui. This file contains classes for: Base Widget class Label Block Label Scroll Menu Checkbox Menu Button TextBox Text Block Additional widgets should be added in as additional_widgets/$WIDGET_NAME.py, importing this file and extending the base Widget class, or if appropriate one of the other core widgets. @author: Jakub Wlodek @created: 12-Aug-2019 Classes Class BlockLabel {#py_cui.widgets.BlockLabel} class BlockLabel(id, title, grid, row, column, row_span, column_span, padx, pady) A Variation of the label widget that renders a block of text Ancestors (in MRO) py_cui.widgets.Widget Methods Method draw {#py_cui.widgets.BlockLabel.draw} def draw(self) Override base draw class. Center text and draw it Class Button {#py_cui.widgets.Button} class Button(id, title, grid, row, column, row_span, column_span, padx, pady, command) Basic button widget. Allows for running a command function on Enter Ancestors (in MRO) py_cui.widgets.Widget Methods Method draw {#py_cui.widgets.Button.draw} def draw(self) Override of base class draw function Method handle_key_press {#py_cui.widgets.Button.handle_key_press} def handle_key_press(self, key_pressed) Override of base class, adds ENTER listener that runs the button's command Class CheckBoxMenu {#py_cui.widgets.CheckBoxMenu} class CheckBoxMenu(id, title, grid, row, column, row_span, column_span, padx, pady, checked_char) Extension of ScrollMenu that allows for multiple items to be selected at once. Ancestors (in MRO) py_cui.widgets.ScrollMenu py_cui.widgets.Widget Methods Method add_item {#py_cui.widgets.CheckBoxMenu.add_item} def add_item(self, item_text) Adds item to Checkbox Method add_item_list {#py_cui.widgets.CheckBoxMenu.add_item_list} def add_item_list(self, item_list) Adds list of items to the checkbox Method get {#py_cui.widgets.CheckBoxMenu.get} def get(self) Gets list of selected items from the checkbox Method handle_key_press {#py_cui.widgets.CheckBoxMenu.handle_key_press} def handle_key_press(self, key_pressed) Override of key presses. First, run the superclass function, scrolling should still work. Adds Enter command to toggle selection Method mark_item_as_checked {#py_cui.widgets.CheckBoxMenu.mark_item_as_checked} def mark_item_as_checked(self, text) Function that marks an item as selected Class Label {#py_cui.widgets.Label} class Label(id, title, grid, row, column, row_span, column_span, padx, pady) The most basic subclass of Widget. Simply displays one centered row of text Ancestors (in MRO) py_cui.widgets.Widget Methods Method draw {#py_cui.widgets.Label.draw} def draw(self) Override base draw class. Center text and draw it Class ScrollMenu {#py_cui.widgets.ScrollMenu} class ScrollMenu(id, title, grid, row, column, row_span, column_span, padx, pady) A scroll menu widget. Allows for creating a scrollable list of items of which one is selectable. Analogous to a RadioButton Ancestors (in MRO) py_cui.widgets.Widget Descendants py_cui.widgets.CheckBoxMenu Methods Method add_item {#py_cui.widgets.ScrollMenu.add_item} def add_item(self, item_text) Adds an item to the menu. Parameters item_text :\u2002 str : The text for the item Method add_item_list {#py_cui.widgets.ScrollMenu.add_item_list} def add_item_list(self, item_list) Adds a list of items to the scroll menu. Parameters item_list :\u2002 list of str : list of strings to add as items to the scrollmenu Method clear {#py_cui.widgets.ScrollMenu.clear} def clear(self) Clears all items from the Scroll Menu Method draw {#py_cui.widgets.ScrollMenu.draw} def draw(self) Overrides base class draw function Method get {#py_cui.widgets.ScrollMenu.get} def get(self) Function that gets the selected item from the scroll menu Returns item :\u2002 str : selected item, or None if there are no items in the menu Method get_item_list {#py_cui.widgets.ScrollMenu.get_item_list} def get_item_list(self) Function that gets list of items in a scroll menu Returns item_list :\u2002 list of str : list of items in the scrollmenu Method handle_key_press {#py_cui.widgets.ScrollMenu.handle_key_press} def handle_key_press(self, key_pressed) Override base class function. UP_ARROW scrolls up, DOWN_ARROW scrolls down Method remove_selected_item {#py_cui.widgets.ScrollMenu.remove_selected_item} def remove_selected_item(self) Function that removes the selected item from the scroll menu. Method scroll_down {#py_cui.widgets.ScrollMenu.scroll_down} def scroll_down(self) Function that scrolls the view down in the scroll menu Method scroll_up {#py_cui.widgets.ScrollMenu.scroll_up} def scroll_up(self) Function that scrolls the view up in the scroll menu Class ScrollTextBlock {#py_cui.widgets.ScrollTextBlock} class ScrollTextBlock(id, title, grid, row, column, row_span, column_span, padx, pady, initial_text) Widget for editing large multi-line blocks of text Ancestors (in MRO) py_cui.widgets.Widget Methods Method clear {#py_cui.widgets.ScrollTextBlock.clear} def clear(self) Function that clears the text block Method draw {#py_cui.widgets.ScrollTextBlock.draw} def draw(self) Override of base class draw function Method get {#py_cui.widgets.ScrollTextBlock.get} def get(self) Gets all of the text in the textblock and returns it Method get_current_line {#py_cui.widgets.ScrollTextBlock.get_current_line} def get_current_line(self) Returns the line on which the cursor currently resides Method handle_backspace {#py_cui.widgets.ScrollTextBlock.handle_backspace} def handle_backspace(self) Function that handles recieving backspace characters in the text Method handle_delete {#py_cui.widgets.ScrollTextBlock.handle_delete} def handle_delete(self) Function that handles recieving a delete keypress Method handle_end {#py_cui.widgets.ScrollTextBlock.handle_end} def handle_end(self) Function that handles recieving an end keypress Method handle_home {#py_cui.widgets.ScrollTextBlock.handle_home} def handle_home(self) Function that handles recieving a home keypress Method handle_key_press {#py_cui.widgets.ScrollTextBlock.handle_key_press} def handle_key_press(self, key_pressed) Override of base class handle key press function Method handle_newline {#py_cui.widgets.ScrollTextBlock.handle_newline} def handle_newline(self) Function that handles recieving newline characters in the text Method insert_char {#py_cui.widgets.ScrollTextBlock.insert_char} def insert_char(self, key_pressed) Function that handles recieving a character Method move_down {#py_cui.widgets.ScrollTextBlock.move_down} def move_down(self) Function that moves the cursor/text position one location down Method move_left {#py_cui.widgets.ScrollTextBlock.move_left} def move_left(self) Function that moves the cursor/text position one location to the left Method move_right {#py_cui.widgets.ScrollTextBlock.move_right} def move_right(self) Function that moves the cursor/text position one location to the right Method move_up {#py_cui.widgets.ScrollTextBlock.move_up} def move_up(self) Function that moves the cursor/text position one location up Method set_text {#py_cui.widgets.ScrollTextBlock.set_text} def set_text(self, text) Function that sets the text for the textblock. Note that this will overwrite any existing text Parameters text :\u2002 str : text to write into text block Method set_text_line {#py_cui.widgets.ScrollTextBlock.set_text_line} def set_text_line(self, text) Function that sets the current line's text. Meant only for internal use Method write {#py_cui.widgets.ScrollTextBlock.write} def write(self, text) Function used for writing text to the text block Class TextBox {#py_cui.widgets.TextBox} class TextBox(id, title, grid, row, column, row_span, column_span, padx, pady, initial_text) Widget for entering small single lines of text Ancestors (in MRO) py_cui.widgets.Widget Methods Method clear {#py_cui.widgets.TextBox.clear} def clear(self) Clears the text in the textbox Method draw {#py_cui.widgets.TextBox.draw} def draw(self) Override of base draw function Method erase_char {#py_cui.widgets.TextBox.erase_char} def erase_char(self) Erases character at textbox cursor Method get {#py_cui.widgets.TextBox.get} def get(self) Gets value of the text in the textbox Method handle_key_press {#py_cui.widgets.TextBox.handle_key_press} def handle_key_press(self, key_pressed) Override of base handle key press function Method insert_char {#py_cui.widgets.TextBox.insert_char} def insert_char(self, key_pressed) Inserts char at cursor position. Internal use only Method jump_to_end {#py_cui.widgets.TextBox.jump_to_end} def jump_to_end(self) Jumps to the end to the textbox Method jump_to_start {#py_cui.widgets.TextBox.jump_to_start} def jump_to_start(self) Jumps to the start of the textbox Method move_left {#py_cui.widgets.TextBox.move_left} def move_left(self) Shifts the cursor the the left. Internal use only Method move_right {#py_cui.widgets.TextBox.move_right} def move_right(self) Shifts the cursor the the right. Internal use only Method set_text {#py_cui.widgets.TextBox.set_text} def set_text(self, text) Sets the value of the text. Overwrites existing text Method update_height_width {#py_cui.widgets.TextBox.update_height_width} def update_height_width(self) Need to update all cursor positions on resize Class Widget {#py_cui.widgets.Widget} class Widget(id, title, grid, row, column, row_span, column_span, padx, pady, selectable=True) Top Level Widget Base Class Descendants py_cui.widgets.Label py_cui.widgets.BlockLabel py_cui.widgets.ScrollMenu py_cui.widgets.Button py_cui.widgets.TextBox py_cui.widgets.ScrollTextBlock Methods Method add_key_command {#py_cui.widgets.Widget.add_key_command} def add_key_command(self, key, command) Maps a keycode to a function that will be executed when in focus mode Parameters key :\u2002 py_cui.keys.KEY : ascii keycode used to map the key command :\u2002 function without args : a non-argument function or lambda function to execute if in focus mode and key is pressed Method add_text_color_rule {#py_cui.widgets.Widget.add_text_color_rule} def add_text_color_rule(self, regex, color, rule_type, match_type='line', region=[0, 1], include_whitespace=False) Forces renderer to draw text using given color if text_condition_function returns True Parameters rule_type :\u2002 string : A supported color rule type regex :\u2002 str : A string to check against the line for a given rule type color :\u2002 int : a supported py_cui color value match_entire_line :\u2002 bool : if true, if regex fits rule type, entire line will be colored. If false, only matching text Method assign_renderer {#py_cui.widgets.Widget.assign_renderer} def assign_renderer(self, renderer) Function that assigns a renderer object to the widget (Meant for internal usage only) Method draw {#py_cui.widgets.Widget.draw} def draw(self) Base class draw class that checks if renderer is valid. Should be called with super().draw() in overrides Method get_absolute_dims {#py_cui.widgets.Widget.get_absolute_dims} def get_absolute_dims(self) Gets the absolute dimensions of the widget in characters Method get_absolute_position {#py_cui.widgets.Widget.get_absolute_position} def get_absolute_position(self) Gets the absolute position of the widget in characters Method get_help_text {#py_cui.widgets.Widget.get_help_text} def get_help_text(self) Returns help text Method handle_key_press {#py_cui.widgets.Widget.handle_key_press} def handle_key_press(self, key_pressed) Base class function that handles all assigned key presses. When overwriting this function, make sure to add a super().handle_key_press(key_pressed) call, as this is required for user defined key command support Method is_row_col_inside {#py_cui.widgets.Widget.is_row_col_inside} def is_row_col_inside(self, row, col) Checks if a particular row + column is inside the widget area Method set_focus_text {#py_cui.widgets.Widget.set_focus_text} def set_focus_text(self, text) Function that sets the text of the status bar on focus for a particular widget Method set_selected_color {#py_cui.widgets.Widget.set_selected_color} def set_selected_color(self, color) Sets the selected color for the widget Method set_standard_color {#py_cui.widgets.Widget.set_standard_color} def set_standard_color(self, color) Sets the standard color for the widget Method update_height_width {#py_cui.widgets.Widget.update_height_width} def update_height_width(self) Function that refreshes position and dimensons on resize. If necessary, make sure required widget attributes updated here as well.","title":"Functions"},{"location":"functions/#module-py_cui-py_cui","text":"A python library for creating command line based user interfaces. @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui {#py_cui}"},{"location":"functions/#sub-modules","text":"py_cui.colors py_cui.errors py_cui.grid py_cui.keybinding py_cui.popups py_cui.renderer py_cui.statusbar py_cui.widget_set py_cui.widgets","title":"Sub-modules"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#function-fit_text-py_cuifit_text","text":"def fit_text(width, text, center=False) Helper function to fit text within a given width. Used to fix issue with status/title bar text being too long and crashing the CUI","title":"Function fit_text {#py_cui.fit_text}"},{"location":"functions/#parameters","text":"width :\u2002 int : width of window in characters text :\u2002 str : input text center :\u2002 Boolean : flag to center text","title":"Parameters"},{"location":"functions/#returns","text":"text fixed depending on width :","title":"Returns"},{"location":"functions/#classes","text":"","title":"Classes"},{"location":"functions/#class-pycui-py_cuipycui","text":"class PyCUI(num_rows, num_cols, auto_focus_buttons=True, exit_key=113) Main user interface class for py_cui. To create a user interface, you must first create an instance of this class, and then add cells + widgets to it.","title":"Class PyCUI {#py_cui.PyCUI}"},{"location":"functions/#attributes","text":"cursor_x , cursor_y :\u2002 int : absolute position of the cursor in the CUI py_cui.grid :\u2002 Grid : The main layout manager for the CUI cells :\u2002 list of py_cui.cell.Cell : list of cells in the grid title_bar :\u2002 StatusBar : a status bar object that gets drawn at the top of the CUI status_bar :\u2002 StatusBar : a status bar object that gets drawn at the bottom of the CUI keybindings :\u2002 list of py_cui.keybinding.KeyBinding : list of keybindings to check against in the main CUI loop height , width :\u2002 int : height of the terminal in characters, width of terminal in characters exit_key :\u2002 key_code : a key code for a key that exits the CUI","title":"Attributes"},{"location":"functions/#methods","text":"start() starts the CUI once all of the widgets have been added. Note that you cannot add more widgets once this has been run add_status_bar(text : str, foreground_color : color, background_color : color) function that adds a status bar widget to the CUI","title":"Methods"},{"location":"functions/#methods_1","text":"","title":"Methods"},{"location":"functions/#method-add_block_label-py_cuipycuiadd_block_label","text":"def add_block_label(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new label to the CUI grid","title":"Method add_block_label {#py_cui.PyCUI.add_block_label}"},{"location":"functions/#method-add_button-py_cuipycuiadd_button","text":"def add_button(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, command=None) Function that adds a new button to the CUI grid","title":"Method add_button {#py_cui.PyCUI.add_button}"},{"location":"functions/#method-add_checkbox_menu-py_cuipycuiadd_checkbox_menu","text":"def add_checkbox_menu(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, checked_char='X') Function that adds a new checkbox menu to the CUI grid","title":"Method add_checkbox_menu {#py_cui.PyCUI.add_checkbox_menu}"},{"location":"functions/#method-add_key_command-py_cuipycuiadd_key_command","text":"def add_key_command(self, key, command) Function that adds a keybinding to the CUI when in overview mode","title":"Method add_key_command {#py_cui.PyCUI.add_key_command}"},{"location":"functions/#method-add_label-py_cuipycuiadd_label","text":"def add_label(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new label to the CUI grid","title":"Method add_label {#py_cui.PyCUI.add_label}"},{"location":"functions/#method-add_scroll_menu-py_cuipycuiadd_scroll_menu","text":"def add_scroll_menu(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new scroll menu to the CUI grid","title":"Method add_scroll_menu {#py_cui.PyCUI.add_scroll_menu}"},{"location":"functions/#method-add_text_block-py_cuipycuiadd_text_block","text":"def add_text_block(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, initial_text='') Function that adds a new text box to the CUI grid","title":"Method add_text_block {#py_cui.PyCUI.add_text_block}"},{"location":"functions/#method-add_text_box-py_cuipycuiadd_text_box","text":"def add_text_box(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, initial_text='') Function that adds a new text box to the CUI grid","title":"Method add_text_box {#py_cui.PyCUI.add_text_box}"},{"location":"functions/#method-apply_widget_set-py_cuipycuiapply_widget_set","text":"def apply_widget_set(self, new_widget_set) Function that can be used to replace all widgets in a py_cui with those of a different widget set","title":"Method apply_widget_set {#py_cui.PyCUI.apply_widget_set}"},{"location":"functions/#method-check_if_neighbor_exists-py_cuipycuicheck_if_neighbor_exists","text":"def check_if_neighbor_exists(self, row, column, row_span, col_span, direction) Function that checks if widget has neighbor in specified cell. Used for navigating CUI","title":"Method check_if_neighbor_exists {#py_cui.PyCUI.check_if_neighbor_exists}"},{"location":"functions/#method-close_popup-py_cuipycuiclose_popup","text":"def close_popup(self) Closes the popup, and resets focus","title":"Method close_popup {#py_cui.PyCUI.close_popup}"},{"location":"functions/#method-display_window_warning-py_cuipycuidisplay_window_warning","text":"def display_window_warning(self, stdscr, error_info) Function that prints some basic error info if there is an error with the CUI","title":"Method display_window_warning {#py_cui.PyCUI.display_window_warning}"},{"location":"functions/#method-draw-py_cuipycuidraw","text":"def draw(self, stdscr) Main CUI draw loop called by start()","title":"Method draw {#py_cui.PyCUI.draw}"},{"location":"functions/#method-draw_status_bars-py_cuipycuidraw_status_bars","text":"def draw_status_bars(self, stdscr, height, width) Draws status bar and title bar","title":"Method draw_status_bars {#py_cui.PyCUI.draw_status_bars}"},{"location":"functions/#method-draw_widgets-py_cuipycuidraw_widgets","text":"def draw_widgets(self) Function that draws all of the widgets to the screen","title":"Method draw_widgets {#py_cui.PyCUI.draw_widgets}"},{"location":"functions/#method-get_widget_set-py_cuipycuiget_widget_set","text":"def get_widget_set(self) Gets widget set object from current widgets.","title":"Method get_widget_set {#py_cui.PyCUI.get_widget_set}"},{"location":"functions/#method-handle_key_presses-py_cuipycuihandle_key_presses","text":"def handle_key_presses(self, key_pressed) Function that handles all main loop key presses.","title":"Method handle_key_presses {#py_cui.PyCUI.handle_key_presses}"},{"location":"functions/#method-increment_loading_bar-py_cuipycuiincrement_loading_bar","text":"def increment_loading_bar(self) Increments progress bar if loading bar popup is open","title":"Method increment_loading_bar {#py_cui.PyCUI.increment_loading_bar}"},{"location":"functions/#method-initialize_colors-py_cuipycuiinitialize_colors","text":"def initialize_colors(self) Function for initialzing curses colors. Called when CUI is first created.","title":"Method initialize_colors {#py_cui.PyCUI.initialize_colors}"},{"location":"functions/#method-initialize_widget_renderer-py_cuipycuiinitialize_widget_renderer","text":"def initialize_widget_renderer(self) Function that creates the renderer object that will draw each widget","title":"Method initialize_widget_renderer {#py_cui.PyCUI.initialize_widget_renderer}"},{"location":"functions/#method-lose_focus-py_cuipycuilose_focus","text":"def lose_focus(self) Function that forces py_cui out of focus mode. After popup is called, focus is lost","title":"Method lose_focus {#py_cui.PyCUI.lose_focus}"},{"location":"functions/#method-refresh_height_width-py_cuipycuirefresh_height_width","text":"def refresh_height_width(self, height, width) Function that updates the height and width of the CUI based on terminal window size","title":"Method refresh_height_width {#py_cui.PyCUI.refresh_height_width}"},{"location":"functions/#method-set_selected_widget-py_cuipycuiset_selected_widget","text":"def set_selected_widget(self, widget_id) Function that sets the selected cell for the CUI","title":"Method set_selected_widget {#py_cui.PyCUI.set_selected_widget}"},{"location":"functions/#parameters_1","text":"cell_title :\u2002 str : the title of the cell","title":"Parameters"},{"location":"functions/#method-set_status_bar_text-py_cuipycuiset_status_bar_text","text":"def set_status_bar_text(self, text) Sets the status bar text when in overview mode","title":"Method set_status_bar_text {#py_cui.PyCUI.set_status_bar_text}"},{"location":"functions/#method-set_title-py_cuipycuiset_title","text":"def set_title(self, title) Sets the title bar text","title":"Method set_title {#py_cui.PyCUI.set_title}"},{"location":"functions/#method-show_error_popup-py_cuipycuishow_error_popup","text":"def show_error_popup(self, title, text) Shows an error popup","title":"Method show_error_popup {#py_cui.PyCUI.show_error_popup}"},{"location":"functions/#method-show_loading_bar_popup-py_cuipycuishow_loading_bar_popup","text":"def show_loading_bar_popup(self, title, num_items) Shows loading bar popup. Use 'increment_loading_bar' to show progress","title":"Method show_loading_bar_popup {#py_cui.PyCUI.show_loading_bar_popup}"},{"location":"functions/#method-show_loading_icon_popup-py_cuipycuishow_loading_icon_popup","text":"def show_loading_icon_popup(self, title, message) Shows a loading icon popup","title":"Method show_loading_icon_popup {#py_cui.PyCUI.show_loading_icon_popup}"},{"location":"functions/#method-show_menu_popup-py_cuipycuishow_menu_popup","text":"def show_menu_popup(self, title, menu_items, command, run_command_if_none=False) Shows a yes/no popup. The 'command' parameter must be a function with a single boolean parameter","title":"Method show_menu_popup {#py_cui.PyCUI.show_menu_popup}"},{"location":"functions/#method-show_message_popup-py_cuipycuishow_message_popup","text":"def show_message_popup(self, title, text) Shows a message popup","title":"Method show_message_popup {#py_cui.PyCUI.show_message_popup}"},{"location":"functions/#method-show_text_box_popup-py_cuipycuishow_text_box_popup","text":"def show_text_box_popup(self, title, command) Shows a yes/no popup. The 'command' parameter must be a function with a single boolean parameter","title":"Method show_text_box_popup {#py_cui.PyCUI.show_text_box_popup}"},{"location":"functions/#method-show_warning_popup-py_cuipycuishow_warning_popup","text":"def show_warning_popup(self, title, text) Shows a warning popup","title":"Method show_warning_popup {#py_cui.PyCUI.show_warning_popup}"},{"location":"functions/#method-show_yes_no_popup-py_cuipycuishow_yes_no_popup","text":"def show_yes_no_popup(self, title, command) Shows a yes/no popup. The 'command' parameter must be a function with a single boolean parameter","title":"Method show_yes_no_popup {#py_cui.PyCUI.show_yes_no_popup}"},{"location":"functions/#method-start-py_cuipycuistart","text":"def start(self) Function that starts the CUI","title":"Method start {#py_cui.PyCUI.start}"},{"location":"functions/#method-stop-py_cuipycuistop","text":"def stop(self, callback=None) Function that stops the CUI, and fires the callback function. Callback must be a no arg method","title":"Method stop {#py_cui.PyCUI.stop}"},{"location":"functions/#method-stop_loading_popup-py_cuipycuistop_loading_popup","text":"def stop_loading_popup(self) Leaves loading state, and closes popup. Must be called by user to escape loading.","title":"Method stop_loading_popup {#py_cui.PyCUI.stop_loading_popup}"},{"location":"functions/#module-py_cuicolors-py_cuicolors","text":"File containing all error types for py_cui @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui.colors {#py_cui.colors}"},{"location":"functions/#classes_1","text":"","title":"Classes"},{"location":"functions/#class-colorrule-py_cuicolorscolorrule","text":"class ColorRule(regex, color, rule_type, match_type, region, include_whitespace)","title":"Class ColorRule {#py_cui.colors.ColorRule}"},{"location":"functions/#methods_2","text":"","title":"Methods"},{"location":"functions/#method-check_match-py_cuicolorscolorrulecheck_match","text":"def check_match(self, line) Checks if the color rule matches a line","title":"Method check_match {#py_cui.colors.ColorRule.check_match}"},{"location":"functions/#method-generate_fragments-py_cuicolorscolorrulegenerate_fragments","text":"def generate_fragments(self, widget, line, render_text)","title":"Method generate_fragments {#py_cui.colors.ColorRule.generate_fragments}"},{"location":"functions/#method-generate_fragments_regex-py_cuicolorscolorrulegenerate_fragments_regex","text":"def generate_fragments_regex(self, widget, render_text) Splits text into fragments based on regular expression","title":"Method generate_fragments_regex {#py_cui.colors.ColorRule.generate_fragments_regex}"},{"location":"functions/#method-split_text_on_region-py_cuicolorscolorrulesplit_text_on_region","text":"def split_text_on_region(self, widget, render_text) Splits text into fragments based on region","title":"Method split_text_on_region {#py_cui.colors.ColorRule.split_text_on_region}"},{"location":"functions/#module-py_cuierrors-py_cuierrors","text":"File containing all error types for py_cui @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui.errors {#py_cui.errors}"},{"location":"functions/#classes_2","text":"","title":"Classes"},{"location":"functions/#class-pycuierror-py_cuierrorspycuierror","text":"class PyCUIError(*args, **kwargs) General error","title":"Class PyCUIError {#py_cui.errors.PyCUIError}"},{"location":"functions/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"functions/#class-pycuimissingchilderror-py_cuierrorspycuimissingchilderror","text":"class PyCUIMissingChildError(*args, **kwargs) Error for when child widget is None or invalid","title":"Class PyCUIMissingChildError {#py_cui.errors.PyCUIMissingChildError}"},{"location":"functions/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"functions/#class-pycuimissingparenterror-py_cuierrorspycuimissingparenterror","text":"class PyCUIMissingParentError(*args, **kwargs) Error for when parent widget is None or invalid","title":"Class PyCUIMissingParentError {#py_cui.errors.PyCUIMissingParentError}"},{"location":"functions/#ancestors-in-mro_2","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"functions/#class-pycuioutofboundserror-py_cuierrorspycuioutofboundserror","text":"class PyCUIOutOfBoundsError(*args, **kwargs) Error for when widget or text goes off of the py_cui grid","title":"Class PyCUIOutOfBoundsError {#py_cui.errors.PyCUIOutOfBoundsError}"},{"location":"functions/#ancestors-in-mro_3","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"functions/#module-py_cuigrid-py_cuigrid","text":"File containing the Grid Class. The grid is currently the only supported layout manager for py_cui @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui.grid {#py_cui.grid}"},{"location":"functions/#classes_3","text":"","title":"Classes"},{"location":"functions/#class-grid-py_cuigridgrid","text":"class Grid(num_rows, num_columns, height, width)","title":"Class Grid {#py_cui.grid.Grid}"},{"location":"functions/#methods_3","text":"","title":"Methods"},{"location":"functions/#method-set_num_cols-py_cuigridgridset_num_cols","text":"def set_num_cols(self, num_columns) Sets the grid column size","title":"Method set_num_cols {#py_cui.grid.Grid.set_num_cols}"},{"location":"functions/#method-set_num_rows-py_cuigridgridset_num_rows","text":"def set_num_rows(self, num_rows) Sets the grid row size","title":"Method set_num_rows {#py_cui.grid.Grid.set_num_rows}"},{"location":"functions/#method-update_grid_height_width-py_cuigridgridupdate_grid_height_width","text":"def update_grid_height_width(self, height, width) Update grid height and width. Allows for on-the-fly size editing","title":"Method update_grid_height_width {#py_cui.grid.Grid.update_grid_height_width}"},{"location":"functions/#module-py_cuikeybinding-py_cuikeybinding","text":"File containing constants and helper functions for dealing with keys @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui.keybinding {#py_cui.keybinding}"},{"location":"functions/#functions_1","text":"","title":"Functions"},{"location":"functions/#function-get_ascii_from_char-py_cuikeybindingget_ascii_from_char","text":"def get_ascii_from_char(char)","title":"Function get_ascii_from_char {#py_cui.keybinding.get_ascii_from_char}"},{"location":"functions/#function-get_char_from_ascii-py_cuikeybindingget_char_from_ascii","text":"def get_char_from_ascii(key_num)","title":"Function get_char_from_ascii {#py_cui.keybinding.get_char_from_ascii}"},{"location":"functions/#module-py_cuipopups-py_cuipopups","text":"File containing classes for all popups used by py_cui @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui.popups {#py_cui.popups}"},{"location":"functions/#classes_4","text":"","title":"Classes"},{"location":"functions/#class-loadingbarpopup-py_cuipopupsloadingbarpopup","text":"class LoadingBarPopup(root, title, num_items, color, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame","title":"Class LoadingBarPopup {#py_cui.popups.LoadingBarPopup}"},{"location":"functions/#attributes_1","text":"root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup","title":"Attributes"},{"location":"functions/#methods_4","text":"handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class","title":"Methods"},{"location":"functions/#ancestors-in-mro_4","text":"py_cui.popups.Popup","title":"Ancestors (in MRO)"},{"location":"functions/#class-loadingiconpopup-py_cuipopupsloadingiconpopup","text":"class LoadingIconPopup(root, title, message, color, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame","title":"Class LoadingIconPopup {#py_cui.popups.LoadingIconPopup}"},{"location":"functions/#attributes_2","text":"root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup","title":"Attributes"},{"location":"functions/#methods_5","text":"handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class","title":"Methods"},{"location":"functions/#ancestors-in-mro_5","text":"py_cui.popups.Popup","title":"Ancestors (in MRO)"},{"location":"functions/#class-menupopup-py_cuipopupsmenupopup","text":"class MenuPopup(root, items, title, color, command, renderer, run_command_if_none) A scroll menu widget. Allows for creating a scrollable list of items of which one is selectable. Analogous to a RadioButton Constructor for popup class","title":"Class MenuPopup {#py_cui.popups.MenuPopup}"},{"location":"functions/#ancestors-in-mro_6","text":"py_cui.popups.Popup","title":"Ancestors (in MRO)"},{"location":"functions/#methods_6","text":"","title":"Methods"},{"location":"functions/#method-draw-py_cuipopupsmenupopupdraw","text":"def draw(self) Overrides base class draw function","title":"Method draw {#py_cui.popups.MenuPopup.draw}"},{"location":"functions/#method-get-py_cuipopupsmenupopupget","text":"def get(self) Function that gets the selected item from the scroll menu","title":"Method get {#py_cui.popups.MenuPopup.get}"},{"location":"functions/#returns_1","text":"item :\u2002 str : selected item, or None if there are no items in the menu","title":"Returns"},{"location":"functions/#method-handle_key_press-py_cuipopupsmenupopuphandle_key_press","text":"def handle_key_press(self, key_pressed) Override of base handle key press function","title":"Method handle_key_press {#py_cui.popups.MenuPopup.handle_key_press}"},{"location":"functions/#method-scroll_down-py_cuipopupsmenupopupscroll_down","text":"def scroll_down(self) Function that scrolls the view down in the scroll menu","title":"Method scroll_down {#py_cui.popups.MenuPopup.scroll_down}"},{"location":"functions/#method-scroll_up-py_cuipopupsmenupopupscroll_up","text":"def scroll_up(self) Function that scrolls the view up in the scroll menu","title":"Method scroll_up {#py_cui.popups.MenuPopup.scroll_up}"},{"location":"functions/#class-messagepopup-py_cuipopupsmessagepopup","text":"class MessagePopup(root, title, text, color, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame","title":"Class MessagePopup {#py_cui.popups.MessagePopup}"},{"location":"functions/#attributes_3","text":"root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup","title":"Attributes"},{"location":"functions/#methods_7","text":"handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class","title":"Methods"},{"location":"functions/#ancestors-in-mro_7","text":"py_cui.popups.Popup","title":"Ancestors (in MRO)"},{"location":"functions/#class-popup-py_cuipopupspopup","text":"class Popup(root, title, text, color, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame","title":"Class Popup {#py_cui.popups.Popup}"},{"location":"functions/#attributes_4","text":"root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup","title":"Attributes"},{"location":"functions/#methods_8","text":"handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class","title":"Methods"},{"location":"functions/#descendants","text":"py_cui.popups.MessagePopup py_cui.popups.YesNoPopup py_cui.popups.TextBoxPopup py_cui.popups.MenuPopup py_cui.popups.LoadingIconPopup py_cui.popups.LoadingBarPopup","title":"Descendants"},{"location":"functions/#methods_9","text":"","title":"Methods"},{"location":"functions/#method-draw-py_cuipopupspopupdraw","text":"def draw(self) Must be implemented by subclass","title":"Method draw {#py_cui.popups.Popup.draw}"},{"location":"functions/#method-handle_key_press-py_cuipopupspopuphandle_key_press","text":"def handle_key_press(self, key_pressed) Must be implemented by subclass","title":"Method handle_key_press {#py_cui.popups.Popup.handle_key_press}"},{"location":"functions/#class-textboxpopup-py_cuipopupstextboxpopup","text":"class TextBoxPopup(root, title, color, command, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame","title":"Class TextBoxPopup {#py_cui.popups.TextBoxPopup}"},{"location":"functions/#attributes_5","text":"root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup","title":"Attributes"},{"location":"functions/#methods_10","text":"handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class","title":"Methods"},{"location":"functions/#ancestors-in-mro_8","text":"py_cui.popups.Popup","title":"Ancestors (in MRO)"},{"location":"functions/#methods_11","text":"","title":"Methods"},{"location":"functions/#method-clear-py_cuipopupstextboxpopupclear","text":"def clear(self) Clears the text in the textbox","title":"Method clear {#py_cui.popups.TextBoxPopup.clear}"},{"location":"functions/#method-draw-py_cuipopupstextboxpopupdraw","text":"def draw(self) Override of base draw function","title":"Method draw {#py_cui.popups.TextBoxPopup.draw}"},{"location":"functions/#method-erase_char-py_cuipopupstextboxpopuperase_char","text":"def erase_char(self) Erases character at textbox cursor","title":"Method erase_char {#py_cui.popups.TextBoxPopup.erase_char}"},{"location":"functions/#method-get-py_cuipopupstextboxpopupget","text":"def get(self) Gets value of the text in the textbox","title":"Method get {#py_cui.popups.TextBoxPopup.get}"},{"location":"functions/#method-handle_key_press-py_cuipopupstextboxpopuphandle_key_press","text":"def handle_key_press(self, key_pressed) Override of base handle key press function","title":"Method handle_key_press {#py_cui.popups.TextBoxPopup.handle_key_press}"},{"location":"functions/#method-insert_char-py_cuipopupstextboxpopupinsert_char","text":"def insert_char(self, key_pressed) Inserts char at cursor position. Internal use only","title":"Method insert_char {#py_cui.popups.TextBoxPopup.insert_char}"},{"location":"functions/#method-jump_to_end-py_cuipopupstextboxpopupjump_to_end","text":"def jump_to_end(self) Jumps to the end to the textbox","title":"Method jump_to_end {#py_cui.popups.TextBoxPopup.jump_to_end}"},{"location":"functions/#method-jump_to_start-py_cuipopupstextboxpopupjump_to_start","text":"def jump_to_start(self) Jumps to the start of the textbox","title":"Method jump_to_start {#py_cui.popups.TextBoxPopup.jump_to_start}"},{"location":"functions/#method-move_left-py_cuipopupstextboxpopupmove_left","text":"def move_left(self) Shifts the cursor the the left. Internal use only","title":"Method move_left {#py_cui.popups.TextBoxPopup.move_left}"},{"location":"functions/#method-move_right-py_cuipopupstextboxpopupmove_right","text":"def move_right(self) Shifts the cursor the the right. Internal use only","title":"Method move_right {#py_cui.popups.TextBoxPopup.move_right}"},{"location":"functions/#method-set_text-py_cuipopupstextboxpopupset_text","text":"def set_text(self, text) Sets the value of the text. Overwrites existing text","title":"Method set_text {#py_cui.popups.TextBoxPopup.set_text}"},{"location":"functions/#class-yesnopopup-py_cuipopupsyesnopopup","text":"class YesNoPopup(root, title, text, color, command, renderer) Base popup class. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame","title":"Class YesNoPopup {#py_cui.popups.YesNoPopup}"},{"location":"functions/#attributes_6","text":"root :\u2002 PyCUI : the root py_cui window title , text :\u2002 str : The message title and text color :\u2002 int : The py_cui color code start_x , start_y :\u2002 int : top left corner of the popup stop_x , stop_y :\u2002 int : bottom right corner of the popup","title":"Attributes"},{"location":"functions/#methods_12","text":"handle_key_press() Implemented by each subclass, handles key presses draw() Implemented by each subclass, draws the popup to the terminal Constructor for popup class","title":"Methods"},{"location":"functions/#ancestors-in-mro_9","text":"py_cui.popups.Popup","title":"Ancestors (in MRO)"},{"location":"functions/#module-py_cuirenderer-py_cuirenderer","text":"File containing the py_cui renderer. It is used to draw all of the onscreen widgets and items. @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui.renderer {#py_cui.renderer}"},{"location":"functions/#classes_5","text":"","title":"Classes"},{"location":"functions/#class-renderer-py_cuirendererrenderer","text":"class Renderer(root, stdscr) Main renderer class used for drawing widgets to the terminal. Has helper functions for drawing the borders, cursor, and text required for the cui. All of the functions supplied by the renderer class should only be used internally.","title":"Class Renderer {#py_cui.renderer.Renderer}"},{"location":"functions/#methods_13","text":"","title":"Methods"},{"location":"functions/#method-draw_blank_row-py_cuirendererrendererdraw_blank_row","text":"def draw_blank_row(self, widget, y) Internal function for drawing a blank row","title":"Method draw_blank_row {#py_cui.renderer.Renderer.draw_blank_row}"},{"location":"functions/#method-draw_border-py_cuirendererrendererdraw_border","text":"def draw_border(self, widget, fill=True, with_title=True) Draws border around widget","title":"Method draw_border {#py_cui.renderer.Renderer.draw_border}"},{"location":"functions/#parameters_2","text":"fill :\u2002 bool : a flag that tells the renderer if the widget is filling its grid space, or not (ex. Textbox vs textblock) with_title :\u2002 bool : flag that tells whether or not to draw widget title","title":"Parameters"},{"location":"functions/#method-draw_border_bottom-py_cuirendererrendererdraw_border_bottom","text":"def draw_border_bottom(self, widget, y) Internal function for drawing bottom of border","title":"Method draw_border_bottom {#py_cui.renderer.Renderer.draw_border_bottom}"},{"location":"functions/#method-draw_border_top-py_cuirendererrendererdraw_border_top","text":"def draw_border_top(self, widget, y, with_title) Internal function for drawing top of border","title":"Method draw_border_top {#py_cui.renderer.Renderer.draw_border_top}"},{"location":"functions/#method-draw_cursor-py_cuirendererrendererdraw_cursor","text":"def draw_cursor(self, cursor_y, cursor_x) Draws the cursor at a particular location","title":"Method draw_cursor {#py_cui.renderer.Renderer.draw_cursor}"},{"location":"functions/#method-draw_text-py_cuirendererrendererdraw_text","text":"def draw_text(self, widget, line, y, centered=False, bordered=True, selected=False, start_pos=0) Function that draws widget text.","title":"Method draw_text {#py_cui.renderer.Renderer.draw_text}"},{"location":"functions/#parameters_3","text":"widget :\u2002 Widget : The widget being drawn line :\u2002 str : the line of text being drawn y :\u2002 int : the terminal row (top down) on which to draw the text centered :\u2002 bool : flag to set if the text should be centered bordered :\u2002 bool : a flag to set if the text should be bordered start_pos :\u2002 int : position to start rendering the text from.","title":"Parameters"},{"location":"functions/#method-generate_text_color_fragments-py_cuirendererrenderergenerate_text_color_fragments","text":"def generate_text_color_fragments(self, widget, line, render_text) Function that applies color rules to text, dividing them if match is found","title":"Method generate_text_color_fragments {#py_cui.renderer.Renderer.generate_text_color_fragments}"},{"location":"functions/#method-get_render_text-py_cuirendererrendererget_render_text","text":"def get_render_text(self, widget, line, centered, bordered, start_pos) Internal function that computes the scope of the text that should be drawn","title":"Method get_render_text {#py_cui.renderer.Renderer.get_render_text}"},{"location":"functions/#method-reset_cursor-py_cuirendererrendererreset_cursor","text":"def reset_cursor(self, widget, fill=True) Positions the cursor at the bottom right of the selected widget","title":"Method reset_cursor {#py_cui.renderer.Renderer.reset_cursor}"},{"location":"functions/#parameters_4","text":"widget :\u2002 Widget : widget for which to reset cursor fill :\u2002 bool : a flag that tells the renderer if the widget is filling its grid space, or not (ex. Textbox vs textblock)","title":"Parameters"},{"location":"functions/#method-set_bold-py_cuirendererrendererset_bold","text":"def set_bold(self) Sets bold draw mode","title":"Method set_bold {#py_cui.renderer.Renderer.set_bold}"},{"location":"functions/#method-set_color_mode-py_cuirendererrendererset_color_mode","text":"def set_color_mode(self, color_mode) Sets the output color mode","title":"Method set_color_mode {#py_cui.renderer.Renderer.set_color_mode}"},{"location":"functions/#method-set_color_rules-py_cuirendererrendererset_color_rules","text":"def set_color_rules(self, color_rules) Sets current color rules","title":"Method set_color_rules {#py_cui.renderer.Renderer.set_color_rules}"},{"location":"functions/#method-unset_bold-py_cuirendererrendererunset_bold","text":"def unset_bold(self) Unsets bold draw mode","title":"Method unset_bold {#py_cui.renderer.Renderer.unset_bold}"},{"location":"functions/#method-unset_color_mode-py_cuirendererrendererunset_color_mode","text":"def unset_color_mode(self, color_mode) Unsets the output color mode","title":"Method unset_color_mode {#py_cui.renderer.Renderer.unset_color_mode}"},{"location":"functions/#module-py_cuistatusbar-py_cuistatusbar","text":"File containing class for the status bar TODO: File can probably be abstracted away - probably doesn't need a class @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui.statusbar {#py_cui.statusbar}"},{"location":"functions/#classes_6","text":"","title":"Classes"},{"location":"functions/#class-statusbar-py_cuistatusbarstatusbar","text":"class StatusBar(text, color) Very simple class representing a status bar","title":"Class StatusBar {#py_cui.statusbar.StatusBar}"},{"location":"functions/#attributes_7","text":"text :\u2002 str : status bar text color :\u2002 py_cui.COLOR : color to display the statusbar Constructor for statusbar","title":"Attributes"},{"location":"functions/#methods_14","text":"","title":"Methods"},{"location":"functions/#method-set_text-py_cuistatusbarstatusbarset_text","text":"def set_text(self, text) Sets the statusbar text","title":"Method set_text {#py_cui.statusbar.StatusBar.set_text}"},{"location":"functions/#module-py_cuiwidget_set-py_cuiwidget_set","text":"File containing class that abstracts a collection of widgets. It can be used to swap between collections of widgets in a py_cui @Author: Jakub Wlodek @Created 05-Oct-2019","title":"Module py_cui.widget_set {#py_cui.widget_set}"},{"location":"functions/#classes_7","text":"","title":"Classes"},{"location":"functions/#class-widgetset-py_cuiwidget_setwidgetset","text":"class WidgetSet(num_rows, num_cols)","title":"Class WidgetSet {#py_cui.widget_set.WidgetSet}"},{"location":"functions/#methods_15","text":"","title":"Methods"},{"location":"functions/#method-add_block_label-py_cuiwidget_setwidgetsetadd_block_label","text":"def add_block_label(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new label to the CUI grid","title":"Method add_block_label {#py_cui.widget_set.WidgetSet.add_block_label}"},{"location":"functions/#method-add_button-py_cuiwidget_setwidgetsetadd_button","text":"def add_button(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, command=None) Function that adds a new button to the CUI grid","title":"Method add_button {#py_cui.widget_set.WidgetSet.add_button}"},{"location":"functions/#method-add_checkbox_menu-py_cuiwidget_setwidgetsetadd_checkbox_menu","text":"def add_checkbox_menu(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, checked_char='X') Function that adds a new checkbox menu to the CUI grid","title":"Method add_checkbox_menu {#py_cui.widget_set.WidgetSet.add_checkbox_menu}"},{"location":"functions/#method-add_key_command-py_cuiwidget_setwidgetsetadd_key_command","text":"def add_key_command(self, key, command) Function that adds a keybinding to the CUI when in overview mode","title":"Method add_key_command {#py_cui.widget_set.WidgetSet.add_key_command}"},{"location":"functions/#method-add_label-py_cuiwidget_setwidgetsetadd_label","text":"def add_label(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0) Function that adds a new label to the CUI grid","title":"Method add_label {#py_cui.widget_set.WidgetSet.add_label}"},{"location":"functions/#method-add_scroll_menu-py_cuiwidget_setwidgetsetadd_scroll_menu","text":"def add_scroll_menu(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0)","title":"Method add_scroll_menu {#py_cui.widget_set.WidgetSet.add_scroll_menu}"},{"location":"functions/#method-add_text_block-py_cuiwidget_setwidgetsetadd_text_block","text":"def add_text_block(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, initial_text='') Function that adds a new text box to the CUI grid","title":"Method add_text_block {#py_cui.widget_set.WidgetSet.add_text_block}"},{"location":"functions/#method-add_text_box-py_cuiwidget_setwidgetsetadd_text_box","text":"def add_text_box(self, title, row, column, row_span=1, column_span=1, padx=1, pady=0, initial_text='') Function that adds a new text box to the CUI grid","title":"Method add_text_box {#py_cui.widget_set.WidgetSet.add_text_box}"},{"location":"functions/#method-set_selected_widget-py_cuiwidget_setwidgetsetset_selected_widget","text":"def set_selected_widget(self, widget_id) Function that sets the selected cell for the CUI","title":"Method set_selected_widget {#py_cui.widget_set.WidgetSet.set_selected_widget}"},{"location":"functions/#parameters_5","text":"cell_title :\u2002 str : the title of the cell","title":"Parameters"},{"location":"functions/#module-py_cuiwidgets-py_cuiwidgets","text":"File contatining all core widget classes for py_cui. Widgets are the basic building blocks of a user interface made with py_cui. This file contains classes for: Base Widget class Label Block Label Scroll Menu Checkbox Menu Button TextBox Text Block Additional widgets should be added in as additional_widgets/$WIDGET_NAME.py, importing this file and extending the base Widget class, or if appropriate one of the other core widgets. @author: Jakub Wlodek @created: 12-Aug-2019","title":"Module py_cui.widgets {#py_cui.widgets}"},{"location":"functions/#classes_8","text":"","title":"Classes"},{"location":"functions/#class-blocklabel-py_cuiwidgetsblocklabel","text":"class BlockLabel(id, title, grid, row, column, row_span, column_span, padx, pady) A Variation of the label widget that renders a block of text","title":"Class BlockLabel {#py_cui.widgets.BlockLabel}"},{"location":"functions/#ancestors-in-mro_10","text":"py_cui.widgets.Widget","title":"Ancestors (in MRO)"},{"location":"functions/#methods_16","text":"","title":"Methods"},{"location":"functions/#method-draw-py_cuiwidgetsblocklabeldraw","text":"def draw(self) Override base draw class. Center text and draw it","title":"Method draw {#py_cui.widgets.BlockLabel.draw}"},{"location":"functions/#class-button-py_cuiwidgetsbutton","text":"class Button(id, title, grid, row, column, row_span, column_span, padx, pady, command) Basic button widget. Allows for running a command function on Enter","title":"Class Button {#py_cui.widgets.Button}"},{"location":"functions/#ancestors-in-mro_11","text":"py_cui.widgets.Widget","title":"Ancestors (in MRO)"},{"location":"functions/#methods_17","text":"","title":"Methods"},{"location":"functions/#method-draw-py_cuiwidgetsbuttondraw","text":"def draw(self) Override of base class draw function","title":"Method draw {#py_cui.widgets.Button.draw}"},{"location":"functions/#method-handle_key_press-py_cuiwidgetsbuttonhandle_key_press","text":"def handle_key_press(self, key_pressed) Override of base class, adds ENTER listener that runs the button's command","title":"Method handle_key_press {#py_cui.widgets.Button.handle_key_press}"},{"location":"functions/#class-checkboxmenu-py_cuiwidgetscheckboxmenu","text":"class CheckBoxMenu(id, title, grid, row, column, row_span, column_span, padx, pady, checked_char) Extension of ScrollMenu that allows for multiple items to be selected at once.","title":"Class CheckBoxMenu {#py_cui.widgets.CheckBoxMenu}"},{"location":"functions/#ancestors-in-mro_12","text":"py_cui.widgets.ScrollMenu py_cui.widgets.Widget","title":"Ancestors (in MRO)"},{"location":"functions/#methods_18","text":"","title":"Methods"},{"location":"functions/#method-add_item-py_cuiwidgetscheckboxmenuadd_item","text":"def add_item(self, item_text) Adds item to Checkbox","title":"Method add_item {#py_cui.widgets.CheckBoxMenu.add_item}"},{"location":"functions/#method-add_item_list-py_cuiwidgetscheckboxmenuadd_item_list","text":"def add_item_list(self, item_list) Adds list of items to the checkbox","title":"Method add_item_list {#py_cui.widgets.CheckBoxMenu.add_item_list}"},{"location":"functions/#method-get-py_cuiwidgetscheckboxmenuget","text":"def get(self) Gets list of selected items from the checkbox","title":"Method get {#py_cui.widgets.CheckBoxMenu.get}"},{"location":"functions/#method-handle_key_press-py_cuiwidgetscheckboxmenuhandle_key_press","text":"def handle_key_press(self, key_pressed) Override of key presses. First, run the superclass function, scrolling should still work. Adds Enter command to toggle selection","title":"Method handle_key_press {#py_cui.widgets.CheckBoxMenu.handle_key_press}"},{"location":"functions/#method-mark_item_as_checked-py_cuiwidgetscheckboxmenumark_item_as_checked","text":"def mark_item_as_checked(self, text) Function that marks an item as selected","title":"Method mark_item_as_checked {#py_cui.widgets.CheckBoxMenu.mark_item_as_checked}"},{"location":"functions/#class-label-py_cuiwidgetslabel","text":"class Label(id, title, grid, row, column, row_span, column_span, padx, pady) The most basic subclass of Widget. Simply displays one centered row of text","title":"Class Label {#py_cui.widgets.Label}"},{"location":"functions/#ancestors-in-mro_13","text":"py_cui.widgets.Widget","title":"Ancestors (in MRO)"},{"location":"functions/#methods_19","text":"","title":"Methods"},{"location":"functions/#method-draw-py_cuiwidgetslabeldraw","text":"def draw(self) Override base draw class. Center text and draw it","title":"Method draw {#py_cui.widgets.Label.draw}"},{"location":"functions/#class-scrollmenu-py_cuiwidgetsscrollmenu","text":"class ScrollMenu(id, title, grid, row, column, row_span, column_span, padx, pady) A scroll menu widget. Allows for creating a scrollable list of items of which one is selectable. Analogous to a RadioButton","title":"Class ScrollMenu {#py_cui.widgets.ScrollMenu}"},{"location":"functions/#ancestors-in-mro_14","text":"py_cui.widgets.Widget","title":"Ancestors (in MRO)"},{"location":"functions/#descendants_1","text":"py_cui.widgets.CheckBoxMenu","title":"Descendants"},{"location":"functions/#methods_20","text":"","title":"Methods"},{"location":"functions/#method-add_item-py_cuiwidgetsscrollmenuadd_item","text":"def add_item(self, item_text) Adds an item to the menu.","title":"Method add_item {#py_cui.widgets.ScrollMenu.add_item}"},{"location":"functions/#parameters_6","text":"item_text :\u2002 str : The text for the item","title":"Parameters"},{"location":"functions/#method-add_item_list-py_cuiwidgetsscrollmenuadd_item_list","text":"def add_item_list(self, item_list) Adds a list of items to the scroll menu.","title":"Method add_item_list {#py_cui.widgets.ScrollMenu.add_item_list}"},{"location":"functions/#parameters_7","text":"item_list :\u2002 list of str : list of strings to add as items to the scrollmenu","title":"Parameters"},{"location":"functions/#method-clear-py_cuiwidgetsscrollmenuclear","text":"def clear(self) Clears all items from the Scroll Menu","title":"Method clear {#py_cui.widgets.ScrollMenu.clear}"},{"location":"functions/#method-draw-py_cuiwidgetsscrollmenudraw","text":"def draw(self) Overrides base class draw function","title":"Method draw {#py_cui.widgets.ScrollMenu.draw}"},{"location":"functions/#method-get-py_cuiwidgetsscrollmenuget","text":"def get(self) Function that gets the selected item from the scroll menu","title":"Method get {#py_cui.widgets.ScrollMenu.get}"},{"location":"functions/#returns_2","text":"item :\u2002 str : selected item, or None if there are no items in the menu","title":"Returns"},{"location":"functions/#method-get_item_list-py_cuiwidgetsscrollmenuget_item_list","text":"def get_item_list(self) Function that gets list of items in a scroll menu","title":"Method get_item_list {#py_cui.widgets.ScrollMenu.get_item_list}"},{"location":"functions/#returns_3","text":"item_list :\u2002 list of str : list of items in the scrollmenu","title":"Returns"},{"location":"functions/#method-handle_key_press-py_cuiwidgetsscrollmenuhandle_key_press","text":"def handle_key_press(self, key_pressed) Override base class function. UP_ARROW scrolls up, DOWN_ARROW scrolls down","title":"Method handle_key_press {#py_cui.widgets.ScrollMenu.handle_key_press}"},{"location":"functions/#method-remove_selected_item-py_cuiwidgetsscrollmenuremove_selected_item","text":"def remove_selected_item(self) Function that removes the selected item from the scroll menu.","title":"Method remove_selected_item {#py_cui.widgets.ScrollMenu.remove_selected_item}"},{"location":"functions/#method-scroll_down-py_cuiwidgetsscrollmenuscroll_down","text":"def scroll_down(self) Function that scrolls the view down in the scroll menu","title":"Method scroll_down {#py_cui.widgets.ScrollMenu.scroll_down}"},{"location":"functions/#method-scroll_up-py_cuiwidgetsscrollmenuscroll_up","text":"def scroll_up(self) Function that scrolls the view up in the scroll menu","title":"Method scroll_up {#py_cui.widgets.ScrollMenu.scroll_up}"},{"location":"functions/#class-scrolltextblock-py_cuiwidgetsscrolltextblock","text":"class ScrollTextBlock(id, title, grid, row, column, row_span, column_span, padx, pady, initial_text) Widget for editing large multi-line blocks of text","title":"Class ScrollTextBlock {#py_cui.widgets.ScrollTextBlock}"},{"location":"functions/#ancestors-in-mro_15","text":"py_cui.widgets.Widget","title":"Ancestors (in MRO)"},{"location":"functions/#methods_21","text":"","title":"Methods"},{"location":"functions/#method-clear-py_cuiwidgetsscrolltextblockclear","text":"def clear(self) Function that clears the text block","title":"Method clear {#py_cui.widgets.ScrollTextBlock.clear}"},{"location":"functions/#method-draw-py_cuiwidgetsscrolltextblockdraw","text":"def draw(self) Override of base class draw function","title":"Method draw {#py_cui.widgets.ScrollTextBlock.draw}"},{"location":"functions/#method-get-py_cuiwidgetsscrolltextblockget","text":"def get(self) Gets all of the text in the textblock and returns it","title":"Method get {#py_cui.widgets.ScrollTextBlock.get}"},{"location":"functions/#method-get_current_line-py_cuiwidgetsscrolltextblockget_current_line","text":"def get_current_line(self) Returns the line on which the cursor currently resides","title":"Method get_current_line {#py_cui.widgets.ScrollTextBlock.get_current_line}"},{"location":"functions/#method-handle_backspace-py_cuiwidgetsscrolltextblockhandle_backspace","text":"def handle_backspace(self) Function that handles recieving backspace characters in the text","title":"Method handle_backspace {#py_cui.widgets.ScrollTextBlock.handle_backspace}"},{"location":"functions/#method-handle_delete-py_cuiwidgetsscrolltextblockhandle_delete","text":"def handle_delete(self) Function that handles recieving a delete keypress","title":"Method handle_delete {#py_cui.widgets.ScrollTextBlock.handle_delete}"},{"location":"functions/#method-handle_end-py_cuiwidgetsscrolltextblockhandle_end","text":"def handle_end(self) Function that handles recieving an end keypress","title":"Method handle_end {#py_cui.widgets.ScrollTextBlock.handle_end}"},{"location":"functions/#method-handle_home-py_cuiwidgetsscrolltextblockhandle_home","text":"def handle_home(self) Function that handles recieving a home keypress","title":"Method handle_home {#py_cui.widgets.ScrollTextBlock.handle_home}"},{"location":"functions/#method-handle_key_press-py_cuiwidgetsscrolltextblockhandle_key_press","text":"def handle_key_press(self, key_pressed) Override of base class handle key press function","title":"Method handle_key_press {#py_cui.widgets.ScrollTextBlock.handle_key_press}"},{"location":"functions/#method-handle_newline-py_cuiwidgetsscrolltextblockhandle_newline","text":"def handle_newline(self) Function that handles recieving newline characters in the text","title":"Method handle_newline {#py_cui.widgets.ScrollTextBlock.handle_newline}"},{"location":"functions/#method-insert_char-py_cuiwidgetsscrolltextblockinsert_char","text":"def insert_char(self, key_pressed) Function that handles recieving a character","title":"Method insert_char {#py_cui.widgets.ScrollTextBlock.insert_char}"},{"location":"functions/#method-move_down-py_cuiwidgetsscrolltextblockmove_down","text":"def move_down(self) Function that moves the cursor/text position one location down","title":"Method move_down {#py_cui.widgets.ScrollTextBlock.move_down}"},{"location":"functions/#method-move_left-py_cuiwidgetsscrolltextblockmove_left","text":"def move_left(self) Function that moves the cursor/text position one location to the left","title":"Method move_left {#py_cui.widgets.ScrollTextBlock.move_left}"},{"location":"functions/#method-move_right-py_cuiwidgetsscrolltextblockmove_right","text":"def move_right(self) Function that moves the cursor/text position one location to the right","title":"Method move_right {#py_cui.widgets.ScrollTextBlock.move_right}"},{"location":"functions/#method-move_up-py_cuiwidgetsscrolltextblockmove_up","text":"def move_up(self) Function that moves the cursor/text position one location up","title":"Method move_up {#py_cui.widgets.ScrollTextBlock.move_up}"},{"location":"functions/#method-set_text-py_cuiwidgetsscrolltextblockset_text","text":"def set_text(self, text) Function that sets the text for the textblock. Note that this will overwrite any existing text","title":"Method set_text {#py_cui.widgets.ScrollTextBlock.set_text}"},{"location":"functions/#parameters_8","text":"text :\u2002 str : text to write into text block","title":"Parameters"},{"location":"functions/#method-set_text_line-py_cuiwidgetsscrolltextblockset_text_line","text":"def set_text_line(self, text) Function that sets the current line's text. Meant only for internal use","title":"Method set_text_line {#py_cui.widgets.ScrollTextBlock.set_text_line}"},{"location":"functions/#method-write-py_cuiwidgetsscrolltextblockwrite","text":"def write(self, text) Function used for writing text to the text block","title":"Method write {#py_cui.widgets.ScrollTextBlock.write}"},{"location":"functions/#class-textbox-py_cuiwidgetstextbox","text":"class TextBox(id, title, grid, row, column, row_span, column_span, padx, pady, initial_text) Widget for entering small single lines of text","title":"Class TextBox {#py_cui.widgets.TextBox}"},{"location":"functions/#ancestors-in-mro_16","text":"py_cui.widgets.Widget","title":"Ancestors (in MRO)"},{"location":"functions/#methods_22","text":"","title":"Methods"},{"location":"functions/#method-clear-py_cuiwidgetstextboxclear","text":"def clear(self) Clears the text in the textbox","title":"Method clear {#py_cui.widgets.TextBox.clear}"},{"location":"functions/#method-draw-py_cuiwidgetstextboxdraw","text":"def draw(self) Override of base draw function","title":"Method draw {#py_cui.widgets.TextBox.draw}"},{"location":"functions/#method-erase_char-py_cuiwidgetstextboxerase_char","text":"def erase_char(self) Erases character at textbox cursor","title":"Method erase_char {#py_cui.widgets.TextBox.erase_char}"},{"location":"functions/#method-get-py_cuiwidgetstextboxget","text":"def get(self) Gets value of the text in the textbox","title":"Method get {#py_cui.widgets.TextBox.get}"},{"location":"functions/#method-handle_key_press-py_cuiwidgetstextboxhandle_key_press","text":"def handle_key_press(self, key_pressed) Override of base handle key press function","title":"Method handle_key_press {#py_cui.widgets.TextBox.handle_key_press}"},{"location":"functions/#method-insert_char-py_cuiwidgetstextboxinsert_char","text":"def insert_char(self, key_pressed) Inserts char at cursor position. Internal use only","title":"Method insert_char {#py_cui.widgets.TextBox.insert_char}"},{"location":"functions/#method-jump_to_end-py_cuiwidgetstextboxjump_to_end","text":"def jump_to_end(self) Jumps to the end to the textbox","title":"Method jump_to_end {#py_cui.widgets.TextBox.jump_to_end}"},{"location":"functions/#method-jump_to_start-py_cuiwidgetstextboxjump_to_start","text":"def jump_to_start(self) Jumps to the start of the textbox","title":"Method jump_to_start {#py_cui.widgets.TextBox.jump_to_start}"},{"location":"functions/#method-move_left-py_cuiwidgetstextboxmove_left","text":"def move_left(self) Shifts the cursor the the left. Internal use only","title":"Method move_left {#py_cui.widgets.TextBox.move_left}"},{"location":"functions/#method-move_right-py_cuiwidgetstextboxmove_right","text":"def move_right(self) Shifts the cursor the the right. Internal use only","title":"Method move_right {#py_cui.widgets.TextBox.move_right}"},{"location":"functions/#method-set_text-py_cuiwidgetstextboxset_text","text":"def set_text(self, text) Sets the value of the text. Overwrites existing text","title":"Method set_text {#py_cui.widgets.TextBox.set_text}"},{"location":"functions/#method-update_height_width-py_cuiwidgetstextboxupdate_height_width","text":"def update_height_width(self) Need to update all cursor positions on resize","title":"Method update_height_width {#py_cui.widgets.TextBox.update_height_width}"},{"location":"functions/#class-widget-py_cuiwidgetswidget","text":"class Widget(id, title, grid, row, column, row_span, column_span, padx, pady, selectable=True) Top Level Widget Base Class","title":"Class Widget {#py_cui.widgets.Widget}"},{"location":"functions/#descendants_2","text":"py_cui.widgets.Label py_cui.widgets.BlockLabel py_cui.widgets.ScrollMenu py_cui.widgets.Button py_cui.widgets.TextBox py_cui.widgets.ScrollTextBlock","title":"Descendants"},{"location":"functions/#methods_23","text":"","title":"Methods"},{"location":"functions/#method-add_key_command-py_cuiwidgetswidgetadd_key_command","text":"def add_key_command(self, key, command) Maps a keycode to a function that will be executed when in focus mode","title":"Method add_key_command {#py_cui.widgets.Widget.add_key_command}"},{"location":"functions/#parameters_9","text":"key :\u2002 py_cui.keys.KEY : ascii keycode used to map the key command :\u2002 function without args : a non-argument function or lambda function to execute if in focus mode and key is pressed","title":"Parameters"},{"location":"functions/#method-add_text_color_rule-py_cuiwidgetswidgetadd_text_color_rule","text":"def add_text_color_rule(self, regex, color, rule_type, match_type='line', region=[0, 1], include_whitespace=False) Forces renderer to draw text using given color if text_condition_function returns True","title":"Method add_text_color_rule {#py_cui.widgets.Widget.add_text_color_rule}"},{"location":"functions/#parameters_10","text":"rule_type :\u2002 string : A supported color rule type regex :\u2002 str : A string to check against the line for a given rule type color :\u2002 int : a supported py_cui color value match_entire_line :\u2002 bool : if true, if regex fits rule type, entire line will be colored. If false, only matching text","title":"Parameters"},{"location":"functions/#method-assign_renderer-py_cuiwidgetswidgetassign_renderer","text":"def assign_renderer(self, renderer) Function that assigns a renderer object to the widget (Meant for internal usage only)","title":"Method assign_renderer {#py_cui.widgets.Widget.assign_renderer}"},{"location":"functions/#method-draw-py_cuiwidgetswidgetdraw","text":"def draw(self) Base class draw class that checks if renderer is valid. Should be called with super().draw() in overrides","title":"Method draw {#py_cui.widgets.Widget.draw}"},{"location":"functions/#method-get_absolute_dims-py_cuiwidgetswidgetget_absolute_dims","text":"def get_absolute_dims(self) Gets the absolute dimensions of the widget in characters","title":"Method get_absolute_dims {#py_cui.widgets.Widget.get_absolute_dims}"},{"location":"functions/#method-get_absolute_position-py_cuiwidgetswidgetget_absolute_position","text":"def get_absolute_position(self) Gets the absolute position of the widget in characters","title":"Method get_absolute_position {#py_cui.widgets.Widget.get_absolute_position}"},{"location":"functions/#method-get_help_text-py_cuiwidgetswidgetget_help_text","text":"def get_help_text(self) Returns help text","title":"Method get_help_text {#py_cui.widgets.Widget.get_help_text}"},{"location":"functions/#method-handle_key_press-py_cuiwidgetswidgethandle_key_press","text":"def handle_key_press(self, key_pressed) Base class function that handles all assigned key presses. When overwriting this function, make sure to add a super().handle_key_press(key_pressed) call, as this is required for user defined key command support","title":"Method handle_key_press {#py_cui.widgets.Widget.handle_key_press}"},{"location":"functions/#method-is_row_col_inside-py_cuiwidgetswidgetis_row_col_inside","text":"def is_row_col_inside(self, row, col) Checks if a particular row + column is inside the widget area","title":"Method is_row_col_inside {#py_cui.widgets.Widget.is_row_col_inside}"},{"location":"functions/#method-set_focus_text-py_cuiwidgetswidgetset_focus_text","text":"def set_focus_text(self, text) Function that sets the text of the status bar on focus for a particular widget","title":"Method set_focus_text {#py_cui.widgets.Widget.set_focus_text}"},{"location":"functions/#method-set_selected_color-py_cuiwidgetswidgetset_selected_color","text":"def set_selected_color(self, color) Sets the selected color for the widget","title":"Method set_selected_color {#py_cui.widgets.Widget.set_selected_color}"},{"location":"functions/#method-set_standard_color-py_cuiwidgetswidgetset_standard_color","text":"def set_standard_color(self, color) Sets the standard color for the widget","title":"Method set_standard_color {#py_cui.widgets.Widget.set_standard_color}"},{"location":"functions/#method-update_height_width-py_cuiwidgetswidgetupdate_height_width","text":"def update_height_width(self) Function that refreshes position and dimensons on resize. If necessary, make sure required widget attributes updated here as well.","title":"Method update_height_width {#py_cui.widgets.Widget.update_height_width}"},{"location":"install/","text":"Installation The easiest way to install py_cui is to use pip . You may simply run: pip install py_cui and the library should install along with all dependancies. If you are working on a machine where pip defaults to the Python 2 version, replace pip with pip3 . There is no Python 2 support for py_cui , you will need a version of Python 3.4+ in order to use it. It may function with lower versions of Python 3, but it has not been tested on them. Alternatively, if you wish to avoid using pip, you may install from this repository: git clone https://github.com/jwlodek/py_cui cd py_cui pip install . This will use pip to install from the sources in the git repository. If you wish to avoid installing altogether, you may copy an example from the examples/ directory into the root py_cui directory, and run it with python3. Note that in this case you are required to install the dependancies yourself, which are curses on UNIX (should be included with python3) and windows-curses on windows, which can be installed with pip . Running Unit Tests Unit tests for py_cui are written for pytest. Simply clone the repository, and run pytest in the root directory: git clone https://github.com/jwlodek/py_cui cd py_cui pytest These tests are also run on Travis-CI each time a new commit is pushed to the upstream repository. Running Examples To run examples, install py_cui, enter the examples/ directory, and run them with python3. For example, to run todo_list_example.py : cd examples python3 todo_list_example.py Feel free to take a look at the Examples section of this documentation for more details.","title":"Installation"},{"location":"install/#installation","text":"The easiest way to install py_cui is to use pip . You may simply run: pip install py_cui and the library should install along with all dependancies. If you are working on a machine where pip defaults to the Python 2 version, replace pip with pip3 . There is no Python 2 support for py_cui , you will need a version of Python 3.4+ in order to use it. It may function with lower versions of Python 3, but it has not been tested on them. Alternatively, if you wish to avoid using pip, you may install from this repository: git clone https://github.com/jwlodek/py_cui cd py_cui pip install . This will use pip to install from the sources in the git repository. If you wish to avoid installing altogether, you may copy an example from the examples/ directory into the root py_cui directory, and run it with python3. Note that in this case you are required to install the dependancies yourself, which are curses on UNIX (should be included with python3) and windows-curses on windows, which can be installed with pip .","title":"Installation"},{"location":"install/#running-unit-tests","text":"Unit tests for py_cui are written for pytest. Simply clone the repository, and run pytest in the root directory: git clone https://github.com/jwlodek/py_cui cd py_cui pytest These tests are also run on Travis-CI each time a new commit is pushed to the upstream repository.","title":"Running Unit Tests"},{"location":"install/#running-examples","text":"To run examples, install py_cui, enter the examples/ directory, and run them with python3. For example, to run todo_list_example.py : cd examples python3 todo_list_example.py Feel free to take a look at the Examples section of this documentation for more details.","title":"Running Examples"},{"location":"keybindings/","text":"Keybindings Almost all CUI elements in py_cui support some degree of keybindings. The order in which these keybindings are executed depend on the order they are added, however, user keybindings are always executed prior to default keybindings, so make sure you don't unintentionally override an already bound key. Lists of default keybindings for each widget are available in the Widgets section of this documentation, and a list of default keybindings for overview mode is found in the Usage section. Adding a Keybinding For all keybindings, you must pass a py_cui key and a function with no arguments. This function will be fired when the key bound to it is detected. The function may also be a class funciton, with self.FUNCTION being passed into the add keybinding function. Make sure to take a look at the examples for more uses of keybindings. Overview Mode To add a keybinding to overview mode, you need to add it to the PyCUI object itself. For example, if I wanted to add a binding for the c key to clear all text fields in my cui : # import the library import py_cui # Create the PyCUI and add a text field root = py_cui.PyCUI(3, 3) text_field = root.add_text_box('Text Field', 1, 1) # This function simply clears the text in the text field def clear_text_field(): text_field.clear() # Add the key binding to the PyCUI object itself for overview mode. root.add_key_command(py_cui.keys.KEY_C_LOWER, clear_text_field) # Start the CUI root.start() Focus Mode Adding keybindings to focus mode is done at a widget by widget basis. When a widget is added to the PyCUI , the returned object is used to add a key command. Once again, make sure to check default key bindings that should only be overridden if the user specifically desires to replace their functionality. For example, in a menu widget, if we wish to set the window title to the selected menu item with the t key, we could write the following: # import the library import py_cui # Create the CUI object root = py_cui.PyCUI(3,3) # Add the scroll menu with the three menu items menu_items = ['Item1', 'Item2', 'Item3'] menu = root.add_scroll_menu('Test Menu', 1, 1) menu.add_item_list(menu_items) # Function that sets the root window title def set_title_from_menu(): root.set_title(menu.get()) # Bind the 't' key to the above function menu.add_key_command(py_cui.keys.KEY_T_LOWER, set_title_from_menu) # start the CUI root.start() Supported Keys Below is a table of all keys supported by py_cui . Each key is accessed within your program with py_cui.keys.YOUR_KEY_CODE . There are some differences in the way keycodes are handled on win32 vs. UNIX, though this is abstracted away by py_cui. Key Code Key Presses KEY_ENTER Enter (newline) Key KEY_ESCAPE Escape Key KEY_SPACE Space Key KEY_DELETE Delete Key KEY_TAB Tab Key KEY_UP_ARROW Up Arrow Key KEY_DOWN_ARROW Down Arrow Key KEY_LEFT_ARROW Left Arrow Key KEY_RIGHT_ARROW Right Arrow Key KEY_PAGE_UP Page Up Key KEY_PAGE_DOWN Page Down Key KEY_F1 F1 Function Key KEY_F2 F2 Function Key KEY_F3 F3 Function Key KEY_F4 F4 Function Key KEY_F5 F5 Function Key KEY_F6 F6 Function Key KEY_F7 F7 Function Key KEY_F8 F8 Function Key KEY_HOME Home Key KEY_END End Key KEY_A_LOWER a Key KEY_B_LOWER b Key KEY_C_LOWER c Key KEY_D_LOWER d Key KEY_E_LOWER e Key KEY_F_LOWER f Key KEY_G_LOWER g Key KEY_H_LOWER h Key KEY_I_LOWER i Key KEY_J_LOWER j Key KEY_K_LOWER k Key KEY_L_LOWER l Key KEY_M_LOWER m Key KEY_N_LOWER n Key KEY_O_LOWER o Key KEY_P_LOWER p Key KEY_Q_LOWER q Key KEY_R_LOWER r Key KEY_S_LOWER s Key KEY_T_LOWER t Key KEY_U_LOWER u Key KEY_V_LOWER v Key KEY_W_LOWER w Key KEY_X_LOWER x Key KEY_Y_LOWER y Key KEY_Z_LOWER z Key KEY_A_UPPER a Key + Shift Key KEY_B_UPPER b Key + Shift Key KEY_C_UPPER c Key + Shift Key KEY_D_UPPER d Key + Shift Key KEY_E_UPPER e Key + Shift Key KEY_F_UPPER f Key + Shift Key KEY_G_UPPER g Key + Shift Key KEY_H_UPPER h Key + Shift Key KEY_I_UPPER i Key + Shift Key KEY_J_UPPER j Key + Shift Key KEY_K_UPPER k Key + Shift Key KEY_L_UPPER l Key + Shift Key KEY_M_UPPER m Key + Shift Key KEY_N_UPPER n Key + Shift Key KEY_O_UPPER o Key + Shift Key KEY_P_UPPER p Key + Shift Key KEY_Q_UPPER q Key + Shift Key KEY_R_UPPER r Key + Shift Key KEY_S_UPPER s Key + Shift Key KEY_T_UPPER t Key + Shift Key KEY_U_UPPER u Key + Shift Key KEY_V_UPPER v Key + Shift Key KEY_W_UPPER w Key + Shift Key KEY_X_UPPER x Key + Shift Key KEY_Y_UPPER y Key + Shift Key KEY_Z_UPPER z Key + Shift Key KEY_BACKSPACE Backspace Key","title":"Keys"},{"location":"keybindings/#keybindings","text":"Almost all CUI elements in py_cui support some degree of keybindings. The order in which these keybindings are executed depend on the order they are added, however, user keybindings are always executed prior to default keybindings, so make sure you don't unintentionally override an already bound key. Lists of default keybindings for each widget are available in the Widgets section of this documentation, and a list of default keybindings for overview mode is found in the Usage section.","title":"Keybindings"},{"location":"keybindings/#adding-a-keybinding","text":"For all keybindings, you must pass a py_cui key and a function with no arguments. This function will be fired when the key bound to it is detected. The function may also be a class funciton, with self.FUNCTION being passed into the add keybinding function. Make sure to take a look at the examples for more uses of keybindings. Overview Mode To add a keybinding to overview mode, you need to add it to the PyCUI object itself. For example, if I wanted to add a binding for the c key to clear all text fields in my cui : # import the library import py_cui # Create the PyCUI and add a text field root = py_cui.PyCUI(3, 3) text_field = root.add_text_box('Text Field', 1, 1) # This function simply clears the text in the text field def clear_text_field(): text_field.clear() # Add the key binding to the PyCUI object itself for overview mode. root.add_key_command(py_cui.keys.KEY_C_LOWER, clear_text_field) # Start the CUI root.start() Focus Mode Adding keybindings to focus mode is done at a widget by widget basis. When a widget is added to the PyCUI , the returned object is used to add a key command. Once again, make sure to check default key bindings that should only be overridden if the user specifically desires to replace their functionality. For example, in a menu widget, if we wish to set the window title to the selected menu item with the t key, we could write the following: # import the library import py_cui # Create the CUI object root = py_cui.PyCUI(3,3) # Add the scroll menu with the three menu items menu_items = ['Item1', 'Item2', 'Item3'] menu = root.add_scroll_menu('Test Menu', 1, 1) menu.add_item_list(menu_items) # Function that sets the root window title def set_title_from_menu(): root.set_title(menu.get()) # Bind the 't' key to the above function menu.add_key_command(py_cui.keys.KEY_T_LOWER, set_title_from_menu) # start the CUI root.start()","title":"Adding a Keybinding"},{"location":"keybindings/#supported-keys","text":"Below is a table of all keys supported by py_cui . Each key is accessed within your program with py_cui.keys.YOUR_KEY_CODE . There are some differences in the way keycodes are handled on win32 vs. UNIX, though this is abstracted away by py_cui. Key Code Key Presses KEY_ENTER Enter (newline) Key KEY_ESCAPE Escape Key KEY_SPACE Space Key KEY_DELETE Delete Key KEY_TAB Tab Key KEY_UP_ARROW Up Arrow Key KEY_DOWN_ARROW Down Arrow Key KEY_LEFT_ARROW Left Arrow Key KEY_RIGHT_ARROW Right Arrow Key KEY_PAGE_UP Page Up Key KEY_PAGE_DOWN Page Down Key KEY_F1 F1 Function Key KEY_F2 F2 Function Key KEY_F3 F3 Function Key KEY_F4 F4 Function Key KEY_F5 F5 Function Key KEY_F6 F6 Function Key KEY_F7 F7 Function Key KEY_F8 F8 Function Key KEY_HOME Home Key KEY_END End Key KEY_A_LOWER a Key KEY_B_LOWER b Key KEY_C_LOWER c Key KEY_D_LOWER d Key KEY_E_LOWER e Key KEY_F_LOWER f Key KEY_G_LOWER g Key KEY_H_LOWER h Key KEY_I_LOWER i Key KEY_J_LOWER j Key KEY_K_LOWER k Key KEY_L_LOWER l Key KEY_M_LOWER m Key KEY_N_LOWER n Key KEY_O_LOWER o Key KEY_P_LOWER p Key KEY_Q_LOWER q Key KEY_R_LOWER r Key KEY_S_LOWER s Key KEY_T_LOWER t Key KEY_U_LOWER u Key KEY_V_LOWER v Key KEY_W_LOWER w Key KEY_X_LOWER x Key KEY_Y_LOWER y Key KEY_Z_LOWER z Key KEY_A_UPPER a Key + Shift Key KEY_B_UPPER b Key + Shift Key KEY_C_UPPER c Key + Shift Key KEY_D_UPPER d Key + Shift Key KEY_E_UPPER e Key + Shift Key KEY_F_UPPER f Key + Shift Key KEY_G_UPPER g Key + Shift Key KEY_H_UPPER h Key + Shift Key KEY_I_UPPER i Key + Shift Key KEY_J_UPPER j Key + Shift Key KEY_K_UPPER k Key + Shift Key KEY_L_UPPER l Key + Shift Key KEY_M_UPPER m Key + Shift Key KEY_N_UPPER n Key + Shift Key KEY_O_UPPER o Key + Shift Key KEY_P_UPPER p Key + Shift Key KEY_Q_UPPER q Key + Shift Key KEY_R_UPPER r Key + Shift Key KEY_S_UPPER s Key + Shift Key KEY_T_UPPER t Key + Shift Key KEY_U_UPPER u Key + Shift Key KEY_V_UPPER v Key + Shift Key KEY_W_UPPER w Key + Shift Key KEY_X_UPPER x Key + Shift Key KEY_Y_UPPER y Key + Shift Key KEY_Z_UPPER z Key + Shift Key KEY_BACKSPACE Backspace Key","title":"Supported Keys"},{"location":"popups/","text":"Popups This page contains information regarding all popups supported by py_cui . Please see the popups_example.py in the examples/ directory in the repository. Message/Warning/Error Popup Spawn Command show_message_popup(title, text) show_warning_popup(title, text) show_error_popup(title, text) Usage Used to show a simple message, with a different color depending on warning level. Keys Exit from the popup with KEY_ENTER , KEY_ESCAPE , or KEY_SPACE . Yes/No Popup Spawn Command show_yes_no_popup(self, title, command) Usage Ask user yes/no question. The command parameter passed to the spawn function must be a function that takes a single boolean parameter. Keys If KEY_Y_LOWER is pressed, the command will be run with True passed in, otherwise False is passed in. Loading Icon/Bar Popup Spawn Command show_loading_icon_popup(title, message) show_loading_bar_popup(title, num_items) Usage The loading popups must be used in conjunction with some sort of async/threading. First, spawn the popup and then start a thread performing the long operation. At the end of the long operation, call: stop_loading_popup() Which will escape the loading popup. When using the loading bar popup, increment yout item counter with: increment_loading_bar() Keys None TextBox Popup Spawn Command show_text_box_popup(title, command) Usage Spawn a text box, and on KEY_ENTER pressed, the command function is triggered with the text from the popup as the parameter. Keys The letter keys will write the text, and KEY_ENTER submits. Menu Popup Spawn Command show_menu_popup(title, menu_items, command, run_command_if_none=False) Usage Use as an overall menu system for your application. Gives user option to select from list. Fires the command with the selected menu item as a parameter on KEY_ENTER Keys Arrow keys scroll up and down, enter key submits.","title":"Popups"},{"location":"popups/#popups","text":"This page contains information regarding all popups supported by py_cui . Please see the popups_example.py in the examples/ directory in the repository.","title":"Popups"},{"location":"popups/#messagewarningerror-popup","text":"Spawn Command show_message_popup(title, text) show_warning_popup(title, text) show_error_popup(title, text) Usage Used to show a simple message, with a different color depending on warning level. Keys Exit from the popup with KEY_ENTER , KEY_ESCAPE , or KEY_SPACE .","title":"Message/Warning/Error Popup"},{"location":"popups/#yesno-popup","text":"Spawn Command show_yes_no_popup(self, title, command) Usage Ask user yes/no question. The command parameter passed to the spawn function must be a function that takes a single boolean parameter. Keys If KEY_Y_LOWER is pressed, the command will be run with True passed in, otherwise False is passed in.","title":"Yes/No Popup"},{"location":"popups/#loading-iconbar-popup","text":"Spawn Command show_loading_icon_popup(title, message) show_loading_bar_popup(title, num_items) Usage The loading popups must be used in conjunction with some sort of async/threading. First, spawn the popup and then start a thread performing the long operation. At the end of the long operation, call: stop_loading_popup() Which will escape the loading popup. When using the loading bar popup, increment yout item counter with: increment_loading_bar() Keys None","title":"Loading Icon/Bar Popup"},{"location":"popups/#textbox-popup","text":"Spawn Command show_text_box_popup(title, command) Usage Spawn a text box, and on KEY_ENTER pressed, the command function is triggered with the text from the popup as the parameter. Keys The letter keys will write the text, and KEY_ENTER submits.","title":"TextBox Popup"},{"location":"popups/#menu-popup","text":"Spawn Command show_menu_popup(title, menu_items, command, run_command_if_none=False) Usage Use as an overall menu system for your application. Gives user option to select from list. Fires the command with the selected menu item as a parameter on KEY_ENTER Keys Arrow keys scroll up and down, enter key submits.","title":"Menu Popup"},{"location":"usage/","text":"Usage In this section we discuss some universal usage rules common to all py_cui based interfaces.","title":"Usage"},{"location":"usage/#usage","text":"In this section we discuss some universal usage rules common to all py_cui based interfaces.","title":"Usage"},{"location":"widgets/","text":"Widgets Below are details on each widget supported by py_cui including how to add them to a CUI, and their supported functions. Base Widget Class This base class contains all shared functionality. Label Widget Specific Class Variables None Widget Specific Functions None Usage Labels only display text. You cannot enter focus mode on labels, and thus keybindings will have no effect. Add labels for single lines to text to the center of a grid cell. Adding to CUI add_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title in the center of the grid location it is placed in. Default Keybindings None Block Label Widget Specific Class Variables self.lines - represents the title passed in split on newline characters Widget Specific Functions None Usage Block Labels only display text. You cannot enter focus mode on block labels, and thus keybindings will have no effect. Add block labels for multi line text that will be drawn in the center of the grid cell. One example for this is to display ASCII-Art. Adding to CUI add_block_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title.splitlines() in the center of the grid location it is placed in. Default Keybindings None Button Widget Specific Class Variables self.command - represents the command executed when Enter key pressed on button Widget Specific Functions None Usage Buttons execute a no-args function when enter pressed. By default, pressing enter when hovering over a button executes the command instead of entering focus mode. To disable this behavior, add the auto_focus_buttons=False to the creation of the PyCUI object. Adding to CUI add_button(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Draw Behavior Draws self.title centered in the grid cell, with a border. By default, buttons have a magenta color. Default Keybindings KEY_ENTER - runs the command passed into the button Scroll Menu Widget Specific Class Variables self.top_view - Uppermost menu item in viewport self.selected_item - currently selected item index self.view_items - list of menu items Widget Specific Functions clear() - removes all selected items scroll_up() - Internal use only, scrolls up in menu scroll_down() - Internal use only, scrolls down in menu add_item(item) - Takes in a string, adds it as an item to the menu add_item_list(item_list) - Takes a list of strings, adds them all to the menu remove_selected_item() - Removes the currently selected item from the menu get() - Returns the currently selected item get_item_list() - gets current list of menu items Usage Scroll Menus are very useful for having multiple option menus or for showing a list of information. The most common usage is to add a keybinding for the ENTER which processes some function depending on the selected item. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list Checkbox Menu The checkbox menu extends from the scrollmenu, and so shares many functions with it. Widget Specific Class Variables self.selected_item_list - list of selected items self.checked_char - character to mark item as checked Widget Specific Functions mark_item_as_checked(text) - marks item matching text as checked get() - overrides the ScrollMenu function. Returns the selected item list All functions included from ScrollMenu are also available. Usage Checkbox Menus are very useful for selecting several options. They should be used for having the user to select multiple items. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_checkbox_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list Text Box Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left() - Shifts the cursor the the left. Internal use only move_right() - Shifts the cursor the the right. Internal use only insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only Usage Used for user entering text into CUI. For prompts, it is suggested to use the Textbox popup instead. Adding to CUI add_text_box(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry field centered in the grid cell assigned Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text Text Block Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left(current_line) - Shifts the cursor to the left. Internal use only move_right(current_line) - Shifts the cursor to the right. Internal use only move_down(current_line) - Shifts the cursor down. Internal use only move_up(current_line) - Shifts the cursor up. Internal use only write(text) - writes text to the textblock insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only handle_delete(current_line) - Handles deleting characters. Internal use only handle_end(current_line) - handles end key. Internal use only handle_home(current_line) - handles home key. Internal use only handle_backspace(current_line) - handles backspace key. Internal use only handle_newline(current_line) - handles newline key. Internal use only Usage TextBoxes have two key uses: * For editing larger blocks of text, such as if you wish to create a CUI text editor (see snano example) * For displaying large amounts of text, such as statuses, logs etc. (see pyautogit example) Adding to CUI add_text_block(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry box that fills the grid cells. Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right KEY_DOWN_ARROW - Shifts cursor down KEY_UP_ARROW - Shifts cursor up Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text KEY_TAB - Enters 4 space characters (Sorry tab people) KEY_DELETE - Deletes next character KEY_ENTER - Inserts newline character","title":"Widgets"},{"location":"widgets/#widgets","text":"Below are details on each widget supported by py_cui including how to add them to a CUI, and their supported functions.","title":"Widgets"},{"location":"widgets/#base-widget-class","text":"This base class contains all shared functionality.","title":"Base Widget Class"},{"location":"widgets/#label","text":"Widget Specific Class Variables None Widget Specific Functions None Usage Labels only display text. You cannot enter focus mode on labels, and thus keybindings will have no effect. Add labels for single lines to text to the center of a grid cell. Adding to CUI add_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title in the center of the grid location it is placed in. Default Keybindings None","title":"Label"},{"location":"widgets/#block-label","text":"Widget Specific Class Variables self.lines - represents the title passed in split on newline characters Widget Specific Functions None Usage Block Labels only display text. You cannot enter focus mode on block labels, and thus keybindings will have no effect. Add block labels for multi line text that will be drawn in the center of the grid cell. One example for this is to display ASCII-Art. Adding to CUI add_block_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title.splitlines() in the center of the grid location it is placed in. Default Keybindings None","title":"Block Label"},{"location":"widgets/#button","text":"Widget Specific Class Variables self.command - represents the command executed when Enter key pressed on button Widget Specific Functions None Usage Buttons execute a no-args function when enter pressed. By default, pressing enter when hovering over a button executes the command instead of entering focus mode. To disable this behavior, add the auto_focus_buttons=False to the creation of the PyCUI object. Adding to CUI add_button(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Draw Behavior Draws self.title centered in the grid cell, with a border. By default, buttons have a magenta color. Default Keybindings KEY_ENTER - runs the command passed into the button","title":"Button"},{"location":"widgets/#scroll-menu","text":"Widget Specific Class Variables self.top_view - Uppermost menu item in viewport self.selected_item - currently selected item index self.view_items - list of menu items Widget Specific Functions clear() - removes all selected items scroll_up() - Internal use only, scrolls up in menu scroll_down() - Internal use only, scrolls down in menu add_item(item) - Takes in a string, adds it as an item to the menu add_item_list(item_list) - Takes a list of strings, adds them all to the menu remove_selected_item() - Removes the currently selected item from the menu get() - Returns the currently selected item get_item_list() - gets current list of menu items Usage Scroll Menus are very useful for having multiple option menus or for showing a list of information. The most common usage is to add a keybinding for the ENTER which processes some function depending on the selected item. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list","title":"Scroll Menu"},{"location":"widgets/#checkbox-menu","text":"The checkbox menu extends from the scrollmenu, and so shares many functions with it. Widget Specific Class Variables self.selected_item_list - list of selected items self.checked_char - character to mark item as checked Widget Specific Functions mark_item_as_checked(text) - marks item matching text as checked get() - overrides the ScrollMenu function. Returns the selected item list All functions included from ScrollMenu are also available. Usage Checkbox Menus are very useful for selecting several options. They should be used for having the user to select multiple items. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_checkbox_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list","title":"Checkbox Menu"},{"location":"widgets/#text-box","text":"Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left() - Shifts the cursor the the left. Internal use only move_right() - Shifts the cursor the the right. Internal use only insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only Usage Used for user entering text into CUI. For prompts, it is suggested to use the Textbox popup instead. Adding to CUI add_text_box(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry field centered in the grid cell assigned Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text","title":"Text Box"},{"location":"widgets/#text-block","text":"Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left(current_line) - Shifts the cursor to the left. Internal use only move_right(current_line) - Shifts the cursor to the right. Internal use only move_down(current_line) - Shifts the cursor down. Internal use only move_up(current_line) - Shifts the cursor up. Internal use only write(text) - writes text to the textblock insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only handle_delete(current_line) - Handles deleting characters. Internal use only handle_end(current_line) - handles end key. Internal use only handle_home(current_line) - handles home key. Internal use only handle_backspace(current_line) - handles backspace key. Internal use only handle_newline(current_line) - handles newline key. Internal use only Usage TextBoxes have two key uses: * For editing larger blocks of text, such as if you wish to create a CUI text editor (see snano example) * For displaying large amounts of text, such as statuses, logs etc. (see pyautogit example) Adding to CUI add_text_block(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry box that fills the grid cells. Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right KEY_DOWN_ARROW - Shifts cursor down KEY_UP_ARROW - Shifts cursor up Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text KEY_TAB - Enters 4 space characters (Sorry tab people) KEY_DELETE - Deletes next character KEY_ENTER - Inserts newline character","title":"Text Block"},{"location":"writing/","text":"Writing a py_cui, step by step On this page, we will create a simple py_cui program, step by step. We will create something similar to the todo list example that can be seen in the examples directory in the repository. Step 1 - Create PyCUI and wrapper class The recommended way to create py_cui programs is to create a wrapper class that takes the PyCUI object as an argument, similar to how Tk objects are often passed as an argument to a wrapper class. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Step 2 - Add your widgets Next, we want to add widgets to the CUI. We will add 3 scroll menus to represent our lists of TODO, In Progress, and Done, a text field for adding new items for now. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note how we set the row_span and column_span values, so that even though the grid is 7x6, our widgets will actually be larger than that size. The reason we define these sizes is becaue we wish to have the text field fill a narrow row, meaning that we must subdivide the window into many rows. Step 3 - Add key commands Next, add keybindings to your widgets. We want buttons that send items into the next list, and the items get removed if theyre in the \"Done\" list. Also, we need to make the text field send its contents into the \"TODO\" list. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note that in the mark_as_in_progress and mark_as_done functions spawn an error popup if the lists are empty. Step 4 - You're done! That's it! our simple example is complete, and you can test it with: python3 simple_todo.py You should see something similar to this: Feel free to play around with this CUI, and note how the keybindings we assigned perform the tasks we wanted them to.","title":"Writing a PyCUI step-by-step"},{"location":"writing/#writing-a-py_cui-step-by-step","text":"On this page, we will create a simple py_cui program, step by step. We will create something similar to the todo list example that can be seen in the examples directory in the repository. Step 1 - Create PyCUI and wrapper class The recommended way to create py_cui programs is to create a wrapper class that takes the PyCUI object as an argument, similar to how Tk objects are often passed as an argument to a wrapper class. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Step 2 - Add your widgets Next, we want to add widgets to the CUI. We will add 3 scroll menus to represent our lists of TODO, In Progress, and Done, a text field for adding new items for now. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note how we set the row_span and column_span values, so that even though the grid is 7x6, our widgets will actually be larger than that size. The reason we define these sizes is becaue we wish to have the text field fill a narrow row, meaning that we must subdivide the window into many rows. Step 3 - Add key commands Next, add keybindings to your widgets. We want buttons that send items into the next list, and the items get removed if theyre in the \"Done\" list. Also, we need to make the text field send its contents into the \"TODO\" list. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note that in the mark_as_in_progress and mark_as_done functions spawn an error popup if the lists are empty. Step 4 - You're done! That's it! our simple example is complete, and you can test it with: python3 simple_todo.py You should see something similar to this: Feel free to play around with this CUI, and note how the keybindings we assigned perform the tasks we wanted them to.","title":"Writing a py_cui, step by step"}]}