{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"py_cui A py thon library for creating c ommand line u ser i nterfaces. What is py_cui? py_cui is a python library meant to simplify writing command line user interfaces in python. It relies on the curses module, which is traditionally a unix-specific python module, however, I was able to use the windows-curses module to run py_cui on windows. The main advantage py_cui has over traditional command line user interfaces is that it relies on widgets and a grid layout manager like most traditional Graphical User Interfaces. You may define a grid size, and then drop predefined widgets onto it into specific grid locations. Widgets can also be stretched accross multiple grid rows and columns. If you've ever made a Tkinter GUI, you will feel right at home. Writing a PyCUI Basic usage of py_cui starts with creating a PyCUI object, and specifiying it's grid size. Keep in mind that grid cell height and width will be measured in terminal characters, not pixels, so there is a lower limit on legal grid size, and heights will be smaller values than widths. Create this object with: root = py_cui.PyCUI(7, 9) The above line will create a UI with 7 rows and 9 columns. Then, add widgets with the different add commands: label = root.add_label('Label Text', 0, 0) button = root.add_button('Button Text', 1, 2, column_span=2, command=my_function) ... Finally, start the CUI with root.start() py_cui has support for custom key bindings for both the overview mode and focused mode, popup windows and prompts, color rendering rules, and several useful widgets. For more details on writing py_cui based interfaces, be sure to check on the examples and the documentation here . Using a PyCUI There are some basic rules that apply to all py_cui based interfaces. There are three key operating modes - overview mode, focus mode, and popup mode. Overview Mode Overview mode is the main control view of the interface. In this mode you use the arrow keys to move between widgets, and you may select widgets with the Enter key. By default, you may also press buttons in this mode, unless auto_focus_buttons is set to false when the CUI was created. Focus Mode When in focus mode, you enter into a particular widget (For example a text box.). Each widget has some predefined basic controls, such as arrow keys to scroll in a ScrollMenu . You may also add keybindings to functions for each particular widget. These keybindings will only apply to a widget if it is in focus mode. Enter focus mode by navigating to a widget in overview mode and hitting the Enter key. Return to overview mode from focus mode by pressing Escape . Popup Mode Popup mode simply displays a popup over the rest of the UI. Each popup type behaves slightly differently. For example, you may exit an info popup mode by pressing Space , Enter , or Escape , while a loading popup will remain onscreen until whatever operation is being run is terminated.","title":"Home"},{"location":"#py_cui","text":"A py thon library for creating c ommand line u ser i nterfaces.","title":"py_cui"},{"location":"#what-is-py_cui","text":"py_cui is a python library meant to simplify writing command line user interfaces in python. It relies on the curses module, which is traditionally a unix-specific python module, however, I was able to use the windows-curses module to run py_cui on windows. The main advantage py_cui has over traditional command line user interfaces is that it relies on widgets and a grid layout manager like most traditional Graphical User Interfaces. You may define a grid size, and then drop predefined widgets onto it into specific grid locations. Widgets can also be stretched accross multiple grid rows and columns. If you've ever made a Tkinter GUI, you will feel right at home.","title":"What is py_cui?"},{"location":"#writing-a-pycui","text":"Basic usage of py_cui starts with creating a PyCUI object, and specifiying it's grid size. Keep in mind that grid cell height and width will be measured in terminal characters, not pixels, so there is a lower limit on legal grid size, and heights will be smaller values than widths. Create this object with: root = py_cui.PyCUI(7, 9) The above line will create a UI with 7 rows and 9 columns. Then, add widgets with the different add commands: label = root.add_label('Label Text', 0, 0) button = root.add_button('Button Text', 1, 2, column_span=2, command=my_function) ... Finally, start the CUI with root.start() py_cui has support for custom key bindings for both the overview mode and focused mode, popup windows and prompts, color rendering rules, and several useful widgets. For more details on writing py_cui based interfaces, be sure to check on the examples and the documentation here .","title":"Writing a PyCUI"},{"location":"#using-a-pycui","text":"There are some basic rules that apply to all py_cui based interfaces. There are three key operating modes - overview mode, focus mode, and popup mode. Overview Mode Overview mode is the main control view of the interface. In this mode you use the arrow keys to move between widgets, and you may select widgets with the Enter key. By default, you may also press buttons in this mode, unless auto_focus_buttons is set to false when the CUI was created. Focus Mode When in focus mode, you enter into a particular widget (For example a text box.). Each widget has some predefined basic controls, such as arrow keys to scroll in a ScrollMenu . You may also add keybindings to functions for each particular widget. These keybindings will only apply to a widget if it is in focus mode. Enter focus mode by navigating to a widget in overview mode and hitting the Enter key. Return to overview mode from focus mode by pressing Escape . Popup Mode Popup mode simply displays a popup over the rest of the UI. Each popup type behaves slightly differently. For example, you may exit an info popup mode by pressing Space , Enter , or Escape , while a loading popup will remain onscreen until whatever operation is being run is terminated.","title":"Using a PyCUI"},{"location":"about/","text":"About csplit Primary Author Jakub Wlodek Created on August 12, 2019 Contributing Authors Maciej Wlodek License BSD 3-Clause License Copyright (c) 2019, Jakub Wlodek All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"About"},{"location":"about/#about-csplit","text":"","title":"About csplit"},{"location":"about/#primary-author","text":"Jakub Wlodek Created on August 12, 2019","title":"Primary Author"},{"location":"about/#contributing-authors","text":"Maciej Wlodek","title":"Contributing Authors"},{"location":"about/#license","text":"BSD 3-Clause License Copyright (c) 2019, Jakub Wlodek All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"colors/","text":"Using colors in a py_cui Colors in py_cui based interfaces are handled wither by widget level color choices, or by text color rules. In the case of widget coloring, you may set the Widget.color attribute to one of the supported color pairs. Color rules on the other hand are assigned to widgets, and relate to the text drawn within the widget. Supported Colors All colors in the py_cui library are represented as pairs, a foreground and background color. Below is a list of supported color pairs: Color Pair Foreground (Text) Color Background Color WHITE_ON_BLACK WHITE BLACK BLACK_ON_GREEN BLACK GREEN BLACK_ON_WHITE BLACK WHITE WHITE_ON_RED WHITE RED YELLOW_ON_BLACK YELLOW BLACK RED_ON_BLACK RED BLACK CYAN_ON_BLACK CYAN BLACK MAGENTA_ON_BLACK MAGENTA BLACK GREEN_ON_BLACK GREEN BLACK BLUE_ON_BLACK BLUE BLACK Using Color Rules There are severl possible color rules that can be added to a py_cui widget, and these are classified under: * Rule Type - How we attempt to match a text line with a given regular expression * Match Type - How the resulting matched text is rendered Rule Types Rule Type Explanation startswith check if string starts with regex endswith check if string ends with regex notstartswith check if string doesn't start with regex notendswith check if string doesn't end with regex contains check if regex is contained within line Match Type Match Type Explanation line Color the entire line given color if matched region Color specified region if matched. For example a region of (0,3) would color the first 3 characters regex Color the matched regex only Examples self.text_block.add_text_color_rule('+', py_cui.GREEN_ON_BLACK, 'startswith') In the above example, all lines that start with a '+' symbol will be green. The default match type is line, meaning that the entire line will be colored in the event of a rule match. self.menu.add_text_color_rule('?', py_cui.GREEN_ON_BLACK, 'notstartswith', match_type='region', region=[0,3], include_whitespace=True) For this color rule, all lines that don't start with a ? will have their first three characters colored green. self.text_block.add_text_color_rule('@.*@', py_cui.CYAN_ON_BLACK, 'contains', match_type='regex') The above color rule will color all matches of @ ... @ cyan in the text of the textblock.","title":"Colors"},{"location":"colors/#using-colors-in-a-py_cui","text":"Colors in py_cui based interfaces are handled wither by widget level color choices, or by text color rules. In the case of widget coloring, you may set the Widget.color attribute to one of the supported color pairs. Color rules on the other hand are assigned to widgets, and relate to the text drawn within the widget.","title":"Using colors in a py_cui"},{"location":"colors/#supported-colors","text":"All colors in the py_cui library are represented as pairs, a foreground and background color. Below is a list of supported color pairs: Color Pair Foreground (Text) Color Background Color WHITE_ON_BLACK WHITE BLACK BLACK_ON_GREEN BLACK GREEN BLACK_ON_WHITE BLACK WHITE WHITE_ON_RED WHITE RED YELLOW_ON_BLACK YELLOW BLACK RED_ON_BLACK RED BLACK CYAN_ON_BLACK CYAN BLACK MAGENTA_ON_BLACK MAGENTA BLACK GREEN_ON_BLACK GREEN BLACK BLUE_ON_BLACK BLUE BLACK","title":"Supported Colors"},{"location":"colors/#using-color-rules","text":"There are severl possible color rules that can be added to a py_cui widget, and these are classified under: * Rule Type - How we attempt to match a text line with a given regular expression * Match Type - How the resulting matched text is rendered Rule Types Rule Type Explanation startswith check if string starts with regex endswith check if string ends with regex notstartswith check if string doesn't start with regex notendswith check if string doesn't end with regex contains check if regex is contained within line Match Type Match Type Explanation line Color the entire line given color if matched region Color specified region if matched. For example a region of (0,3) would color the first 3 characters regex Color the matched regex only Examples self.text_block.add_text_color_rule('+', py_cui.GREEN_ON_BLACK, 'startswith') In the above example, all lines that start with a '+' symbol will be green. The default match type is line, meaning that the entire line will be colored in the event of a rule match. self.menu.add_text_color_rule('?', py_cui.GREEN_ON_BLACK, 'notstartswith', match_type='region', region=[0,3], include_whitespace=True) For this color rule, all lines that don't start with a ? will have their first three characters colored green. self.text_block.add_text_color_rule('@.*@', py_cui.CYAN_ON_BLACK, 'contains', match_type='regex') The above color rule will color all matches of @ ... @ cyan in the text of the textblock.","title":"Using Color Rules"},{"location":"developers/","text":"Documentation for py_cui Developers This page contains information on writing new widgets and popups, as well as anything else required for developers and contributors for py_cui. Adding a new Widget We will walk through the steps of adding a new widget to py_cui (in this case a scroll menu) in order to demonstrate this process. Step One - Extend the Widget Class Your first step when writing a new widget is to create a class in py_cui/widgets.py that extends the base Widget class. For our ScrollMenu example: class ScrollMenu(Widget): def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) def draw(self): super().draw() The handle_key_press and draw functions must be extended for your new widget. You may leave the handle_key_press as above, if you don't require any keybindings for the widget. The draw function must extended, as the base class does no drawing itself, instead just setting up color rules. Step Two - Add additional class variables Next, add any variables that your widget may require on top of the base Widget class variables. In our case, it will be the selected item index, a list of menu items, and an integer representing the top item visible (in case the menu scrolls down). We also add some functions for getting and setting these variables. def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) self.top_view = 0 self.selected_item = 0 self.view_items = [] def clear(self): \"\"\" Clears all items from the Scroll Menu \"\"\" self.view_items = [] self.selected_item = 0 self.top_view = 0 def add_item_list(self, item_list): for item in item_list: self.add_item(item) def remove_selected_item(self): if len(self.view_items) == 0: return del self.view_items[self.selected_item] if self.selected_item >= len(self.view_items): self.selected_item = self.selected_item - 1 def get_item_list(self): return self.view_items def get(self): if len(self.view_items) > 0: return self.view_items[self.selected_item] return None Step 3 - Add Key Bindings Next, add any default key bindings you wish to have for the widget when in focus mode. In the case of the scroll menu, we wish for the arrow keys to scroll up and down, so we extend the handle_key_press function: def scroll_up(self): if self.selected: if self.top_view > 0: self.top_view = self.top_view - 1 if self.selected_item > 0: self.selected_item = self.selected_item - 1 def scroll_down(self): if self.selected: if self.selected_item < len(self.view_items) - 1: self.selected_item = self.selected_item + 1 if self.selected_item > self.top_view + self.height - (2 * self.pady) - 3: self.top_view = self.top_view + 1 def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) if key_pressed == py_cui.keys.KEY_UP_ARROW: self.scroll_up() if key_pressed == py_cui.keys.KEY_DOWN_ARROW: self.scroll_down() Note that the way default key bindings are added are simply if statements, which happen after the super() call. The scroll_up() and scroll_down() functions simply contain the logic for editing the viewport for the menu. Step 4 - implement the Draw function In the draw function, you must use the self.renderer object to render your widget to the screen. In our case, we want a border around the menu widget, and we also want to draw menu items that are within our viewport. The key renderer functions we will use are: self.renderer.draw_border(self) which will draw a border around the widget space, and self.renderer.draw_text(self, text, y_position) which will draw the text in the y_position. For our scroll menu, we would write the following: def draw(self): super().draw() # sets the color mode self.renderer.set_color_mode(self.color) # draws border around widget self.renderer.draw_border(self) # will store the current y-position counter = self.pady + 1 line_counter = 0 for line in self.view_items: # Until we reach viewport start, increment counter if line_counter < self.top_view: line_counter = line_counter + 1 else: if counter >= self.height - self.pady - 1: break if line_counter == self.selected_item: self.renderer.draw_text(self, line, self.start_y + counter, selected=True) else: self.renderer.draw_text(self, line, self.start_y + counter) counter = counter + 1 line_counter = line_counter + 1 # reset default colors self.renderer.unset_color_mode(self.color) # reset cursor should be called at the end of every draw function self.renderer.reset_cursor(self) Step 5 - add a function to __init__.py to add the widget Finally, add a function to __init__.py that will add the widget to the CUI. In our case we write the following: def add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0): id = 'Widget{}'.format(len(self.widgets.keys())) new_scroll_menu = widgets.ScrollMenu(id, title, self.grid, row, column, row_span, column_span, padx, pady) self.widgets[id] = new_scroll_menu if self.selected_widget is None: self.set_selected_widget(id) return new_scroll_menu The function must: * Create an id titled 'Widget####' where #### is replaced with the number of widget * Add the widget to the PyCUI widgets dict with the ID as a key * If there is no selected widget, make this new widget the selected one * Return a reference to the widget That's it! Your widget is now ready to be added to the CUI! Adding a new Popup This documentation section is incomplete. Feel free to expand me . Working on the renderer This documentation section is incomplete. Feel free to expand me . Working on color rules This documentation section is incomplete. Feel free to expand me .","title":"For PyCUI Developers"},{"location":"developers/#documentation-for-py_cui-developers","text":"This page contains information on writing new widgets and popups, as well as anything else required for developers and contributors for py_cui.","title":"Documentation for py_cui Developers"},{"location":"developers/#adding-a-new-widget","text":"We will walk through the steps of adding a new widget to py_cui (in this case a scroll menu) in order to demonstrate this process. Step One - Extend the Widget Class Your first step when writing a new widget is to create a class in py_cui/widgets.py that extends the base Widget class. For our ScrollMenu example: class ScrollMenu(Widget): def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) def draw(self): super().draw() The handle_key_press and draw functions must be extended for your new widget. You may leave the handle_key_press as above, if you don't require any keybindings for the widget. The draw function must extended, as the base class does no drawing itself, instead just setting up color rules. Step Two - Add additional class variables Next, add any variables that your widget may require on top of the base Widget class variables. In our case, it will be the selected item index, a list of menu items, and an integer representing the top item visible (in case the menu scrolls down). We also add some functions for getting and setting these variables. def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) self.top_view = 0 self.selected_item = 0 self.view_items = [] def clear(self): \"\"\" Clears all items from the Scroll Menu \"\"\" self.view_items = [] self.selected_item = 0 self.top_view = 0 def add_item_list(self, item_list): for item in item_list: self.add_item(item) def remove_selected_item(self): if len(self.view_items) == 0: return del self.view_items[self.selected_item] if self.selected_item >= len(self.view_items): self.selected_item = self.selected_item - 1 def get_item_list(self): return self.view_items def get(self): if len(self.view_items) > 0: return self.view_items[self.selected_item] return None Step 3 - Add Key Bindings Next, add any default key bindings you wish to have for the widget when in focus mode. In the case of the scroll menu, we wish for the arrow keys to scroll up and down, so we extend the handle_key_press function: def scroll_up(self): if self.selected: if self.top_view > 0: self.top_view = self.top_view - 1 if self.selected_item > 0: self.selected_item = self.selected_item - 1 def scroll_down(self): if self.selected: if self.selected_item < len(self.view_items) - 1: self.selected_item = self.selected_item + 1 if self.selected_item > self.top_view + self.height - (2 * self.pady) - 3: self.top_view = self.top_view + 1 def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) if key_pressed == py_cui.keys.KEY_UP_ARROW: self.scroll_up() if key_pressed == py_cui.keys.KEY_DOWN_ARROW: self.scroll_down() Note that the way default key bindings are added are simply if statements, which happen after the super() call. The scroll_up() and scroll_down() functions simply contain the logic for editing the viewport for the menu. Step 4 - implement the Draw function In the draw function, you must use the self.renderer object to render your widget to the screen. In our case, we want a border around the menu widget, and we also want to draw menu items that are within our viewport. The key renderer functions we will use are: self.renderer.draw_border(self) which will draw a border around the widget space, and self.renderer.draw_text(self, text, y_position) which will draw the text in the y_position. For our scroll menu, we would write the following: def draw(self): super().draw() # sets the color mode self.renderer.set_color_mode(self.color) # draws border around widget self.renderer.draw_border(self) # will store the current y-position counter = self.pady + 1 line_counter = 0 for line in self.view_items: # Until we reach viewport start, increment counter if line_counter < self.top_view: line_counter = line_counter + 1 else: if counter >= self.height - self.pady - 1: break if line_counter == self.selected_item: self.renderer.draw_text(self, line, self.start_y + counter, selected=True) else: self.renderer.draw_text(self, line, self.start_y + counter) counter = counter + 1 line_counter = line_counter + 1 # reset default colors self.renderer.unset_color_mode(self.color) # reset cursor should be called at the end of every draw function self.renderer.reset_cursor(self) Step 5 - add a function to __init__.py to add the widget Finally, add a function to __init__.py that will add the widget to the CUI. In our case we write the following: def add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0): id = 'Widget{}'.format(len(self.widgets.keys())) new_scroll_menu = widgets.ScrollMenu(id, title, self.grid, row, column, row_span, column_span, padx, pady) self.widgets[id] = new_scroll_menu if self.selected_widget is None: self.set_selected_widget(id) return new_scroll_menu The function must: * Create an id titled 'Widget####' where #### is replaced with the number of widget * Add the widget to the PyCUI widgets dict with the ID as a key * If there is no selected widget, make this new widget the selected one * Return a reference to the widget That's it! Your widget is now ready to be added to the CUI!","title":"Adding a new Widget"},{"location":"developers/#adding-a-new-popup","text":"This documentation section is incomplete. Feel free to expand me .","title":"Adding a new Popup"},{"location":"developers/#working-on-the-renderer","text":"This documentation section is incomplete. Feel free to expand me .","title":"Working on the renderer"},{"location":"developers/#working-on-color-rules","text":"This documentation section is incomplete. Feel free to expand me .","title":"Working on color rules"},{"location":"examples/","text":"py_cui Examples There are several examples of simple py_cui programs you can find in the examples directory of the github repository. In addition, a larger python module pyautogit was written with py_cui , and is available for download using pip or from github. In this section of the documentation we will explain the source code for some of the supplied examples in more detail. Hello py_cui! As is tradition with programming, we start with our Hello World example. Here we simply create a PyCUI object with a grid size of 3 x 3, and we add a Label into the center grid space. This is the most basic py_cui you can create. # Import the lib import py_cui # create the CUI object. Will have a 3 by 3 grid with indexes from 0,0 to 2,2 root = py_cui.PyCUI(3,3) # Add a label to the center of the CUI in the 1,1 grid position root.add_label('Hello py_cui!!!', 1, 1) # Start/Render the CUI root.start() Simple Todo List A simple usage of py_cui for creating a terminal todo list. We use keybindings to get control of each of our lists as well as our text entry import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Keybindings for controlling our CUI. # We bind the enter key for each of the widgets self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Popups Example This example will demonstrate the usage for using all supported popups. # imports import py_cui import time import os import threading # We will need the threading library when we want to use the loading popups class PopupExample: def __init__(self, master): # This is a reference to our top level CUI object self.master = master # buttons for control - each simply spawns the linked popup self.show_message_popup = self.master.add_button('Show Message Popup', 0, 0, command=self.show_message) self.show_yes_no_popup = self.master.add_button('Show Yes No Popup', 1, 0, command=self.show_yes_no) self.show_loading_icon_popup = self.master.add_button('Show Loading Icon Popup', 2, 0, command=self.show_loading_icon) self.show_loading_bar_popup = self.master.add_button('Show Loading Bar Popup', 0,1, command = self.show_loading_bar) self.show_text_box_popup = self.master.add_button('Show Text Box Popup', 1,1, command = self.show_text_box) self.show_menu_popup = self.master.add_button('Show Scroll Menu Popup', 2,1, command = self.show_menu_popup_fun) def show_message(self): \"\"\" Displays a simple message popup \"\"\" self.master.show_message_popup('Hello!', 'This is a message popup. You can also spawn warnings and errors.') ################################################ # YES NO POPUP def quit_cui(self, to_quit): # THis is the function given to the yes no popup. The to_quit parameter will be true if y is pressed, or False if n is pressed if to_quit: exit() else: self.master.show_message_popup('Cancelled', 'The quit operation was cancelled.') def show_yes_no(self): \"\"\" Displays a yes no popup asking if the user would like to quit \"\"\" # For the yes/no popup, the 'command' parameter must take a function that requires a single boolean parameter self.master.show_yes_no_popup('Are you sure you want to quit?', self.quit_cui) ################################################ ################################################ # TEXTBOX POPUP def reset_title(self, new_title): self.master.title = new_title def show_text_box(self): \"\"\" Displays a textbox popup asking the user for a new window title \"\"\" # A textbox popup requires a prompt and a function reference. The function must take a single string parameter that will return # whatever is within the text box when the ENTER key is pressed self.master.show_text_box_popup('Please enter a new window title', self.reset_title) ################################################ ################################################ # SCROLL MENU POPUP def change_button_color(self, new_color): \"\"\" Function called when ENTER pressed in menu popup. Takes string as parameter \"\"\" color = py_cui.WHITE_ON_BLACK if new_color == \"RED\": color = py_cui.RED_ON_BLACK elif new_color == \"CYAN\": color = py_cui.CYAN_ON_BLACK elif new_color == \"MAGENTA\": color = py_cui.MAGENTA_ON_BLACK for key in self.master.widgets.keys(): if isinstance(self.master.widgets[key], py_cui.widgets.Button): self.master.widgets[key].color = color def show_menu_popup_fun(self): \"\"\" Opens scroll menu for selecting button colors \"\"\" # Spawning a menu popup must recieve a list of strings as menu options, and a function reference that takes a string parameter menu_choices = ['RED', 'CYAN', 'MAGENTA'] self.master.show_menu_popup('Please select a new button color', menu_choices, self.change_button_color) ################################################ def show_loading_icon(self): \"\"\" Function that shows the usage for spwaning a loading icon popup \"\"\" # The loading popup will remain onscreen until the stop loading function is called. Call this before a large operation, and call # stop after the operation is finished. Note that for these long operations, you must use a different thread # to not block the draw calls. self.master.show_loading_icon_popup('Please Wait', 'Loading') operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def show_loading_bar(self): \"\"\" Function that shows the usage for spawning a loading bar popup \"\"\" self.master.show_loading_bar_popup('Incrementing a counter...', 100) operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def long_operation(self): \"\"\" A simple function that demonstrates a long callback operation performed while loading popup is open \"\"\" counter = 0 for i in range(0, 100): time.sleep(0.1) counter= counter +1 self.master.status_bar.set_text(str(counter)) # When using a bar indicator, we will increment the completed counter. Will be ignored for loading icon popup self.master.increment_loading_bar() # This is what stops the loading popup and reenters overview mode self.master.stop_loading_popup() # Create the CUI, pass it to the wrapper object, and start it root = py_cui.PyCUI(3, 2) root.set_title('CUI Popups Example') s = PopupExample(root) root.start() Other examples Other examples are available in the examples directory in the repository on github. For a larger example of a project using py_cui , see pyautogit .","title":"Examples"},{"location":"examples/#py_cui-examples","text":"There are several examples of simple py_cui programs you can find in the examples directory of the github repository. In addition, a larger python module pyautogit was written with py_cui , and is available for download using pip or from github. In this section of the documentation we will explain the source code for some of the supplied examples in more detail.","title":"py_cui Examples"},{"location":"examples/#hello-py_cui","text":"As is tradition with programming, we start with our Hello World example. Here we simply create a PyCUI object with a grid size of 3 x 3, and we add a Label into the center grid space. This is the most basic py_cui you can create. # Import the lib import py_cui # create the CUI object. Will have a 3 by 3 grid with indexes from 0,0 to 2,2 root = py_cui.PyCUI(3,3) # Add a label to the center of the CUI in the 1,1 grid position root.add_label('Hello py_cui!!!', 1, 1) # Start/Render the CUI root.start()","title":"Hello py_cui!"},{"location":"examples/#simple-todo-list","text":"A simple usage of py_cui for creating a terminal todo list. We use keybindings to get control of each of our lists as well as our text entry import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Keybindings for controlling our CUI. # We bind the enter key for each of the widgets self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start()","title":"Simple Todo List"},{"location":"examples/#popups-example","text":"This example will demonstrate the usage for using all supported popups. # imports import py_cui import time import os import threading # We will need the threading library when we want to use the loading popups class PopupExample: def __init__(self, master): # This is a reference to our top level CUI object self.master = master # buttons for control - each simply spawns the linked popup self.show_message_popup = self.master.add_button('Show Message Popup', 0, 0, command=self.show_message) self.show_yes_no_popup = self.master.add_button('Show Yes No Popup', 1, 0, command=self.show_yes_no) self.show_loading_icon_popup = self.master.add_button('Show Loading Icon Popup', 2, 0, command=self.show_loading_icon) self.show_loading_bar_popup = self.master.add_button('Show Loading Bar Popup', 0,1, command = self.show_loading_bar) self.show_text_box_popup = self.master.add_button('Show Text Box Popup', 1,1, command = self.show_text_box) self.show_menu_popup = self.master.add_button('Show Scroll Menu Popup', 2,1, command = self.show_menu_popup_fun) def show_message(self): \"\"\" Displays a simple message popup \"\"\" self.master.show_message_popup('Hello!', 'This is a message popup. You can also spawn warnings and errors.') ################################################ # YES NO POPUP def quit_cui(self, to_quit): # THis is the function given to the yes no popup. The to_quit parameter will be true if y is pressed, or False if n is pressed if to_quit: exit() else: self.master.show_message_popup('Cancelled', 'The quit operation was cancelled.') def show_yes_no(self): \"\"\" Displays a yes no popup asking if the user would like to quit \"\"\" # For the yes/no popup, the 'command' parameter must take a function that requires a single boolean parameter self.master.show_yes_no_popup('Are you sure you want to quit?', self.quit_cui) ################################################ ################################################ # TEXTBOX POPUP def reset_title(self, new_title): self.master.title = new_title def show_text_box(self): \"\"\" Displays a textbox popup asking the user for a new window title \"\"\" # A textbox popup requires a prompt and a function reference. The function must take a single string parameter that will return # whatever is within the text box when the ENTER key is pressed self.master.show_text_box_popup('Please enter a new window title', self.reset_title) ################################################ ################################################ # SCROLL MENU POPUP def change_button_color(self, new_color): \"\"\" Function called when ENTER pressed in menu popup. Takes string as parameter \"\"\" color = py_cui.WHITE_ON_BLACK if new_color == \"RED\": color = py_cui.RED_ON_BLACK elif new_color == \"CYAN\": color = py_cui.CYAN_ON_BLACK elif new_color == \"MAGENTA\": color = py_cui.MAGENTA_ON_BLACK for key in self.master.widgets.keys(): if isinstance(self.master.widgets[key], py_cui.widgets.Button): self.master.widgets[key].color = color def show_menu_popup_fun(self): \"\"\" Opens scroll menu for selecting button colors \"\"\" # Spawning a menu popup must recieve a list of strings as menu options, and a function reference that takes a string parameter menu_choices = ['RED', 'CYAN', 'MAGENTA'] self.master.show_menu_popup('Please select a new button color', menu_choices, self.change_button_color) ################################################ def show_loading_icon(self): \"\"\" Function that shows the usage for spwaning a loading icon popup \"\"\" # The loading popup will remain onscreen until the stop loading function is called. Call this before a large operation, and call # stop after the operation is finished. Note that for these long operations, you must use a different thread # to not block the draw calls. self.master.show_loading_icon_popup('Please Wait', 'Loading') operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def show_loading_bar(self): \"\"\" Function that shows the usage for spawning a loading bar popup \"\"\" self.master.show_loading_bar_popup('Incrementing a counter...', 100) operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def long_operation(self): \"\"\" A simple function that demonstrates a long callback operation performed while loading popup is open \"\"\" counter = 0 for i in range(0, 100): time.sleep(0.1) counter= counter +1 self.master.status_bar.set_text(str(counter)) # When using a bar indicator, we will increment the completed counter. Will be ignored for loading icon popup self.master.increment_loading_bar() # This is what stops the loading popup and reenters overview mode self.master.stop_loading_popup() # Create the CUI, pass it to the wrapper object, and start it root = py_cui.PyCUI(3, 2) root.set_title('CUI Popups Example') s = PopupExample(root) root.start()","title":"Popups Example"},{"location":"examples/#other-examples","text":"Other examples are available in the examples directory in the repository on github. For a larger example of a project using py_cui , see pyautogit .","title":"Other examples"},{"location":"functions/","text":"py_cui functions This page will list all functions and methods included with py_cui . It is not yet completed.","title":"py_cui functions"},{"location":"functions/#py_cui-functions","text":"This page will list all functions and methods included with py_cui . It is not yet completed.","title":"py_cui functions"},{"location":"install/","text":"Installation The easiest way to install py_cui is to use pip . You may simply run: pip install py_cui and the library should install along with all dependancies. If you are working on a machine where pip defaults to the Python 2 version, replace pip with pip3 . There is no Python 2 support for py_cui , you will need a version of Python 3.4+ in order to use it. It may function with lower versions of Python 3, but it has not been tested on them. Alternatively, if you wish to avoid using pip, you may install from this repository: git clone https://github.com/jwlodek/py_cui cd py_cui pip install . This will use pip to install from the sources in the git repository. If you wish to avoid installing altogether, you may copy an example from the examples/ directory into the root py_cui directory, and run it with python3. Note that in this case you are required to install the dependancies yourself, which are curses on UNIX (should be included with python3) and windows-curses on windows, which can be installed with pip . Running Unit Tests Unit tests for py_cui are written for pytest. Simply clone the repository, and run pytest in the root directory: git clone https://github.com/jwlodek/py_cui cd py_cui pytest These tests are also run on Travis-CI each time a new commit is pushed to the upstream repository. Running Examples To run examples, install py_cui, enter the examples/ directory, and run them with python3. For example, to run todo_list_example.py : cd examples python3 todo_list_example.py Feel free to take a look at the Examples section of this documentation for more details.","title":"Installation"},{"location":"install/#installation","text":"The easiest way to install py_cui is to use pip . You may simply run: pip install py_cui and the library should install along with all dependancies. If you are working on a machine where pip defaults to the Python 2 version, replace pip with pip3 . There is no Python 2 support for py_cui , you will need a version of Python 3.4+ in order to use it. It may function with lower versions of Python 3, but it has not been tested on them. Alternatively, if you wish to avoid using pip, you may install from this repository: git clone https://github.com/jwlodek/py_cui cd py_cui pip install . This will use pip to install from the sources in the git repository. If you wish to avoid installing altogether, you may copy an example from the examples/ directory into the root py_cui directory, and run it with python3. Note that in this case you are required to install the dependancies yourself, which are curses on UNIX (should be included with python3) and windows-curses on windows, which can be installed with pip .","title":"Installation"},{"location":"install/#running-unit-tests","text":"Unit tests for py_cui are written for pytest. Simply clone the repository, and run pytest in the root directory: git clone https://github.com/jwlodek/py_cui cd py_cui pytest These tests are also run on Travis-CI each time a new commit is pushed to the upstream repository.","title":"Running Unit Tests"},{"location":"install/#running-examples","text":"To run examples, install py_cui, enter the examples/ directory, and run them with python3. For example, to run todo_list_example.py : cd examples python3 todo_list_example.py Feel free to take a look at the Examples section of this documentation for more details.","title":"Running Examples"},{"location":"keybindings/","text":"Keybindings Almost all CUI elements in py_cui support some degree of keybindings. The order in which these keybindings are executed depend on the order they are added, however, user keybindings are always executed prior to default keybindings, so make sure you don't unintentionally override an already bound key. Lists of default keybindings for each widget are available in the Widgets section of this documentation, and a list of default keybindings for overview mode is found in the Usage section. Adding a Keybinding For all keybindings, you must pass a py_cui key and a function with no arguments. This function will be fired when the key bound to it is detected. The function may also be a class funciton, with self.FUNCTION being passed into the add keybinding function. Make sure to take a look at the examples for more uses of keybindings. Overview Mode To add a keybinding to overview mode, you need to add it to the PyCUI object itself. For example, if I wanted to add a binding for the c key to clear all text fields in my cui : # import the library import py_cui # Create the PyCUI and add a text field root = py_cui.PyCUI(3, 3) text_field = root.add_text_box('Text Field', 1, 1) # This function simply clears the text in the text field def clear_text_field(): text_field.clear() # Add the key binding to the PyCUI object itself for overview mode. root.add_key_command(py_cui.keys.KEY_C_LOWER, clear_text_field) # Start the CUI root.start() Focus Mode Adding keybindings to focus mode is done at a widget by widget basis. When a widget is added to the PyCUI , the returned object is used to add a key command. Once again, make sure to check default key bindings that should only be overridden if the user specifically desires to replace their functionality. For example, in a menu widget, if we wish to set the window title to the selected menu item with the t key, we could write the following: # import the library import py_cui # Create the CUI object root = py_cui.PyCUI(3,3) # Add the scroll menu with the three menu items menu_items = ['Item1', 'Item2', 'Item3'] menu = root.add_scroll_menu('Test Menu', 1, 1) menu.add_item_list(menu_items) # Function that sets the root window title def set_title_from_menu(): root.set_title(menu.get()) # Bind the 't' key to the above function menu.add_key_command(py_cui.keys.KEY_T_LOWER, set_title_from_menu) # start the CUI root.start() Supported Keys Below is a table of all keys supported by py_cui . Each key is accessed within your program with py_cui.keys.YOUR_KEY_CODE . There are some differences in the way keycodes are handled on win32 vs. UNIX, though this is abstracted away by py_cui. Key Code Key Presses KEY_ENTER Enter (newline) Key KEY_ESCAPE Escape Key KEY_SPACE Space Key KEY_DELETE Delete Key KEY_TAB Tab Key KEY_UP_ARROW Up Arrow Key KEY_DOWN_ARROW Down Arrow Key KEY_LEFT_ARROW Left Arrow Key KEY_RIGHT_ARROW Right Arrow Key KEY_PAGE_UP Page Up Key KEY_PAGE_DOWN Page Down Key KEY_F1 F1 Function Key KEY_F2 F2 Function Key KEY_F3 F3 Function Key KEY_F4 F4 Function Key KEY_F5 F5 Function Key KEY_F6 F6 Function Key KEY_F7 F7 Function Key KEY_F8 F8 Function Key KEY_HOME Home Key KEY_END End Key KEY_A_LOWER a Key KEY_B_LOWER b Key KEY_C_LOWER c Key KEY_D_LOWER d Key KEY_E_LOWER e Key KEY_F_LOWER f Key KEY_G_LOWER g Key KEY_H_LOWER h Key KEY_I_LOWER i Key KEY_J_LOWER j Key KEY_K_LOWER k Key KEY_L_LOWER l Key KEY_M_LOWER m Key KEY_N_LOWER n Key KEY_O_LOWER o Key KEY_P_LOWER p Key KEY_Q_LOWER q Key KEY_R_LOWER r Key KEY_S_LOWER s Key KEY_T_LOWER t Key KEY_U_LOWER u Key KEY_V_LOWER v Key KEY_W_LOWER w Key KEY_X_LOWER x Key KEY_Y_LOWER y Key KEY_Z_LOWER z Key KEY_A_UPPER a Key + Shift Key KEY_B_UPPER b Key + Shift Key KEY_C_UPPER c Key + Shift Key KEY_D_UPPER d Key + Shift Key KEY_E_UPPER e Key + Shift Key KEY_F_UPPER f Key + Shift Key KEY_G_UPPER g Key + Shift Key KEY_H_UPPER h Key + Shift Key KEY_I_UPPER i Key + Shift Key KEY_J_UPPER j Key + Shift Key KEY_K_UPPER k Key + Shift Key KEY_L_UPPER l Key + Shift Key KEY_M_UPPER m Key + Shift Key KEY_N_UPPER n Key + Shift Key KEY_O_UPPER o Key + Shift Key KEY_P_UPPER p Key + Shift Key KEY_Q_UPPER q Key + Shift Key KEY_R_UPPER r Key + Shift Key KEY_S_UPPER s Key + Shift Key KEY_T_UPPER t Key + Shift Key KEY_U_UPPER u Key + Shift Key KEY_V_UPPER v Key + Shift Key KEY_W_UPPER w Key + Shift Key KEY_X_UPPER x Key + Shift Key KEY_Y_UPPER y Key + Shift Key KEY_Z_UPPER z Key + Shift Key KEY_BACKSPACE Backspace Key","title":"Keys"},{"location":"keybindings/#keybindings","text":"Almost all CUI elements in py_cui support some degree of keybindings. The order in which these keybindings are executed depend on the order they are added, however, user keybindings are always executed prior to default keybindings, so make sure you don't unintentionally override an already bound key. Lists of default keybindings for each widget are available in the Widgets section of this documentation, and a list of default keybindings for overview mode is found in the Usage section.","title":"Keybindings"},{"location":"keybindings/#adding-a-keybinding","text":"For all keybindings, you must pass a py_cui key and a function with no arguments. This function will be fired when the key bound to it is detected. The function may also be a class funciton, with self.FUNCTION being passed into the add keybinding function. Make sure to take a look at the examples for more uses of keybindings. Overview Mode To add a keybinding to overview mode, you need to add it to the PyCUI object itself. For example, if I wanted to add a binding for the c key to clear all text fields in my cui : # import the library import py_cui # Create the PyCUI and add a text field root = py_cui.PyCUI(3, 3) text_field = root.add_text_box('Text Field', 1, 1) # This function simply clears the text in the text field def clear_text_field(): text_field.clear() # Add the key binding to the PyCUI object itself for overview mode. root.add_key_command(py_cui.keys.KEY_C_LOWER, clear_text_field) # Start the CUI root.start() Focus Mode Adding keybindings to focus mode is done at a widget by widget basis. When a widget is added to the PyCUI , the returned object is used to add a key command. Once again, make sure to check default key bindings that should only be overridden if the user specifically desires to replace their functionality. For example, in a menu widget, if we wish to set the window title to the selected menu item with the t key, we could write the following: # import the library import py_cui # Create the CUI object root = py_cui.PyCUI(3,3) # Add the scroll menu with the three menu items menu_items = ['Item1', 'Item2', 'Item3'] menu = root.add_scroll_menu('Test Menu', 1, 1) menu.add_item_list(menu_items) # Function that sets the root window title def set_title_from_menu(): root.set_title(menu.get()) # Bind the 't' key to the above function menu.add_key_command(py_cui.keys.KEY_T_LOWER, set_title_from_menu) # start the CUI root.start()","title":"Adding a Keybinding"},{"location":"keybindings/#supported-keys","text":"Below is a table of all keys supported by py_cui . Each key is accessed within your program with py_cui.keys.YOUR_KEY_CODE . There are some differences in the way keycodes are handled on win32 vs. UNIX, though this is abstracted away by py_cui. Key Code Key Presses KEY_ENTER Enter (newline) Key KEY_ESCAPE Escape Key KEY_SPACE Space Key KEY_DELETE Delete Key KEY_TAB Tab Key KEY_UP_ARROW Up Arrow Key KEY_DOWN_ARROW Down Arrow Key KEY_LEFT_ARROW Left Arrow Key KEY_RIGHT_ARROW Right Arrow Key KEY_PAGE_UP Page Up Key KEY_PAGE_DOWN Page Down Key KEY_F1 F1 Function Key KEY_F2 F2 Function Key KEY_F3 F3 Function Key KEY_F4 F4 Function Key KEY_F5 F5 Function Key KEY_F6 F6 Function Key KEY_F7 F7 Function Key KEY_F8 F8 Function Key KEY_HOME Home Key KEY_END End Key KEY_A_LOWER a Key KEY_B_LOWER b Key KEY_C_LOWER c Key KEY_D_LOWER d Key KEY_E_LOWER e Key KEY_F_LOWER f Key KEY_G_LOWER g Key KEY_H_LOWER h Key KEY_I_LOWER i Key KEY_J_LOWER j Key KEY_K_LOWER k Key KEY_L_LOWER l Key KEY_M_LOWER m Key KEY_N_LOWER n Key KEY_O_LOWER o Key KEY_P_LOWER p Key KEY_Q_LOWER q Key KEY_R_LOWER r Key KEY_S_LOWER s Key KEY_T_LOWER t Key KEY_U_LOWER u Key KEY_V_LOWER v Key KEY_W_LOWER w Key KEY_X_LOWER x Key KEY_Y_LOWER y Key KEY_Z_LOWER z Key KEY_A_UPPER a Key + Shift Key KEY_B_UPPER b Key + Shift Key KEY_C_UPPER c Key + Shift Key KEY_D_UPPER d Key + Shift Key KEY_E_UPPER e Key + Shift Key KEY_F_UPPER f Key + Shift Key KEY_G_UPPER g Key + Shift Key KEY_H_UPPER h Key + Shift Key KEY_I_UPPER i Key + Shift Key KEY_J_UPPER j Key + Shift Key KEY_K_UPPER k Key + Shift Key KEY_L_UPPER l Key + Shift Key KEY_M_UPPER m Key + Shift Key KEY_N_UPPER n Key + Shift Key KEY_O_UPPER o Key + Shift Key KEY_P_UPPER p Key + Shift Key KEY_Q_UPPER q Key + Shift Key KEY_R_UPPER r Key + Shift Key KEY_S_UPPER s Key + Shift Key KEY_T_UPPER t Key + Shift Key KEY_U_UPPER u Key + Shift Key KEY_V_UPPER v Key + Shift Key KEY_W_UPPER w Key + Shift Key KEY_X_UPPER x Key + Shift Key KEY_Y_UPPER y Key + Shift Key KEY_Z_UPPER z Key + Shift Key KEY_BACKSPACE Backspace Key","title":"Supported Keys"},{"location":"popups/","text":"Popups This page contains information regarding all popups supported by py_cui . Please see the popups_example.py in the examples/ directory in the repository. Message/Warning/Error Popup Spawn Command show_message_popup(title, text) show_warning_popup(title, text) show_error_popup(title, text) Usage Used to show a simple message, with a different color depending on warning level. Keys Exit from the popup with KEY_ENTER , KEY_ESCAPE , or KEY_SPACE . Yes/No Popup Spawn Command show_yes_no_popup(self, title, command) Usage Ask user yes/no question. The command parameter passed to the spawn function must be a function that takes a single boolean parameter. Keys If KEY_Y_LOWER is pressed, the command will be run with True passed in, otherwise False is passed in. Loading Icon/Bar Popup Spawn Command show_loading_icon_popup(title, message) show_loading_bar_popup(title, num_items) Usage The loading popups must be used in conjunction with some sort of async/threading. First, spawn the popup and then start a thread performing the long operation. At the end of the long operation, call: stop_loading_popup() Which will escape the loading popup. When using the loading bar popup, increment yout item counter with: increment_loading_bar() Keys None TextBox Popup Spawn Command show_text_box_popup(title, command) Usage Spawn a text box, and on KEY_ENTER pressed, the command function is triggered with the text from the popup as the parameter. Keys The letter keys will write the text, and KEY_ENTER submits. Menu Popup Spawn Command show_menu_popup(title, menu_items, command, run_command_if_none=False) Usage Use as an overall menu system for your application. Gives user option to select from list. Fires the command with the selected menu item as a parameter on KEY_ENTER Keys Arrow keys scroll up and down, enter key submits.","title":"Popups"},{"location":"popups/#popups","text":"This page contains information regarding all popups supported by py_cui . Please see the popups_example.py in the examples/ directory in the repository.","title":"Popups"},{"location":"popups/#messagewarningerror-popup","text":"Spawn Command show_message_popup(title, text) show_warning_popup(title, text) show_error_popup(title, text) Usage Used to show a simple message, with a different color depending on warning level. Keys Exit from the popup with KEY_ENTER , KEY_ESCAPE , or KEY_SPACE .","title":"Message/Warning/Error Popup"},{"location":"popups/#yesno-popup","text":"Spawn Command show_yes_no_popup(self, title, command) Usage Ask user yes/no question. The command parameter passed to the spawn function must be a function that takes a single boolean parameter. Keys If KEY_Y_LOWER is pressed, the command will be run with True passed in, otherwise False is passed in.","title":"Yes/No Popup"},{"location":"popups/#loading-iconbar-popup","text":"Spawn Command show_loading_icon_popup(title, message) show_loading_bar_popup(title, num_items) Usage The loading popups must be used in conjunction with some sort of async/threading. First, spawn the popup and then start a thread performing the long operation. At the end of the long operation, call: stop_loading_popup() Which will escape the loading popup. When using the loading bar popup, increment yout item counter with: increment_loading_bar() Keys None","title":"Loading Icon/Bar Popup"},{"location":"popups/#textbox-popup","text":"Spawn Command show_text_box_popup(title, command) Usage Spawn a text box, and on KEY_ENTER pressed, the command function is triggered with the text from the popup as the parameter. Keys The letter keys will write the text, and KEY_ENTER submits.","title":"TextBox Popup"},{"location":"popups/#menu-popup","text":"Spawn Command show_menu_popup(title, menu_items, command, run_command_if_none=False) Usage Use as an overall menu system for your application. Gives user option to select from list. Fires the command with the selected menu item as a parameter on KEY_ENTER Keys Arrow keys scroll up and down, enter key submits.","title":"Menu Popup"},{"location":"usage/","text":"Usage In this section we discuss some universal usage rules common to all py_cui based interfaces. py_cui Operation Modes Each py_cui based interface has three operation modes: overview mode, focus mode, and popup mode. Overview Mode In overview mode, you use your arrow keys to navigate between widgets. Note that making a py_cui with a gap between widgets will not work, as they will be unreachable. Please use row_span/column_span instead. While in overview mode you may also press buttons by hovering over them and pressing Enter, or you may enter focus mode on a widget by hovering over it and pressing Enter. In addition, any keybindings you add to the root PyCUI object will be accessible while in overview mode. Also while in overview mode, by default the q key is used to quit. Focus mode Once you enter focus mode on a particular widget, different keybindings apply. These vary from widget to widget, but the Esc key always returns to overview mode. Also, any keybindings assigned to the in-focus widget will be honored here. Popup Mode During popup mode, no keybindings are accepted by default. Certain popups allow for certain keys to close or interact with them however. When in popup mode no CUI widgets or overview are accessible. If a widget was in focus when popup mode is initiated, focus is lost.","title":"Basic Usage"},{"location":"usage/#usage","text":"In this section we discuss some universal usage rules common to all py_cui based interfaces.","title":"Usage"},{"location":"usage/#py_cui-operation-modes","text":"Each py_cui based interface has three operation modes: overview mode, focus mode, and popup mode. Overview Mode In overview mode, you use your arrow keys to navigate between widgets. Note that making a py_cui with a gap between widgets will not work, as they will be unreachable. Please use row_span/column_span instead. While in overview mode you may also press buttons by hovering over them and pressing Enter, or you may enter focus mode on a widget by hovering over it and pressing Enter. In addition, any keybindings you add to the root PyCUI object will be accessible while in overview mode. Also while in overview mode, by default the q key is used to quit. Focus mode Once you enter focus mode on a particular widget, different keybindings apply. These vary from widget to widget, but the Esc key always returns to overview mode. Also, any keybindings assigned to the in-focus widget will be honored here. Popup Mode During popup mode, no keybindings are accepted by default. Certain popups allow for certain keys to close or interact with them however. When in popup mode no CUI widgets or overview are accessible. If a widget was in focus when popup mode is initiated, focus is lost.","title":"py_cui Operation Modes"},{"location":"widgets/","text":"Widgets Below are details on each widget supported by py_cui including how to add them to a CUI, and their supported functions. Base Widget Class This base class contains all shared functionality. Label Widget Specific Class Variables None Widget Specific Functions None Usage Labels only display text. You cannot enter focus mode on labels, and thus keybindings will have no effect. Add labels for single lines to text to the center of a grid cell. Adding to CUI add_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title in the center of the grid location it is placed in. Default Keybindings None Block Label Widget Specific Class Variables self.lines - represents the title passed in split on newline characters Widget Specific Functions None Usage Block Labels only display text. You cannot enter focus mode on block labels, and thus keybindings will have no effect. Add block labels for multi line text that will be drawn in the center of the grid cell. One example for this is to display ASCII-Art. Adding to CUI add_block_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title.splitlines() in the center of the grid location it is placed in. Default Keybindings None Button Widget Specific Class Variables self.command - represents the command executed when Enter key pressed on button Widget Specific Functions None Usage Buttons execute a no-args function when enter pressed. By default, pressing enter when hovering over a button executes the command instead of entering focus mode. To disable this behavior, add the auto_focus_buttons=False to the creation of the PyCUI object. Adding to CUI add_button(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Draw Behavior Draws self.title centered in the grid cell, with a border. By default, buttons have a magenta color. Default Keybindings KEY_ENTER - runs the command passed into the button Scroll Menu Widget Specific Class Variables self.top_view - Uppermost menu item in viewport self.selected_item - currently selected item index self.view_items - list of menu items Widget Specific Functions clear() - removes all selected items scroll_up() - Internal use only, scrolls up in menu scroll_down() - Internal use only, scrolls down in menu add_item(item) - Takes in a string, adds it as an item to the menu add_item_list(item_list) - Takes a list of strings, adds them all to the menu remove_selected_item() - Removes the currently selected item from the menu get() - Returns the currently selected item get_item_list() - gets current list of menu items Usage Scroll Menus are very useful for having multiple option menus or for showing a list of information. The most common usage is to add a keybinding for the ENTER which processes some function depending on the selected item. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list Checkbox Menu The checkbox menu extends from the scrollmenu, and so shares many functions with it. Widget Specific Class Variables self.selected_item_list - list of selected items self.checked_char - character to mark item as checked Widget Specific Functions mark_item_as_checked(text) - marks item matching text as checked get() - overrides the ScrollMenu function. Returns the selected item list All functions included from ScrollMenu are also available. Usage Checkbox Menus are very useful for selecting several options. They should be used for having the user to select multiple items. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_checkbox_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list Text Box Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left() - Shifts the cursor the the left. Internal use only move_right() - Shifts the cursor the the right. Internal use only insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only Usage Used for user entering text into CUI. For prompts, it is suggested to use the Textbox popup instead. Adding to CUI add_text_box(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry field centered in the grid cell assigned Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text Text Block Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left(current_line) - Shifts the cursor to the left. Internal use only move_right(current_line) - Shifts the cursor to the right. Internal use only move_down(current_line) - Shifts the cursor down. Internal use only move_up(current_line) - Shifts the cursor up. Internal use only write(text) - writes text to the textblock insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only handle_delete(current_line) - Handles deleting characters. Internal use only handle_end(current_line) - handles end key. Internal use only handle_home(current_line) - handles home key. Internal use only handle_backspace(current_line) - handles backspace key. Internal use only handle_newline(current_line) - handles newline key. Internal use only Usage TextBoxes have two key uses: * For editing larger blocks of text, such as if you wish to create a CUI text editor (see snano example) * For displaying large amounts of text, such as statuses, logs etc. (see pyautogit example) Adding to CUI add_text_block(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry box that fills the grid cells. Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right KEY_DOWN_ARROW - Shifts cursor down KEY_UP_ARROW - Shifts cursor up Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text KEY_TAB - Enters 4 space characters (Sorry tab people) KEY_DELETE - Deletes next character KEY_ENTER - Inserts newline character","title":"Widgets"},{"location":"widgets/#widgets","text":"Below are details on each widget supported by py_cui including how to add them to a CUI, and their supported functions.","title":"Widgets"},{"location":"widgets/#base-widget-class","text":"This base class contains all shared functionality.","title":"Base Widget Class"},{"location":"widgets/#label","text":"Widget Specific Class Variables None Widget Specific Functions None Usage Labels only display text. You cannot enter focus mode on labels, and thus keybindings will have no effect. Add labels for single lines to text to the center of a grid cell. Adding to CUI add_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title in the center of the grid location it is placed in. Default Keybindings None","title":"Label"},{"location":"widgets/#block-label","text":"Widget Specific Class Variables self.lines - represents the title passed in split on newline characters Widget Specific Functions None Usage Block Labels only display text. You cannot enter focus mode on block labels, and thus keybindings will have no effect. Add block labels for multi line text that will be drawn in the center of the grid cell. One example for this is to display ASCII-Art. Adding to CUI add_block_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title.splitlines() in the center of the grid location it is placed in. Default Keybindings None","title":"Block Label"},{"location":"widgets/#button","text":"Widget Specific Class Variables self.command - represents the command executed when Enter key pressed on button Widget Specific Functions None Usage Buttons execute a no-args function when enter pressed. By default, pressing enter when hovering over a button executes the command instead of entering focus mode. To disable this behavior, add the auto_focus_buttons=False to the creation of the PyCUI object. Adding to CUI add_button(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Draw Behavior Draws self.title centered in the grid cell, with a border. By default, buttons have a magenta color. Default Keybindings KEY_ENTER - runs the command passed into the button","title":"Button"},{"location":"widgets/#scroll-menu","text":"Widget Specific Class Variables self.top_view - Uppermost menu item in viewport self.selected_item - currently selected item index self.view_items - list of menu items Widget Specific Functions clear() - removes all selected items scroll_up() - Internal use only, scrolls up in menu scroll_down() - Internal use only, scrolls down in menu add_item(item) - Takes in a string, adds it as an item to the menu add_item_list(item_list) - Takes a list of strings, adds them all to the menu remove_selected_item() - Removes the currently selected item from the menu get() - Returns the currently selected item get_item_list() - gets current list of menu items Usage Scroll Menus are very useful for having multiple option menus or for showing a list of information. The most common usage is to add a keybinding for the ENTER which processes some function depending on the selected item. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list","title":"Scroll Menu"},{"location":"widgets/#checkbox-menu","text":"The checkbox menu extends from the scrollmenu, and so shares many functions with it. Widget Specific Class Variables self.selected_item_list - list of selected items self.checked_char - character to mark item as checked Widget Specific Functions mark_item_as_checked(text) - marks item matching text as checked get() - overrides the ScrollMenu function. Returns the selected item list All functions included from ScrollMenu are also available. Usage Checkbox Menus are very useful for selecting several options. They should be used for having the user to select multiple items. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_checkbox_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list","title":"Checkbox Menu"},{"location":"widgets/#text-box","text":"Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left() - Shifts the cursor the the left. Internal use only move_right() - Shifts the cursor the the right. Internal use only insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only Usage Used for user entering text into CUI. For prompts, it is suggested to use the Textbox popup instead. Adding to CUI add_text_box(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry field centered in the grid cell assigned Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text","title":"Text Box"},{"location":"widgets/#text-block","text":"Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left(current_line) - Shifts the cursor to the left. Internal use only move_right(current_line) - Shifts the cursor to the right. Internal use only move_down(current_line) - Shifts the cursor down. Internal use only move_up(current_line) - Shifts the cursor up. Internal use only write(text) - writes text to the textblock insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only handle_delete(current_line) - Handles deleting characters. Internal use only handle_end(current_line) - handles end key. Internal use only handle_home(current_line) - handles home key. Internal use only handle_backspace(current_line) - handles backspace key. Internal use only handle_newline(current_line) - handles newline key. Internal use only Usage TextBoxes have two key uses: * For editing larger blocks of text, such as if you wish to create a CUI text editor (see snano example) * For displaying large amounts of text, such as statuses, logs etc. (see pyautogit example) Adding to CUI add_text_block(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry box that fills the grid cells. Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right KEY_DOWN_ARROW - Shifts cursor down KEY_UP_ARROW - Shifts cursor up Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text KEY_TAB - Enters 4 space characters (Sorry tab people) KEY_DELETE - Deletes next character KEY_ENTER - Inserts newline character","title":"Text Block"},{"location":"writing/","text":"Writing a py_cui, step by step On this page, we will create a simple py_cui program, step by step. We will create something similar to the todo list example that can be seen in the examples directory in the repository. Step 1 - Create PyCUI and wrapper class The recommended way to create py_cui programs is to create a wrapper class that takes the PyCUI object as an argument, similar to how Tk objects are often passed as an argument to a wrapper class. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Step 2 - Add your widgets Next, we want to add widgets to the CUI. We will add 3 scroll menus to represent our lists of TODO, In Progress, and Done, a text field for adding new items for now. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note how we set the row_span and column_span values, so that even though the grid is 7x6, our widgets will actually be larger than that size. The reason we define these sizes is becaue we wish to have the text field fill a narrow row, meaning that we must subdivide the window into many rows. Step 3 - Add key commands Next, add keybindings to your widgets. We want buttons that send items into the next list, and the items get removed if theyre in the \"Done\" list. Also, we need to make the text field send its contents into the \"TODO\" list. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note that in the mark_as_in_progress and mark_as_done functions spawn an error popup if the lists are empty. Step 4 - You're done! That's it! our simple example is complete, and you can test it with: python3 simple_todo.py You should see something similar to this: Feel free to play around with this CUI, and note how the keybindings we assigned perform the tasks we wanted them to.","title":"Writing a PyCUI step-by-step"},{"location":"writing/#writing-a-py_cui-step-by-step","text":"On this page, we will create a simple py_cui program, step by step. We will create something similar to the todo list example that can be seen in the examples directory in the repository. Step 1 - Create PyCUI and wrapper class The recommended way to create py_cui programs is to create a wrapper class that takes the PyCUI object as an argument, similar to how Tk objects are often passed as an argument to a wrapper class. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Step 2 - Add your widgets Next, we want to add widgets to the CUI. We will add 3 scroll menus to represent our lists of TODO, In Progress, and Done, a text field for adding new items for now. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note how we set the row_span and column_span values, so that even though the grid is 7x6, our widgets will actually be larger than that size. The reason we define these sizes is becaue we wish to have the text field fill a narrow row, meaning that we must subdivide the window into many rows. Step 3 - Add key commands Next, add keybindings to your widgets. We want buttons that send items into the next list, and the items get removed if theyre in the \"Done\" list. Also, we need to make the text field send its contents into the \"TODO\" list. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note that in the mark_as_in_progress and mark_as_done functions spawn an error popup if the lists are empty. Step 4 - You're done! That's it! our simple example is complete, and you can test it with: python3 simple_todo.py You should see something similar to this: Feel free to play around with this CUI, and note how the keybindings we assigned perform the tasks we wanted them to.","title":"Writing a py_cui, step by step"},{"location":"DocstringGenerated/Colors/","text":"File containing color rule class and any color-rendering related function @author:Jakub Wlodek @created: 12-Aug-2019 ColorRule class ColorRule Class representing a text color rendering rul. Attributes Type Doc regex str A python 're' module string color int A valid color value. Ex. py_cui.WHITE_ON_BLACK rule_type str String representing rule type. ['startswith', 'endswith', 'notstartswith', 'notendswith', 'contains'] match_type str String representing the match type. ['line', 'regex', 'region'] region [int, int] Start and end positions for the coloring, None if match_type != 'region' include_whitespace bool Flag to determine whether to strip whitespace before matching. Methods method Doc check_match Checks if the color rule matches a lin. generate_fragments_regex Splits text into fragments based on regular expressio. split_text_on_region Splits text into fragments based on regio. generate_fragments Splits text into fragments if matched line to rege. check_match check_match(line) Checks if the color rule matches a lin. Parameters Type Doc line str The input line of text to try to match the rule against Returns Type Doc matched bool True if a match was found, false otherwise generate_fragments_regex generate_fragments_regex(widget, render_text) Splits text into fragments based on regular expressio. Parameters Type Doc widget py_cui.Widget Widget containing the render text render_text str text being rendered Returns Type Doc fragments list of lists of [str, color] the render text split into fragments of strings paired with colors split_text_on_region split_text_on_region(widget, render_text) Splits text into fragments based on regio. Parameters Type Doc widget py_cui.Widget Widget containing the render text render_text str text being rendered Returns Type Doc fragments list of lists of [str, color] the render text split into fragments of strings paired with colors generate_fragments generate_fragments(widget, line, render_text) Splits text into fragments if matched line to rege. Parameters Type Doc widget py_cui.Widget Widget containing the render text line str the line to match render_text str text being rendered Returns Type Doc fragments list of lists of [str, color] the render text split into fragments of strings paired with colors matched bool Boolean output saying if a match was found in the line.","title":"Colors"},{"location":"DocstringGenerated/Colors/#file-containing-color-rule-class-and-any-color-rendering-related-function","text":"@author:Jakub Wlodek @created: 12-Aug-2019","title":"File containing color rule class and any color-rendering related function"},{"location":"DocstringGenerated/Colors/#colorrule","text":"class ColorRule Class representing a text color rendering rul. Attributes Type Doc regex str A python 're' module string color int A valid color value. Ex. py_cui.WHITE_ON_BLACK rule_type str String representing rule type. ['startswith', 'endswith', 'notstartswith', 'notendswith', 'contains'] match_type str String representing the match type. ['line', 'regex', 'region'] region [int, int] Start and end positions for the coloring, None if match_type != 'region' include_whitespace bool Flag to determine whether to strip whitespace before matching.","title":"ColorRule"},{"location":"DocstringGenerated/Colors/#methods","text":"method Doc check_match Checks if the color rule matches a lin. generate_fragments_regex Splits text into fragments based on regular expressio. split_text_on_region Splits text into fragments based on regio. generate_fragments Splits text into fragments if matched line to rege.","title":"Methods"},{"location":"DocstringGenerated/Colors/#check_match","text":"check_match(line) Checks if the color rule matches a lin. Parameters Type Doc line str The input line of text to try to match the rule against Returns Type Doc matched bool True if a match was found, false otherwise","title":"check_match"},{"location":"DocstringGenerated/Colors/#generate_fragments_regex","text":"generate_fragments_regex(widget, render_text) Splits text into fragments based on regular expressio. Parameters Type Doc widget py_cui.Widget Widget containing the render text render_text str text being rendered Returns Type Doc fragments list of lists of [str, color] the render text split into fragments of strings paired with colors","title":"generate_fragments_regex"},{"location":"DocstringGenerated/Colors/#split_text_on_region","text":"split_text_on_region(widget, render_text) Splits text into fragments based on regio. Parameters Type Doc widget py_cui.Widget Widget containing the render text render_text str text being rendered Returns Type Doc fragments list of lists of [str, color] the render text split into fragments of strings paired with colors","title":"split_text_on_region"},{"location":"DocstringGenerated/Colors/#generate_fragments","text":"generate_fragments(widget, line, render_text) Splits text into fragments if matched line to rege. Parameters Type Doc widget py_cui.Widget Widget containing the render text line str the line to match render_text str text being rendered Returns Type Doc fragments list of lists of [str, color] the render text split into fragments of strings paired with colors matched bool Boolean output saying if a match was found in the line.","title":"generate_fragments"},{"location":"DocstringGenerated/Grid/","text":"File containing the Grid Class. The grid is currently the only supported layout manager for py_cui @author:Jakub Wlodek @created: 12-Aug-2019 Grid class Grid Class representing the CUI gri. Attributes Type Doc num_rows int Number of grid rows num_columns int Number of grid columns height int The height in characters of the terminal window width int The width in characters of the terminal window offset_y int The number of additional characters found by height mod rows offset_x int The number of additional characters found by width mod columns row_height int The number of characters in a single grid row column_width int The number of characters in a single grid column Methods method Doc set_num_rows Sets the grid row siz. set_num_cols Sets the grid column siz. update_grid_height_width Update grid height and width. Allows for on-the-fly size editin. set_num_rows set_num_rows(num_rows) Sets the grid row siz. Parameters Type Doc num_rows int New number of grid rows set_num_cols set_num_cols(num_columns) Sets the grid column siz. Parameters Type Doc num_columns int New number of grid columns update_grid_height_width update_grid_height_width(height, width) Update grid height and width. Allows for on-the-fly size editin. Parameters Type Doc height int The height in characters of the terminal window width int The width in characters of the terminal window","title":"Grid"},{"location":"DocstringGenerated/Grid/#file-containing-the-grid-class","text":"The grid is currently the only supported layout manager for py_cui @author:Jakub Wlodek @created: 12-Aug-2019","title":"File containing the Grid Class."},{"location":"DocstringGenerated/Grid/#grid","text":"class Grid Class representing the CUI gri. Attributes Type Doc num_rows int Number of grid rows num_columns int Number of grid columns height int The height in characters of the terminal window width int The width in characters of the terminal window offset_y int The number of additional characters found by height mod rows offset_x int The number of additional characters found by width mod columns row_height int The number of characters in a single grid row column_width int The number of characters in a single grid column","title":"Grid"},{"location":"DocstringGenerated/Grid/#methods","text":"method Doc set_num_rows Sets the grid row siz. set_num_cols Sets the grid column siz. update_grid_height_width Update grid height and width. Allows for on-the-fly size editin.","title":"Methods"},{"location":"DocstringGenerated/Grid/#set_num_rows","text":"set_num_rows(num_rows) Sets the grid row siz. Parameters Type Doc num_rows int New number of grid rows","title":"set_num_rows"},{"location":"DocstringGenerated/Grid/#set_num_cols","text":"set_num_cols(num_columns) Sets the grid column siz. Parameters Type Doc num_columns int New number of grid columns","title":"set_num_cols"},{"location":"DocstringGenerated/Grid/#update_grid_height_width","text":"update_grid_height_width(height, width) Update grid height and width. Allows for on-the-fly size editin. Parameters Type Doc height int The height in characters of the terminal window width int The width in characters of the terminal window","title":"update_grid_height_width"},{"location":"DocstringGenerated/Keys/","text":"Module containing constants and helper functions for dealing with keys @author:Jakub Wlodek @created: 12-Aug-2019","title":"Keys"},{"location":"DocstringGenerated/Keys/#module-containing-constants-and-helper-functions-for-dealing-with-keys","text":"@author:Jakub Wlodek @created: 12-Aug-2019","title":"Module containing constants and helper functions for dealing with keys"},{"location":"DocstringGenerated/Popups/","text":"File containing classes for all popups used by py_cu @author:Jakub Wlodek @created: 12-Aug-2019 Popup class Popup Base CUI popup class.. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame Attributes Type Doc root py_cui.PyCUI Root CUI window title str Popup title text str Popup message text color int PyCUI color value renderer py_cui.renderer.Renderer Renderer for drawing the popup start_x, start_y int top left corner of the popup stop_x, stop_y int bottom right corner of the popup height, width int The dimensions of the popup padx, pady int The padding on either side of the popup selected bool Always true. Used by the renderer to highlight popup Methods method Doc handle_key_press Handles key presses when popup is ope. draw Function that uses renderer to draw the popu. handle_key_press handle_key_press(key_pressed) Handles key presses when popup is ope. Must be implemented by subclass Parameters Type Doc key_pressed int The ascii code for the key that was pressed draw draw() Function that uses renderer to draw the popu. Can be implemented by subclass. Base draw function will draw the title and text in a bordered box MessagePopup class MessagePopup(Popup) Class representing a simple message popu. Attributes Type Doc close_keys list of int list of key codes that can be used to close the popup Methods method Doc handle_key_press Implementation of handle_key_pressed. draw Draw function for MessagePopup. Calls superclass draw(. handle_key_press handle_key_press(key_pressed) Implementation of handle_key_pressed. Closes popup if Enter, Space, or Escape is pressed. Parameters Type Doc key_pressed int key code of key pressed draw draw() Draw function for MessagePopup. Calls superclass draw(. YesNoPopup class YesNoPopup(Popup) Class for Yes/No popup. Extends Popu. Attributes Type Doc command function, 1 boolean parameter Function that takes one boolean parameter. Called with True if yes, called with False if no. Methods method Doc handle_key_press Handle key press overwrite from superclas. draw Uses base class draw functio. handle_key_press handle_key_press(key_pressed) Handle key press overwrite from superclas. Parameters Type Doc key_pressed int key code of key pressed draw draw() Uses base class draw functio. TextBoxPopup class TextBoxPopup(Popup) Class representing a textbox popu. Attributes Type Doc text str The text in the text box command function The command to run when enter is pressed cursor_x, cursor_y int The absolute positions of the cursor in the terminal window cursor_text_pos int the cursor position relative to the text cursor_max_left, cursor_max_right int The cursor bounds of the text box viewport_width int The width of the textbox viewport password bool If set, replace all characters with * Methods method Doc get Gets value of the text in the textbo. clear Clears the text in the textbo. move_left Shifts the cursor the the left. Internal use onl. move_right Shifts the cursor the the right. Internal use onl. insert_char Inserts char at cursor position. Internal use onl. jump_to_start Jumps to the start of the textbo. jump_to_end Jumps to the end to the textbo. erase_char Erases character at textbox curso. handle_key_press Override of base handle key press functio. draw Override of base draw functio. get get() Gets value of the text in the textbo. Returns Type Doc text str The current textbox test clear clear() Clears the text in the textbo. move_left move_left() Shifts the cursor the the left. Internal use onl. move_right move_right() Shifts the cursor the the right. Internal use onl. insert_char insert_char(key_pressed) Inserts char at cursor position. Internal use onl. Parameters Type Doc key_pressed int key code of key pressed jump_to_start jump_to_start() Jumps to the start of the textbo. jump_to_end jump_to_end() Jumps to the end to the textbo. erase_char erase_char() Erases character at textbox curso. handle_key_press handle_key_press(key_pressed) Override of base handle key press functio. Parameters Type Doc key_pressed int key code of key pressed draw draw() Override of base draw functio. MenuPopup class MenuPopup(Popup) A scroll menu popup. Allows for popup with several menu items to select from Attributes Type Doc top_view int the uppermost menu element in view selected_item int the currently highlighted menu item view_items list of str list of menu items command function a function that takes a single string parameter, run when ENTER pressed run_command_if_none bool Runs command even if there are no menu items (passes None) Methods method Doc scroll_up Function that scrolls the view up in the scroll men. scroll_down Function that scrolls the view down in the scroll men. get Function that gets the selected item from the scroll men. handle_key_press Override of base handle key press functio. draw Overrides base class draw functio. scroll_up scroll_up() Function that scrolls the view up in the scroll men. scroll_down scroll_down() Function that scrolls the view down in the scroll men. get get() Function that gets the selected item from the scroll men. Returns Type Doc item str selected item, or None if there are no items in the menu handle_key_press handle_key_press(key_pressed) Override of base handle key press functio. Enter key runs command, Escape key closes menu Parameters Type Doc key_pressed int key code of key pressed draw draw() Overrides base class draw functio. LoadingIconPopup class LoadingIconPopup(Popup) Loading icon popup clas. MUST BE USED WITH A FORM OF ASYNC/THREADING Attributes Type Doc loading_icons list of str Animation frames for loading icon icon_counter int Current frame of animation message str Loading message Methods method Doc draw Overrides base draw functio. draw draw() Overrides base draw functio. LoadingBarPopup class LoadingBarPopup(Popup) Class for Loading Bar Popu. MUST BE USED WITH A FORM OF ASYNC/THREADING Attributes Type Doc num_items int NUmber of items to count through completed_items int counter for completed items Methods method Doc draw Override of base draw functio. draw draw() Override of base draw functio.","title":"Popups"},{"location":"DocstringGenerated/Popups/#file-containing-classes-for-all-popups-used-by-py_cu","text":"@author:Jakub Wlodek @created: 12-Aug-2019","title":"File containing classes for all popups used by py_cu"},{"location":"DocstringGenerated/Popups/#popup","text":"class Popup Base CUI popup class.. Contains constructor and initial definitions for key_press and draw Unlike widgets, they do not have a set grid cell, they are simply centered in the view frame Attributes Type Doc root py_cui.PyCUI Root CUI window title str Popup title text str Popup message text color int PyCUI color value renderer py_cui.renderer.Renderer Renderer for drawing the popup start_x, start_y int top left corner of the popup stop_x, stop_y int bottom right corner of the popup height, width int The dimensions of the popup padx, pady int The padding on either side of the popup selected bool Always true. Used by the renderer to highlight popup","title":"Popup"},{"location":"DocstringGenerated/Popups/#methods","text":"method Doc handle_key_press Handles key presses when popup is ope. draw Function that uses renderer to draw the popu.","title":"Methods"},{"location":"DocstringGenerated/Popups/#handle_key_press","text":"handle_key_press(key_pressed) Handles key presses when popup is ope. Must be implemented by subclass Parameters Type Doc key_pressed int The ascii code for the key that was pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Popups/#draw","text":"draw() Function that uses renderer to draw the popu. Can be implemented by subclass. Base draw function will draw the title and text in a bordered box","title":"draw"},{"location":"DocstringGenerated/Popups/#messagepopup","text":"class MessagePopup(Popup) Class representing a simple message popu. Attributes Type Doc close_keys list of int list of key codes that can be used to close the popup","title":"MessagePopup"},{"location":"DocstringGenerated/Popups/#methods_1","text":"method Doc handle_key_press Implementation of handle_key_pressed. draw Draw function for MessagePopup. Calls superclass draw(.","title":"Methods"},{"location":"DocstringGenerated/Popups/#handle_key_press_1","text":"handle_key_press(key_pressed) Implementation of handle_key_pressed. Closes popup if Enter, Space, or Escape is pressed. Parameters Type Doc key_pressed int key code of key pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Popups/#draw_1","text":"draw() Draw function for MessagePopup. Calls superclass draw(.","title":"draw"},{"location":"DocstringGenerated/Popups/#yesnopopup","text":"class YesNoPopup(Popup) Class for Yes/No popup. Extends Popu. Attributes Type Doc command function, 1 boolean parameter Function that takes one boolean parameter. Called with True if yes, called with False if no.","title":"YesNoPopup"},{"location":"DocstringGenerated/Popups/#methods_2","text":"method Doc handle_key_press Handle key press overwrite from superclas. draw Uses base class draw functio.","title":"Methods"},{"location":"DocstringGenerated/Popups/#handle_key_press_2","text":"handle_key_press(key_pressed) Handle key press overwrite from superclas. Parameters Type Doc key_pressed int key code of key pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Popups/#draw_2","text":"draw() Uses base class draw functio.","title":"draw"},{"location":"DocstringGenerated/Popups/#textboxpopup","text":"class TextBoxPopup(Popup) Class representing a textbox popu. Attributes Type Doc text str The text in the text box command function The command to run when enter is pressed cursor_x, cursor_y int The absolute positions of the cursor in the terminal window cursor_text_pos int the cursor position relative to the text cursor_max_left, cursor_max_right int The cursor bounds of the text box viewport_width int The width of the textbox viewport password bool If set, replace all characters with *","title":"TextBoxPopup"},{"location":"DocstringGenerated/Popups/#methods_3","text":"method Doc get Gets value of the text in the textbo. clear Clears the text in the textbo. move_left Shifts the cursor the the left. Internal use onl. move_right Shifts the cursor the the right. Internal use onl. insert_char Inserts char at cursor position. Internal use onl. jump_to_start Jumps to the start of the textbo. jump_to_end Jumps to the end to the textbo. erase_char Erases character at textbox curso. handle_key_press Override of base handle key press functio. draw Override of base draw functio.","title":"Methods"},{"location":"DocstringGenerated/Popups/#get","text":"get() Gets value of the text in the textbo. Returns Type Doc text str The current textbox test","title":"get"},{"location":"DocstringGenerated/Popups/#clear","text":"clear() Clears the text in the textbo.","title":"clear"},{"location":"DocstringGenerated/Popups/#move_left","text":"move_left() Shifts the cursor the the left. Internal use onl.","title":"move_left"},{"location":"DocstringGenerated/Popups/#move_right","text":"move_right() Shifts the cursor the the right. Internal use onl.","title":"move_right"},{"location":"DocstringGenerated/Popups/#insert_char","text":"insert_char(key_pressed) Inserts char at cursor position. Internal use onl. Parameters Type Doc key_pressed int key code of key pressed","title":"insert_char"},{"location":"DocstringGenerated/Popups/#jump_to_start","text":"jump_to_start() Jumps to the start of the textbo.","title":"jump_to_start"},{"location":"DocstringGenerated/Popups/#jump_to_end","text":"jump_to_end() Jumps to the end to the textbo.","title":"jump_to_end"},{"location":"DocstringGenerated/Popups/#erase_char","text":"erase_char() Erases character at textbox curso.","title":"erase_char"},{"location":"DocstringGenerated/Popups/#handle_key_press_3","text":"handle_key_press(key_pressed) Override of base handle key press functio. Parameters Type Doc key_pressed int key code of key pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Popups/#draw_3","text":"draw() Override of base draw functio.","title":"draw"},{"location":"DocstringGenerated/Popups/#menupopup","text":"class MenuPopup(Popup) A scroll menu popup. Allows for popup with several menu items to select from Attributes Type Doc top_view int the uppermost menu element in view selected_item int the currently highlighted menu item view_items list of str list of menu items command function a function that takes a single string parameter, run when ENTER pressed run_command_if_none bool Runs command even if there are no menu items (passes None)","title":"MenuPopup"},{"location":"DocstringGenerated/Popups/#methods_4","text":"method Doc scroll_up Function that scrolls the view up in the scroll men. scroll_down Function that scrolls the view down in the scroll men. get Function that gets the selected item from the scroll men. handle_key_press Override of base handle key press functio. draw Overrides base class draw functio.","title":"Methods"},{"location":"DocstringGenerated/Popups/#scroll_up","text":"scroll_up() Function that scrolls the view up in the scroll men.","title":"scroll_up"},{"location":"DocstringGenerated/Popups/#scroll_down","text":"scroll_down() Function that scrolls the view down in the scroll men.","title":"scroll_down"},{"location":"DocstringGenerated/Popups/#get_1","text":"get() Function that gets the selected item from the scroll men. Returns Type Doc item str selected item, or None if there are no items in the menu","title":"get"},{"location":"DocstringGenerated/Popups/#handle_key_press_4","text":"handle_key_press(key_pressed) Override of base handle key press functio. Enter key runs command, Escape key closes menu Parameters Type Doc key_pressed int key code of key pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Popups/#draw_4","text":"draw() Overrides base class draw functio.","title":"draw"},{"location":"DocstringGenerated/Popups/#loadingiconpopup","text":"class LoadingIconPopup(Popup) Loading icon popup clas. MUST BE USED WITH A FORM OF ASYNC/THREADING Attributes Type Doc loading_icons list of str Animation frames for loading icon icon_counter int Current frame of animation message str Loading message","title":"LoadingIconPopup"},{"location":"DocstringGenerated/Popups/#methods_5","text":"method Doc draw Overrides base draw functio.","title":"Methods"},{"location":"DocstringGenerated/Popups/#draw_5","text":"draw() Overrides base draw functio.","title":"draw"},{"location":"DocstringGenerated/Popups/#loadingbarpopup","text":"class LoadingBarPopup(Popup) Class for Loading Bar Popu. MUST BE USED WITH A FORM OF ASYNC/THREADING Attributes Type Doc num_items int NUmber of items to count through completed_items int counter for completed items","title":"LoadingBarPopup"},{"location":"DocstringGenerated/Popups/#methods_6","text":"method Doc draw Override of base draw functio.","title":"Methods"},{"location":"DocstringGenerated/Popups/#draw_6","text":"draw() Override of base draw functio.","title":"draw"},{"location":"DocstringGenerated/PyCUI/","text":"A python library for creating command line based user interfaces @author:Jakub Wlodek @created: 12-Aug-2019 PyCUI class PyCUI Base CUI clas. Main user interface class for py_cui. To create a user interface, you must first create an instance of this class, and then add cells + widgets to it. Attributes Type Doc cursor_x, cursor_y int absolute position of the cursor in the CUI grid py_cui.grid.Grid The main layout manager for the CUI widgets dict of str - py_cui.widgets.Widget dict of widget in the grid title_bar py_cui.statusbar.StatusBar a status bar object that gets drawn at the top of the CUI status_bar py_cui.statusbar.StatusBar a status bar object that gets drawn at the bottom of the CUI keybindings list of py_cui.keybinding.KeyBinding list of keybindings to check against in the main CUI loop height, width int height of the terminal in characters, width of terminal in characters exit_key key_code a key code for a key that exits the CUI Methods method Doc get_widget_set Gets widget set object from current widgets. apply_widget_set Function that replaces all widgets in a py_cui with those of a different widget se. start Function that starts the CU. stop Function that stops the CUI, and fires the callback function.. run_on_exit Sets callback function on CUI exit. Must be a no-argument function or lambda functio. set_title Sets the title bar tex. set_status_bar_text Sets the status bar text when in overview mod. initialize_colors Function for initialzing curses colors. Called when CUI is first created. initialize_widget_renderer Function that creates the renderer object that will draw each widge. add_scroll_menu Function that adds a new scroll menu to the CUI gri. add_checkbox_menu Function that adds a new checkbox menu to the CUI gri. add_text_box Function that adds a new text box to the CUI gri. add_text_block Function that adds a new text block to the CUI gri. add_label Function that adds a new label to the CUI gri. add_block_label Function that adds a new block label to the CUI gri. add_button Function that adds a new button to the CUI gri. check_if_neighbor_exists Function that checks if widget has neighbor in specified cell.. set_selected_widget Function that sets the selected cell for the CU. get_widget_id Function for grabbing widget I. lose_focus Function that forces py_cui out of focus mode. move_focus Moves focus mode to different widge. add_key_command Function that adds a keybinding to the CUI when in overview mod. show_message_popup Shows a message popu. show_warning_popup Shows a warning popu. show_error_popup Shows an error popu. show_yes_no_popup Shows a yes/no popup. show_text_box_popup Shows a textbox popup. show_menu_popup Shows a menu popup. show_loading_icon_popup Shows a loading icon popu. show_loading_bar_popup Shows loading bar popup. increment_loading_bar Increments progress bar if loading bar popup is ope. stop_loading_popup Leaves loading state, and closes popup. close_popup Closes the popup, and resets focu. refresh_height_width Function that updates the height and width of the CUI based on terminal window siz. draw_widgets Function that draws all of the widgets to the scree. draw_status_bars Draws status bar and title ba. display_window_warning Function that prints some basic error info if there is an error with the CU. handle_key_presses Function that handles all main loop key presses. draw Main CUI draw loop called by start(. format Override of base format function. Prints list of current widgets. get_widget_set get_widget_set() Gets widget set object from current widgets. Returns Type Doc new_widget_set py_cui.widget_set.WidgetSet Widget set collected from widgets currently added to the py_cui apply_widget_set apply_widget_set(new_widget_set) Function that replaces all widgets in a py_cui with those of a different widget se. Parameters Type Doc new_widget_set WidgetSet The new widget set to switch to start start() Function that starts the CU. stop stop() Function that stops the CUI, and fires the callback function.. Callback must be a no arg method run_on_exit run_on_exit(command) Sets callback function on CUI exit. Must be a no-argument function or lambda functio. Parameters Type Doc command function A no-argument or lambda function to be fired on exit set_title set_title(title) Sets the title bar tex. Parameters Type Doc title str New title for CUI set_status_bar_text set_status_bar_text(text) Sets the status bar text when in overview mod. Parameters Type Doc text str Status bar text initialize_colors initialize_colors() Function for initialzing curses colors. Called when CUI is first created. initialize_widget_renderer initialize_widget_renderer() Function that creates the renderer object that will draw each widge. add_scroll_menu add_scroll_menu(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Function that adds a new scroll menu to the CUI gri. Parameters Type Doc title str The title of the scroll menu row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction Returns Type Doc new_scroll_menu ScrollMenu A reference to the created scroll menu object. add_checkbox_menu add_checkbox_menu(title, row, column, row_span=1, column_span=1, padx=1, pady=0, checked_char='X') Function that adds a new checkbox menu to the CUI gri. Parameters Type Doc title str The title of the checkbox row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction checked_char='X' char The character used to mark 'Checked' items Returns Type Doc new_checkbox_menu CheckBoxMenu A reference to the created checkbox object. add_text_box add_text_box(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Function that adds a new text box to the CUI gri. Parameters Type Doc title str The title of the textbox row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction initial_text='' str Initial text for the textbox Returns Type Doc new_text_box TextBox A reference to the created textbox object. add_text_block add_text_block(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Function that adds a new text block to the CUI gri. Parameters Type Doc title str The title of the text block row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction initial_text='' str Initial text for the text block Returns Type Doc new_text_block ScrollTextBlock A reference to the created textblock object. add_label add_label(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Function that adds a new label to the CUI gri. Parameters Type Doc title str The title of the label row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction Returns Type Doc new_label Label A reference to the created label object. add_block_label add_block_label(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, center=True) Function that adds a new block label to the CUI gri. Parameters Type Doc title str The title of the block label row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction center bool flag to tell label to be centered or left-aligned. Returns Type Doc new_label BlockLabel A reference to the created block label object. add_button add_button(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Function that adds a new button to the CUI gri. Parameters Type Doc title str The title of the button row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction command=None Function A no-argument or lambda function to fire on button press. Returns Type Doc new_button Button A reference to the created button object. check_if_neighbor_exists check_if_neighbor_exists(row, column, row_span, col_span, direction) Function that checks if widget has neighbor in specified cell.. Used for navigating CUI, as arrow keys find the immediate neighbor Parameters Type Doc row int row of current widget column int column of current widget row_span int row span of current widget col_span int column span of current widget direction py_cui.keys.KEY_* The direction in which to search Returns Type Doc widget_id str The widget neighbor ID if found, None otherwise set_selected_widget set_selected_widget(widget_id) Function that sets the selected cell for the CU. Parameters Type Doc widget_id str the id of the widget get_widget_id get_widget_id(widget) Function for grabbing widget I. Parameters Type Doc widget Widget The widget object we wish to get an ID from Returns Type Doc widget_id str The id if found, None otherwise lose_focus lose_focus() Function that forces py_cui out of focus mode. After popup is called, focus is lost move_focus move_focus(widget) Moves focus mode to different widge. Parameters Type Doc widget Widget The widget object we want to move focus to. add_key_command add_key_command(key, command) Function that adds a keybinding to the CUI when in overview mod. Parameters Type Doc key py_cui.keys.KEY_* The key bound to the command command Function A no-arg or lambda function to fire on keypress show_message_popup show_message_popup(title, text) Shows a message popu. Parameters Type Doc title str Message title text str Message text show_warning_popup show_warning_popup(title, text) Shows a warning popu. Parameters Type Doc title str Warning title text str Warning text show_error_popup show_error_popup(title, text) Shows an error popu. Parameters Type Doc title str Error title text str Error text show_yes_no_popup show_yes_no_popup(title, command) Shows a yes/no popup. The 'command' parameter must be a function with a single boolean parameter Parameters Type Doc title str Message title command function A function taking in a single boolean parameter. Will be fired with True if yes selected, false otherwise show_text_box_popup show_text_box_popup(title, command, password=False) Shows a textbox popup. The 'command' parameter must be a function with a single string parameter Parameters Type Doc title str Message title command Function A function with a single string parameter, fired with contents of textbox when enter key pressed password=False bool If true, write characters as '*' show_menu_popup show_menu_popup(title, menu_items, command, run_command_if_none=False) Shows a menu popup. The 'command' parameter must be a function with a single string parameter Parameters Type Doc title str menu title menu_items list of str A list of menu items command Function A function taking in a single string argument. Fired with selected menu item when ENTER pressed. run_command_if_none=False bool If True, will run command passing in None if no menu item selected. show_loading_icon_popup show_loading_icon_popup(title, message, callback=None) Shows a loading icon popu. Parameters Type Doc title str Message title message str Message text. Will show as '$message...' callback=None Function If not none, fired after loading is completed. Must be a no-arg function show_loading_bar_popup show_loading_bar_popup(title, num_items, callback=None) Shows loading bar popup. Use 'increment_loading_bar' to show progress Parameters Type Doc title str Message title num_items int Number of items to iterate through for loading callback=None Function If not none, fired after loading is completed. Must be a no-arg function increment_loading_bar increment_loading_bar() Increments progress bar if loading bar popup is ope. stop_loading_popup stop_loading_popup() Leaves loading state, and closes popup. Must be called by user to escape loading. close_popup close_popup() Closes the popup, and resets focu. refresh_height_width refresh_height_width(height, width) Function that updates the height and width of the CUI based on terminal window siz. Parameters Type Doc height int Window height in terminal characters width int Window width in terminal characters draw_widgets draw_widgets() Function that draws all of the widgets to the scree. draw_status_bars draw_status_bars(stdscr, height, width) Draws status bar and title ba. Parameters Type Doc stdscr curses Standard cursor The cursor used to draw the status bar height int Window height in terminal characters width int Window width in terminal characters display_window_warning display_window_warning(stdscr, error_info) Function that prints some basic error info if there is an error with the CU. Parameters Type Doc stdscr curses Standard cursor The cursor used to draw the warning error_info str The information regarding the error. handle_key_presses handle_key_presses(key_pressed) Function that handles all main loop key presses. Parameters Type Doc key_pressed py_cui.keys.KEY_* The key being pressed draw draw(stdscr) Main CUI draw loop called by start(. Parameters Type Doc stdscr curses Standard cursor The cursor used to draw the CUI format __format__(fmt) Override of base format function. Prints list of current widgets. Parameters Type Doc fmt Format The format to override","title":"PyCUI"},{"location":"DocstringGenerated/PyCUI/#a-python-library-for-creating-command-line-based-user-interfaces","text":"@author:Jakub Wlodek @created: 12-Aug-2019","title":"A python library for creating command line based user interfaces"},{"location":"DocstringGenerated/PyCUI/#pycui","text":"class PyCUI Base CUI clas. Main user interface class for py_cui. To create a user interface, you must first create an instance of this class, and then add cells + widgets to it. Attributes Type Doc cursor_x, cursor_y int absolute position of the cursor in the CUI grid py_cui.grid.Grid The main layout manager for the CUI widgets dict of str - py_cui.widgets.Widget dict of widget in the grid title_bar py_cui.statusbar.StatusBar a status bar object that gets drawn at the top of the CUI status_bar py_cui.statusbar.StatusBar a status bar object that gets drawn at the bottom of the CUI keybindings list of py_cui.keybinding.KeyBinding list of keybindings to check against in the main CUI loop height, width int height of the terminal in characters, width of terminal in characters exit_key key_code a key code for a key that exits the CUI","title":"PyCUI"},{"location":"DocstringGenerated/PyCUI/#methods","text":"method Doc get_widget_set Gets widget set object from current widgets. apply_widget_set Function that replaces all widgets in a py_cui with those of a different widget se. start Function that starts the CU. stop Function that stops the CUI, and fires the callback function.. run_on_exit Sets callback function on CUI exit. Must be a no-argument function or lambda functio. set_title Sets the title bar tex. set_status_bar_text Sets the status bar text when in overview mod. initialize_colors Function for initialzing curses colors. Called when CUI is first created. initialize_widget_renderer Function that creates the renderer object that will draw each widge. add_scroll_menu Function that adds a new scroll menu to the CUI gri. add_checkbox_menu Function that adds a new checkbox menu to the CUI gri. add_text_box Function that adds a new text box to the CUI gri. add_text_block Function that adds a new text block to the CUI gri. add_label Function that adds a new label to the CUI gri. add_block_label Function that adds a new block label to the CUI gri. add_button Function that adds a new button to the CUI gri. check_if_neighbor_exists Function that checks if widget has neighbor in specified cell.. set_selected_widget Function that sets the selected cell for the CU. get_widget_id Function for grabbing widget I. lose_focus Function that forces py_cui out of focus mode. move_focus Moves focus mode to different widge. add_key_command Function that adds a keybinding to the CUI when in overview mod. show_message_popup Shows a message popu. show_warning_popup Shows a warning popu. show_error_popup Shows an error popu. show_yes_no_popup Shows a yes/no popup. show_text_box_popup Shows a textbox popup. show_menu_popup Shows a menu popup. show_loading_icon_popup Shows a loading icon popu. show_loading_bar_popup Shows loading bar popup. increment_loading_bar Increments progress bar if loading bar popup is ope. stop_loading_popup Leaves loading state, and closes popup. close_popup Closes the popup, and resets focu. refresh_height_width Function that updates the height and width of the CUI based on terminal window siz. draw_widgets Function that draws all of the widgets to the scree. draw_status_bars Draws status bar and title ba. display_window_warning Function that prints some basic error info if there is an error with the CU. handle_key_presses Function that handles all main loop key presses. draw Main CUI draw loop called by start(. format Override of base format function. Prints list of current widgets.","title":"Methods"},{"location":"DocstringGenerated/PyCUI/#get_widget_set","text":"get_widget_set() Gets widget set object from current widgets. Returns Type Doc new_widget_set py_cui.widget_set.WidgetSet Widget set collected from widgets currently added to the py_cui","title":"get_widget_set"},{"location":"DocstringGenerated/PyCUI/#apply_widget_set","text":"apply_widget_set(new_widget_set) Function that replaces all widgets in a py_cui with those of a different widget se. Parameters Type Doc new_widget_set WidgetSet The new widget set to switch to","title":"apply_widget_set"},{"location":"DocstringGenerated/PyCUI/#start","text":"start() Function that starts the CU.","title":"start"},{"location":"DocstringGenerated/PyCUI/#stop","text":"stop() Function that stops the CUI, and fires the callback function.. Callback must be a no arg method","title":"stop"},{"location":"DocstringGenerated/PyCUI/#run_on_exit","text":"run_on_exit(command) Sets callback function on CUI exit. Must be a no-argument function or lambda functio. Parameters Type Doc command function A no-argument or lambda function to be fired on exit","title":"run_on_exit"},{"location":"DocstringGenerated/PyCUI/#set_title","text":"set_title(title) Sets the title bar tex. Parameters Type Doc title str New title for CUI","title":"set_title"},{"location":"DocstringGenerated/PyCUI/#set_status_bar_text","text":"set_status_bar_text(text) Sets the status bar text when in overview mod. Parameters Type Doc text str Status bar text","title":"set_status_bar_text"},{"location":"DocstringGenerated/PyCUI/#initialize_colors","text":"initialize_colors() Function for initialzing curses colors. Called when CUI is first created.","title":"initialize_colors"},{"location":"DocstringGenerated/PyCUI/#initialize_widget_renderer","text":"initialize_widget_renderer() Function that creates the renderer object that will draw each widge.","title":"initialize_widget_renderer"},{"location":"DocstringGenerated/PyCUI/#add_scroll_menu","text":"add_scroll_menu(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Function that adds a new scroll menu to the CUI gri. Parameters Type Doc title str The title of the scroll menu row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction Returns Type Doc new_scroll_menu ScrollMenu A reference to the created scroll menu object.","title":"add_scroll_menu"},{"location":"DocstringGenerated/PyCUI/#add_checkbox_menu","text":"add_checkbox_menu(title, row, column, row_span=1, column_span=1, padx=1, pady=0, checked_char='X') Function that adds a new checkbox menu to the CUI gri. Parameters Type Doc title str The title of the checkbox row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction checked_char='X' char The character used to mark 'Checked' items Returns Type Doc new_checkbox_menu CheckBoxMenu A reference to the created checkbox object.","title":"add_checkbox_menu"},{"location":"DocstringGenerated/PyCUI/#add_text_box","text":"add_text_box(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Function that adds a new text box to the CUI gri. Parameters Type Doc title str The title of the textbox row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction initial_text='' str Initial text for the textbox Returns Type Doc new_text_box TextBox A reference to the created textbox object.","title":"add_text_box"},{"location":"DocstringGenerated/PyCUI/#add_text_block","text":"add_text_block(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Function that adds a new text block to the CUI gri. Parameters Type Doc title str The title of the text block row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction initial_text='' str Initial text for the text block Returns Type Doc new_text_block ScrollTextBlock A reference to the created textblock object.","title":"add_text_block"},{"location":"DocstringGenerated/PyCUI/#add_label","text":"add_label(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Function that adds a new label to the CUI gri. Parameters Type Doc title str The title of the label row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction Returns Type Doc new_label Label A reference to the created label object.","title":"add_label"},{"location":"DocstringGenerated/PyCUI/#add_block_label","text":"add_block_label(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, center=True) Function that adds a new block label to the CUI gri. Parameters Type Doc title str The title of the block label row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction center bool flag to tell label to be centered or left-aligned. Returns Type Doc new_label BlockLabel A reference to the created block label object.","title":"add_block_label"},{"location":"DocstringGenerated/PyCUI/#add_button","text":"add_button(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Function that adds a new button to the CUI gri. Parameters Type Doc title str The title of the button row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction command=None Function A no-argument or lambda function to fire on button press. Returns Type Doc new_button Button A reference to the created button object.","title":"add_button"},{"location":"DocstringGenerated/PyCUI/#check_if_neighbor_exists","text":"check_if_neighbor_exists(row, column, row_span, col_span, direction) Function that checks if widget has neighbor in specified cell.. Used for navigating CUI, as arrow keys find the immediate neighbor Parameters Type Doc row int row of current widget column int column of current widget row_span int row span of current widget col_span int column span of current widget direction py_cui.keys.KEY_* The direction in which to search Returns Type Doc widget_id str The widget neighbor ID if found, None otherwise","title":"check_if_neighbor_exists"},{"location":"DocstringGenerated/PyCUI/#set_selected_widget","text":"set_selected_widget(widget_id) Function that sets the selected cell for the CU. Parameters Type Doc widget_id str the id of the widget","title":"set_selected_widget"},{"location":"DocstringGenerated/PyCUI/#get_widget_id","text":"get_widget_id(widget) Function for grabbing widget I. Parameters Type Doc widget Widget The widget object we wish to get an ID from Returns Type Doc widget_id str The id if found, None otherwise","title":"get_widget_id"},{"location":"DocstringGenerated/PyCUI/#lose_focus","text":"lose_focus() Function that forces py_cui out of focus mode. After popup is called, focus is lost","title":"lose_focus"},{"location":"DocstringGenerated/PyCUI/#move_focus","text":"move_focus(widget) Moves focus mode to different widge. Parameters Type Doc widget Widget The widget object we want to move focus to.","title":"move_focus"},{"location":"DocstringGenerated/PyCUI/#add_key_command","text":"add_key_command(key, command) Function that adds a keybinding to the CUI when in overview mod. Parameters Type Doc key py_cui.keys.KEY_* The key bound to the command command Function A no-arg or lambda function to fire on keypress","title":"add_key_command"},{"location":"DocstringGenerated/PyCUI/#show_message_popup","text":"show_message_popup(title, text) Shows a message popu. Parameters Type Doc title str Message title text str Message text","title":"show_message_popup"},{"location":"DocstringGenerated/PyCUI/#show_warning_popup","text":"show_warning_popup(title, text) Shows a warning popu. Parameters Type Doc title str Warning title text str Warning text","title":"show_warning_popup"},{"location":"DocstringGenerated/PyCUI/#show_error_popup","text":"show_error_popup(title, text) Shows an error popu. Parameters Type Doc title str Error title text str Error text","title":"show_error_popup"},{"location":"DocstringGenerated/PyCUI/#show_yes_no_popup","text":"show_yes_no_popup(title, command) Shows a yes/no popup. The 'command' parameter must be a function with a single boolean parameter Parameters Type Doc title str Message title command function A function taking in a single boolean parameter. Will be fired with True if yes selected, false otherwise","title":"show_yes_no_popup"},{"location":"DocstringGenerated/PyCUI/#show_text_box_popup","text":"show_text_box_popup(title, command, password=False) Shows a textbox popup. The 'command' parameter must be a function with a single string parameter Parameters Type Doc title str Message title command Function A function with a single string parameter, fired with contents of textbox when enter key pressed password=False bool If true, write characters as '*'","title":"show_text_box_popup"},{"location":"DocstringGenerated/PyCUI/#show_menu_popup","text":"show_menu_popup(title, menu_items, command, run_command_if_none=False) Shows a menu popup. The 'command' parameter must be a function with a single string parameter Parameters Type Doc title str menu title menu_items list of str A list of menu items command Function A function taking in a single string argument. Fired with selected menu item when ENTER pressed. run_command_if_none=False bool If True, will run command passing in None if no menu item selected.","title":"show_menu_popup"},{"location":"DocstringGenerated/PyCUI/#show_loading_icon_popup","text":"show_loading_icon_popup(title, message, callback=None) Shows a loading icon popu. Parameters Type Doc title str Message title message str Message text. Will show as '$message...' callback=None Function If not none, fired after loading is completed. Must be a no-arg function","title":"show_loading_icon_popup"},{"location":"DocstringGenerated/PyCUI/#show_loading_bar_popup","text":"show_loading_bar_popup(title, num_items, callback=None) Shows loading bar popup. Use 'increment_loading_bar' to show progress Parameters Type Doc title str Message title num_items int Number of items to iterate through for loading callback=None Function If not none, fired after loading is completed. Must be a no-arg function","title":"show_loading_bar_popup"},{"location":"DocstringGenerated/PyCUI/#increment_loading_bar","text":"increment_loading_bar() Increments progress bar if loading bar popup is ope.","title":"increment_loading_bar"},{"location":"DocstringGenerated/PyCUI/#stop_loading_popup","text":"stop_loading_popup() Leaves loading state, and closes popup. Must be called by user to escape loading.","title":"stop_loading_popup"},{"location":"DocstringGenerated/PyCUI/#close_popup","text":"close_popup() Closes the popup, and resets focu.","title":"close_popup"},{"location":"DocstringGenerated/PyCUI/#refresh_height_width","text":"refresh_height_width(height, width) Function that updates the height and width of the CUI based on terminal window siz. Parameters Type Doc height int Window height in terminal characters width int Window width in terminal characters","title":"refresh_height_width"},{"location":"DocstringGenerated/PyCUI/#draw_widgets","text":"draw_widgets() Function that draws all of the widgets to the scree.","title":"draw_widgets"},{"location":"DocstringGenerated/PyCUI/#draw_status_bars","text":"draw_status_bars(stdscr, height, width) Draws status bar and title ba. Parameters Type Doc stdscr curses Standard cursor The cursor used to draw the status bar height int Window height in terminal characters width int Window width in terminal characters","title":"draw_status_bars"},{"location":"DocstringGenerated/PyCUI/#display_window_warning","text":"display_window_warning(stdscr, error_info) Function that prints some basic error info if there is an error with the CU. Parameters Type Doc stdscr curses Standard cursor The cursor used to draw the warning error_info str The information regarding the error.","title":"display_window_warning"},{"location":"DocstringGenerated/PyCUI/#handle_key_presses","text":"handle_key_presses(key_pressed) Function that handles all main loop key presses. Parameters Type Doc key_pressed py_cui.keys.KEY_* The key being pressed","title":"handle_key_presses"},{"location":"DocstringGenerated/PyCUI/#draw","text":"draw(stdscr) Main CUI draw loop called by start(. Parameters Type Doc stdscr curses Standard cursor The cursor used to draw the CUI","title":"draw"},{"location":"DocstringGenerated/PyCUI/#format","text":"__format__(fmt) Override of base format function. Prints list of current widgets. Parameters Type Doc fmt Format The format to override","title":"format"},{"location":"DocstringGenerated/Renderer/","text":"Module containing the py_cui renderer. It is used to draw all of the onscreen widgets and items. @author:Jakub Wlodek @created: 12-Aug-2019 Renderer class Renderer Main renderer class used for drawing widgets to the terminal. Has helper functions for drawing the borders, cursor, and text required for the cui. All of the functions supplied by the renderer class should only be used internally. Attributes Type Doc root py_cui.PyCUI The parent window stdscr standard cursor The cursor with which renderer draws text color_rules list of py_cui.colors.ColorRule List of currently loaded rules to apply during drawing Methods method Doc set_bold Sets bold draw mod. unset_bold Unsets bold draw mod. set_color_rules Sets current color rule. set_color_mode Sets the output color mod. unset_color_mode Unsets the output color mod. reset_cursor Positions the cursor at the bottom right of the selected widge. draw_cursor Draws the cursor at a particular locatio. draw_border Draws border around widge. draw_border_top Internal function for drawing top of borde. draw_border_bottom Internal function for drawing bottom of borde. draw_blank_row Internal function for drawing a blank ro. get_render_text Internal function that computes the scope of the text that should be draw. generate_text_color_fragments Function that applies color rules to text, dividing them if match is foun. draw_text Function that draws widget text. set_bold set_bold() Sets bold draw mod. unset_bold unset_bold() Unsets bold draw mod. set_color_rules set_color_rules(color_rules) Sets current color rule. Parameters Type Doc color_rules list of py_cui.colors.ColorRule List of currently loaded rules to apply during drawing set_color_mode set_color_mode(color_mode) Sets the output color mod. Parameters Type Doc color_mode int Color code to apply during drawing unset_color_mode unset_color_mode(color_mode) Unsets the output color mod. Parameters Type Doc color_mode int Color code to unapply during drawing reset_cursor reset_cursor(widget, fill=True) Positions the cursor at the bottom right of the selected widge. Parameters Type Doc widget py_cui.widgets.Widget widget for which to reset cursor fill bool a flag that tells the renderer if the widget is filling its grid space, or not (ex. Textbox vs textblock) draw_cursor draw_cursor(cursor_y, cursor_x) Draws the cursor at a particular locatio. Parameters Type Doc cursor_x, cursor_y int x, y coordinates where to draw the cursor draw_border draw_border(widget, fill=True, with_title=True) Draws border around widge. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn fill bool a flag that tells the renderer if the widget is filling its grid space, or not (ex. Textbox vs textblock) with_title bool flag that tells whether or not to draw widget title draw_border_top draw_border_top(widget, y, with_title) Internal function for drawing top of borde. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn y int the terminal row (top down) on which to draw the text with_title bool Flag that tells renderer if title should be superimposed into border. draw_border_bottom draw_border_bottom(widget, y) Internal function for drawing bottom of borde. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn y int the terminal row (top down) on which to draw the text draw_blank_row draw_blank_row(widget, y) Internal function for drawing a blank ro. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn y int the terminal row (top down) on which to draw the text get_render_text get_render_text(widget, line, centered, bordered, start_pos) Internal function that computes the scope of the text that should be draw. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn line str the line of text being drawn centered bool flag to set if the text should be centered bordered bool a flag to set if the text should be bordered start_pos int position to start rendering the text from. Returns Type Doc render_text str The text shortened to fit within given space generate_text_color_fragments generate_text_color_fragments(widget, line, render_text) Function that applies color rules to text, dividing them if match is foun. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn line str the line of text being drawn render_text str The text shortened to fit within given space Returns Type Doc fragments list of [int, str] list of text - color code combinations to write draw_text draw_text(widget, line, y, centered = False, bordered = True, selected = False, start_pos = 0) Function that draws widget text. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn line str the line of text being drawn y int the terminal row (top down) on which to draw the text centered bool flag to set if the text should be centered bordered bool a flag to set if the text should be bordered selected bool Flag that tells renderer if widget is selected. start_pos int position to start rendering the text from.","title":"Renderer"},{"location":"DocstringGenerated/Renderer/#renderer","text":"class Renderer Main renderer class used for drawing widgets to the terminal. Has helper functions for drawing the borders, cursor, and text required for the cui. All of the functions supplied by the renderer class should only be used internally. Attributes Type Doc root py_cui.PyCUI The parent window stdscr standard cursor The cursor with which renderer draws text color_rules list of py_cui.colors.ColorRule List of currently loaded rules to apply during drawing","title":"Renderer"},{"location":"DocstringGenerated/Renderer/#methods","text":"method Doc set_bold Sets bold draw mod. unset_bold Unsets bold draw mod. set_color_rules Sets current color rule. set_color_mode Sets the output color mod. unset_color_mode Unsets the output color mod. reset_cursor Positions the cursor at the bottom right of the selected widge. draw_cursor Draws the cursor at a particular locatio. draw_border Draws border around widge. draw_border_top Internal function for drawing top of borde. draw_border_bottom Internal function for drawing bottom of borde. draw_blank_row Internal function for drawing a blank ro. get_render_text Internal function that computes the scope of the text that should be draw. generate_text_color_fragments Function that applies color rules to text, dividing them if match is foun. draw_text Function that draws widget text.","title":"Methods"},{"location":"DocstringGenerated/Renderer/#set_bold","text":"set_bold() Sets bold draw mod.","title":"set_bold"},{"location":"DocstringGenerated/Renderer/#unset_bold","text":"unset_bold() Unsets bold draw mod.","title":"unset_bold"},{"location":"DocstringGenerated/Renderer/#set_color_rules","text":"set_color_rules(color_rules) Sets current color rule. Parameters Type Doc color_rules list of py_cui.colors.ColorRule List of currently loaded rules to apply during drawing","title":"set_color_rules"},{"location":"DocstringGenerated/Renderer/#set_color_mode","text":"set_color_mode(color_mode) Sets the output color mod. Parameters Type Doc color_mode int Color code to apply during drawing","title":"set_color_mode"},{"location":"DocstringGenerated/Renderer/#unset_color_mode","text":"unset_color_mode(color_mode) Unsets the output color mod. Parameters Type Doc color_mode int Color code to unapply during drawing","title":"unset_color_mode"},{"location":"DocstringGenerated/Renderer/#reset_cursor","text":"reset_cursor(widget, fill=True) Positions the cursor at the bottom right of the selected widge. Parameters Type Doc widget py_cui.widgets.Widget widget for which to reset cursor fill bool a flag that tells the renderer if the widget is filling its grid space, or not (ex. Textbox vs textblock)","title":"reset_cursor"},{"location":"DocstringGenerated/Renderer/#draw_cursor","text":"draw_cursor(cursor_y, cursor_x) Draws the cursor at a particular locatio. Parameters Type Doc cursor_x, cursor_y int x, y coordinates where to draw the cursor","title":"draw_cursor"},{"location":"DocstringGenerated/Renderer/#draw_border","text":"draw_border(widget, fill=True, with_title=True) Draws border around widge. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn fill bool a flag that tells the renderer if the widget is filling its grid space, or not (ex. Textbox vs textblock) with_title bool flag that tells whether or not to draw widget title","title":"draw_border"},{"location":"DocstringGenerated/Renderer/#draw_border_top","text":"draw_border_top(widget, y, with_title) Internal function for drawing top of borde. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn y int the terminal row (top down) on which to draw the text with_title bool Flag that tells renderer if title should be superimposed into border.","title":"draw_border_top"},{"location":"DocstringGenerated/Renderer/#draw_border_bottom","text":"draw_border_bottom(widget, y) Internal function for drawing bottom of borde. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn y int the terminal row (top down) on which to draw the text","title":"draw_border_bottom"},{"location":"DocstringGenerated/Renderer/#draw_blank_row","text":"draw_blank_row(widget, y) Internal function for drawing a blank ro. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn y int the terminal row (top down) on which to draw the text","title":"draw_blank_row"},{"location":"DocstringGenerated/Renderer/#get_render_text","text":"get_render_text(widget, line, centered, bordered, start_pos) Internal function that computes the scope of the text that should be draw. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn line str the line of text being drawn centered bool flag to set if the text should be centered bordered bool a flag to set if the text should be bordered start_pos int position to start rendering the text from. Returns Type Doc render_text str The text shortened to fit within given space","title":"get_render_text"},{"location":"DocstringGenerated/Renderer/#generate_text_color_fragments","text":"generate_text_color_fragments(widget, line, render_text) Function that applies color rules to text, dividing them if match is foun. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn line str the line of text being drawn render_text str The text shortened to fit within given space Returns Type Doc fragments list of [int, str] list of text - color code combinations to write","title":"generate_text_color_fragments"},{"location":"DocstringGenerated/Renderer/#draw_text","text":"draw_text(widget, line, y, centered = False, bordered = True, selected = False, start_pos = 0) Function that draws widget text. Parameters Type Doc widget py_cui.widgets.Widget The widget being drawn line str the line of text being drawn y int the terminal row (top down) on which to draw the text centered bool flag to set if the text should be centered bordered bool a flag to set if the text should be bordered selected bool Flag that tells renderer if widget is selected. start_pos int position to start rendering the text from.","title":"draw_text"},{"location":"DocstringGenerated/WidgetSet/","text":"File containing class that abstracts a collection of widgets. It can be used to swap between collections of widgets (screens) in a py_cui @Author: Jakub Wlodek @Created 05-Oct-2019 WidgetSet class WidgetSet Class that represents a collection of widgets.. Use PyCUI.apply_widget_set() to set a given widget set for display Attributes Type Doc grid py_cui.grid.Grid The main layout manager for the CUI widgets dict of str - py_cui.widgets.Widget dict of widget in the grid keybindings list of py_cui.keybinding.KeyBinding list of keybindings to check against in the main CUI loop height, width int height of the terminal in characters, width of terminal in characters Methods method Doc set_selected_widget Function that sets the selected cell for the CU. add_key_command Function that adds a keybinding to the CUI when in overview mod. add_scroll_menu Function that adds a new scroll menu to the CUI gri. add_checkbox_menu Function that adds a new checkbox menu to the CUI gri. add_text_box Function that adds a new text box to the CUI gri. add_text_block Function that adds a new text block to the CUI gri. add_label Function that adds a new label to the CUI gri. add_block_label Function that adds a new block label to the CUI gri. add_button Function that adds a new button to the CUI gri. set_selected_widget set_selected_widget(widget_id) Function that sets the selected cell for the CU. Parameters Type Doc cell_title str the title of the cell add_key_command add_key_command(key, command) Function that adds a keybinding to the CUI when in overview mod. Parameters Type Doc key py_cui.keys.KEY_* The key bound to the command command Function A no-arg or lambda function to fire on keypress add_scroll_menu add_scroll_menu(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Function that adds a new scroll menu to the CUI gri. Parameters Type Doc title str The title of the scroll menu row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction Returns Type Doc add_checkbox_menu add_checkbox_menu(title, row, column, row_span=1, column_span=1, padx=1, pady=0, checked_char='X') Function that adds a new checkbox menu to the CUI gri. Parameters Type Doc title str The title of the checkbox row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction checked_char='X' char The character used to mark 'Checked' items Returns Type Doc new_checkbox_menu CheckBoxMenu A reference to the created checkbox object. add_text_box add_text_box(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Function that adds a new text box to the CUI gri. Parameters Type Doc title str The title of the textbox row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction initial_text='' str Initial text for the textbox Returns Type Doc new_text_box TextBox A reference to the created textbox object. add_text_block add_text_block(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Function that adds a new text block to the CUI gri. Parameters Type Doc title str The title of the text block row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction initial_text='' str Initial text for the text block Returns Type Doc new_text_block ScrollTextBlock A reference to the created textblock object. add_label add_label(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Function that adds a new label to the CUI gri. Parameters Type Doc title str The title of the label row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction Returns Type Doc new_label Label A reference to the created label object. add_block_label add_block_label(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, center=True) Function that adds a new block label to the CUI gri. Parameters Type Doc title str The title of the block label row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction center bool flag to tell label to be centered or left-aligned. Returns Type Doc new_label BlockLabel A reference to the created block label object. add_button add_button(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Function that adds a new button to the CUI gri. Parameters Type Doc title str The title of the button row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction command=None Function A no-argument or lambda function to fire on button press. Returns Type Doc new_button Button A reference to the created button object.","title":"Widget Sets"},{"location":"DocstringGenerated/WidgetSet/#file-containing-class-that-abstracts-a-collection-of-widgets","text":"It can be used to swap between collections of widgets (screens) in a py_cui @Author: Jakub Wlodek @Created 05-Oct-2019","title":"File containing class that abstracts a collection of widgets."},{"location":"DocstringGenerated/WidgetSet/#widgetset","text":"class WidgetSet Class that represents a collection of widgets.. Use PyCUI.apply_widget_set() to set a given widget set for display Attributes Type Doc grid py_cui.grid.Grid The main layout manager for the CUI widgets dict of str - py_cui.widgets.Widget dict of widget in the grid keybindings list of py_cui.keybinding.KeyBinding list of keybindings to check against in the main CUI loop height, width int height of the terminal in characters, width of terminal in characters","title":"WidgetSet"},{"location":"DocstringGenerated/WidgetSet/#methods","text":"method Doc set_selected_widget Function that sets the selected cell for the CU. add_key_command Function that adds a keybinding to the CUI when in overview mod. add_scroll_menu Function that adds a new scroll menu to the CUI gri. add_checkbox_menu Function that adds a new checkbox menu to the CUI gri. add_text_box Function that adds a new text box to the CUI gri. add_text_block Function that adds a new text block to the CUI gri. add_label Function that adds a new label to the CUI gri. add_block_label Function that adds a new block label to the CUI gri. add_button Function that adds a new button to the CUI gri.","title":"Methods"},{"location":"DocstringGenerated/WidgetSet/#set_selected_widget","text":"set_selected_widget(widget_id) Function that sets the selected cell for the CU. Parameters Type Doc cell_title str the title of the cell","title":"set_selected_widget"},{"location":"DocstringGenerated/WidgetSet/#add_key_command","text":"add_key_command(key, command) Function that adds a keybinding to the CUI when in overview mod. Parameters Type Doc key py_cui.keys.KEY_* The key bound to the command command Function A no-arg or lambda function to fire on keypress","title":"add_key_command"},{"location":"DocstringGenerated/WidgetSet/#add_scroll_menu","text":"add_scroll_menu(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Function that adds a new scroll menu to the CUI gri. Parameters Type Doc title str The title of the scroll menu row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction Returns Type Doc","title":"add_scroll_menu"},{"location":"DocstringGenerated/WidgetSet/#add_checkbox_menu","text":"add_checkbox_menu(title, row, column, row_span=1, column_span=1, padx=1, pady=0, checked_char='X') Function that adds a new checkbox menu to the CUI gri. Parameters Type Doc title str The title of the checkbox row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction checked_char='X' char The character used to mark 'Checked' items Returns Type Doc new_checkbox_menu CheckBoxMenu A reference to the created checkbox object.","title":"add_checkbox_menu"},{"location":"DocstringGenerated/WidgetSet/#add_text_box","text":"add_text_box(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Function that adds a new text box to the CUI gri. Parameters Type Doc title str The title of the textbox row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction initial_text='' str Initial text for the textbox Returns Type Doc new_text_box TextBox A reference to the created textbox object.","title":"add_text_box"},{"location":"DocstringGenerated/WidgetSet/#add_text_block","text":"add_text_block(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Function that adds a new text block to the CUI gri. Parameters Type Doc title str The title of the text block row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction initial_text='' str Initial text for the text block Returns Type Doc new_text_block ScrollTextBlock A reference to the created textblock object.","title":"add_text_block"},{"location":"DocstringGenerated/WidgetSet/#add_label","text":"add_label(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Function that adds a new label to the CUI gri. Parameters Type Doc title str The title of the label row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction Returns Type Doc new_label Label A reference to the created label object.","title":"add_label"},{"location":"DocstringGenerated/WidgetSet/#add_block_label","text":"add_block_label(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, center=True) Function that adds a new block label to the CUI gri. Parameters Type Doc title str The title of the block label row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction center bool flag to tell label to be centered or left-aligned. Returns Type Doc new_label BlockLabel A reference to the created block label object.","title":"add_block_label"},{"location":"DocstringGenerated/WidgetSet/#add_button","text":"add_button(title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Function that adds a new button to the CUI gri. Parameters Type Doc title str The title of the button row int The row value, from the top down column int The column value from the top down row_span=1 int The number of rows to span accross column_span=1 int the number of columns to span accross padx=1 int number of padding characters in the x direction pady=0 int number of padding characters in the y direction command=None Function A no-argument or lambda function to fire on button press. Returns Type Doc new_button Button A reference to the created button object.","title":"add_button"},{"location":"DocstringGenerated/Widgets/","text":"File contatining all core widget classes for py_cui. Widgets are the basic building blocks of a user interface made with py_cui. This file contains classes for: Base Widget class Label Block Label Scroll Menu Checkbox Menu Button TextBox Text Block Additional widgets should be added in as additional_widgets/$WIDGET_NAME.py, importing this file and extending the base Widget class, or if appropriate one of the other core widgets. @author:Jakub Wlodek @created: 12-Aug-2019 Widget class Widget Top Level Widget Base Clas. Extended by all widgets. Contains base classes for handling key presses, drawing, and setting status bar text. Parameters Type Doc id int Id of the widget title str Widget title grid py_cui.grid.Grid The parent grid object of the widget renderer py_cui.renderer.Renderer The renderer object that draws the widget row, column int row and column position of the widget row_span, column_span int number of rows or columns spanned by the widget padx, pady int Padding size in terminal characters start_x, start_y int The position on the terminal of the top left corner of the widget width, height int The width/height of the widget color int Color code combination selected_color int color code combination for when widget is selected selected bool Flag that says if widget is selected is_selectable bool Flag that says if a widget can be selected help_text str text displayed in status bar when selected key_commands dict Dictionary mapping key codes to functions text_color_rules list of py_cui.ColorRule color rules to load into renderer when drawing widget Attributes Type Doc Methods method Doc set_focus_text Function that sets the text of the status bar on focus for a particular widge. add_key_command Maps a keycode to a function that will be executed when in focus mod. add_text_color_rule Forces renderer to draw text using given color if text_condition_function returns Tru. set_standard_color Sets the standard color for the widge. set_selected_color Sets the selected color for the widge. assign_renderer Function that assigns a renderer object to the widge. get_absolute_position Gets the absolute position of the widget in character. get_absolute_dims Gets the absolute dimensions of the widget in character. is_row_col_inside Checks if a particular row + column is inside the widget are. update_height_width Function that refreshes position and dimensons on resize.. get_help_text Returns help tex. handle_key_press Base class function that handles all assigned key presses. draw Base class draw class that checks if renderer is valid. set_focus_text set_focus_text(text) Function that sets the text of the status bar on focus for a particular widge. Parameters Type Doc text str text to write to status bar when in focus mode. add_key_command add_key_command(key, command) Maps a keycode to a function that will be executed when in focus mod. Parameters Type Doc key py_cui.keys.KEY ascii keycode used to map the key command function without args a non-argument function or lambda function to execute if in focus mode and key is pressed add_text_color_rule add_text_color_rule(regex, color, rule_type, match_type='line', region=[0,1], include_whitespace=False) Forces renderer to draw text using given color if text_condition_function returns Tru. Parameters Type Doc regex str A string to check against the line for a given rule type color int a supported py_cui color value rule_type string A supported color rule type match_type='line' str sets match type. Can be 'line', 'regex', or 'region' region [int, int] A specified region to color if using match_type='region' include_whitespace bool if false, strip string before checking for match set_standard_color set_standard_color(color) Sets the standard color for the widge. Parameters Type Doc color int Color code for widegt set_selected_color set_selected_color(color) Sets the selected color for the widge. Parameters Type Doc color int Color code for widegt when selected assign_renderer assign_renderer(renderer) Function that assigns a renderer object to the widge. (Meant for internal usage only) Parameters Type Doc renderer py_cui.renderer.Renderer Renderer for drawing widget get_absolute_position get_absolute_position() Gets the absolute position of the widget in character. Returns Type Doc x_pos, y_pos int position of widget in terminal get_absolute_dims get_absolute_dims() Gets the absolute dimensions of the widget in character. Returns Type Doc width, height int dimensions of widget in terminal is_row_col_inside is_row_col_inside(row, col) Checks if a particular row + column is inside the widget are. Parameters Type Doc row, col int row and column position to check Returns Type Doc is_inside bool True if row, col is within widget bounds, false otherwise update_height_width update_height_width() Function that refreshes position and dimensons on resize.. If necessary, make sure required widget attributes updated here as well. get_help_text get_help_text() Returns help tex. Returns Type Doc help_text str Status bar text handle_key_press handle_key_press(key_pressed) Base class function that handles all assigned key presses. When overwriting this function, make sure to add a super().handle_key_press(key_pressed) call, as this is required for user defined key command support Parameters Type Doc key_pressed int key code of key pressed draw draw() Base class draw class that checks if renderer is valid. Should be called with super().draw() in overrides Label class Label(Widget) The most basic subclass of Widget. Simply displays one centered row of text. Has no unique attributes or methods Methods method Doc toggle_border Function that gives option to draw border around labe. draw Override base draw class. toggle_border toggle_border() Function that gives option to draw border around labe. draw draw() Override base draw class. Center text and draw it BlockLabel class BlockLabel(Widget) A Variation of the label widget that renders a block of text. Attributes Type Doc lines list of str list of lines that make up block text center bool Decides whether or not label should be centered Methods method Doc draw Override base draw class. draw draw() Override base draw class. ScrollMenu class ScrollMenu(Widget) A scroll menu widget. Allows for creating a scrollable list of items of which one is selectable. Analogous to a RadioButton Attributes Type Doc top_view int the uppermost menu element in view selected_item int the currently highlighted menu item view_items list of str list of menu items Methods method Doc clear Clears all items from the Scroll Men. scroll_up Function that scrolls the view up in the scroll men. scroll_down Function that scrolls the view down in the scroll men. add_item Adds an item to the menu. add_item_list Adds a list of items to the scroll menu. remove_selected_item Function that removes the selected item from the scroll menu. get_item_list Function that gets list of items in a scroll men. get Function that gets the selected item from the scroll men. handle_key_press Override base class function. draw Overrides base class draw functio. clear clear() Clears all items from the Scroll Men. scroll_up scroll_up() Function that scrolls the view up in the scroll men. scroll_down scroll_down() Function that scrolls the view down in the scroll men. add_item add_item(item_text) Adds an item to the menu. Parameters Type Doc item_text str The text for the item add_item_list add_item_list(item_list) Adds a list of items to the scroll menu. Parameters Type Doc item_list list of str list of strings to add as items to the scrollmenu remove_selected_item remove_selected_item() Function that removes the selected item from the scroll menu. get_item_list get_item_list() Function that gets list of items in a scroll men. Returns Type Doc item_list list of str list of items in the scrollmenu get get() Function that gets the selected item from the scroll men. Returns Type Doc item str selected item, or None if there are no items in the menu handle_key_press handle_key_press(key_pressed) Override base class function. UP_ARROW scrolls up, DOWN_ARROW scrolls down. Parameters Type Doc key_pressed int key code of key pressed draw draw() Overrides base class draw functio. CheckBoxMenu class CheckBoxMenu(ScrollMenu) Extension of ScrollMenu that allows for multiple items to be selected at once. Attributes Type Doc selected_item_list list of str List of checked items checked_char char Character to represent a checked item Methods method Doc add_item_list Adds list of items to the checkbo. get Gets list of selected items from the checkbo. mark_item_as_checked Function that marks an item as selecte. handle_key_press Override of key presses. add_item_list add_item_list(item_list) Adds list of items to the checkbo. Parameters Type Doc item_list list of str Menu item list to add get get() Gets list of selected items from the checkbo. Returns Type Doc selected_items list of str list of checked items mark_item_as_checked mark_item_as_checked(text) Function that marks an item as selecte. Parameters Type Doc text str Mark item with text = text as checked handle_key_press handle_key_press(key_pressed) Override of key presses. First, run the superclass function, scrolling should still work. Adds Enter command to toggle selection Parameters Type Doc key_pressed int key code of pressed key Button class Button(Widget) Basic button widget. Allows for running a command function on Enter Attributes Type Doc command function A no-args function to run when the button is pressed. Methods method Doc draw Override of base class draw functio. draw draw() Override of base class draw functio. TextBox class TextBox(Widget) Widget for entering small single lines of tex. Attributes Type Doc text str The text in the text box cursor_x, cursor_y int The absolute positions of the cursor in the terminal window cursor_text_pos int the cursor position relative to the text cursor_max_left, cursor_max_right int The cursor bounds of the text box viewport_width int The width of the textbox viewport Methods method Doc set_text Sets the value of the text. Overwrites existing tex. get Gets value of the text in the textbo. clear Clears the text in the textbo. move_left Shifts the cursor the the left. Internal use onl. move_right Shifts the cursor the the right. Internal use onl. insert_char Inserts char at cursor position. jump_to_start Jumps to the start of the textbo. jump_to_end Jumps to the end to the textbo. erase_char Erases character at textbox curso. handle_key_press Override of base handle key press functio. draw Override of base draw functio. set_text set_text(text) Sets the value of the text. Overwrites existing tex. Parameters Type Doc text str The text to write to the textbox get get() Gets value of the text in the textbo. Returns Type Doc text str The current textbox test clear clear() Clears the text in the textbo. move_left move_left() Shifts the cursor the the left. Internal use onl. move_right move_right() Shifts the cursor the the right. Internal use onl. insert_char insert_char(key_pressed) Inserts char at cursor position. Internal use only Parameters Type Doc key_pressed int key code of key pressed jump_to_start jump_to_start() Jumps to the start of the textbo. jump_to_end jump_to_end() Jumps to the end to the textbo. erase_char erase_char() Erases character at textbox curso. handle_key_press handle_key_press(key_pressed) Override of base handle key press functio. Parameters Type Doc key_pressed int key code of key pressed draw draw() Override of base draw functio. ScrollTextBlock class ScrollTextBlock(Widget) Widget for editing large multi-line blocks of tex. Attributes Type Doc text_lines list of str The lines of text in the text box cursor_x, cursor_y int The absolute positions of the cursor in the terminal window cursor_text_pos_x, cursor_text_pos_y int the cursor position relative to the text cursor_max_left, cursor_max_right int The cursor bounds of the text box cursor_max_up, cursor_max_down int The cursor bounds of the text box viewport_x_start, viewport_y_start int upper left corner of the viewport viewport_width int The width of the textbox viewport Methods method Doc get Gets all of the text in the textblock and returns i. write Function used for writing text to the text bloc. clear Function that clears the text bloc. get_current_line Returns the line on which the cursor currently reside. set_text Function that sets the text for the textblock.. set_text_line Function that sets the current line's text. move_left Function that moves the cursor/text position one location to the lef. move_right Function that moves the cursor/text position one location to the righ. move_up Function that moves the cursor/text position one location u. move_down Function that moves the cursor/text position one location dow. handle_newline Function that handles recieving newline characters in the tex. handle_backspace Function that handles recieving backspace characters in the tex. handle_home Function that handles recieving a home keypres. handle_end Function that handles recieving an end keypres. handle_delete Function that handles recieving a delete keypres. insert_char Function that handles recieving a characte. handle_key_press Override of base class handle key press functio. draw Override of base class draw functio. get get() Gets all of the text in the textblock and returns i. Returns Type Doc text str The current text in the text block write write(text) Function used for writing text to the text bloc. Parameters Type Doc text str Text to write to the text block clear clear() Function that clears the text bloc. get_current_line get_current_line() Returns the line on which the cursor currently reside. Returns Type Doc current_line str The current line of text that the cursor is on set_text set_text(text) Function that sets the text for the textblock.. Note that this will overwrite any existing text Parameters Type Doc text str text to write into text block set_text_line set_text_line(text) Function that sets the current line's text. Meant only for internal use Parameters Type Doc text str text line to write into text block move_left move_left() Function that moves the cursor/text position one location to the lef. move_right move_right() Function that moves the cursor/text position one location to the righ. move_up move_up() Function that moves the cursor/text position one location u. move_down move_down() Function that moves the cursor/text position one location dow. handle_newline handle_newline() Function that handles recieving newline characters in the tex. handle_backspace handle_backspace() Function that handles recieving backspace characters in the tex. handle_home handle_home() Function that handles recieving a home keypres. handle_end handle_end() Function that handles recieving an end keypres. handle_delete handle_delete() Function that handles recieving a delete keypres. insert_char insert_char(key_pressed) Function that handles recieving a characte. Parameters Type Doc key_pressed int key code of key pressed handle_key_press handle_key_press(key_pressed) Override of base class handle key press functio. Parameters Type Doc key_pressed int key code of key pressed draw draw() Override of base class draw functio.","title":"Widgets"},{"location":"DocstringGenerated/Widgets/#file-contatining-all-core-widget-classes-for-py_cui","text":"Widgets are the basic building blocks of a user interface made with py_cui. This file contains classes for: Base Widget class Label Block Label Scroll Menu Checkbox Menu Button TextBox Text Block Additional widgets should be added in as additional_widgets/$WIDGET_NAME.py, importing this file and extending the base Widget class, or if appropriate one of the other core widgets. @author:Jakub Wlodek @created: 12-Aug-2019","title":"File contatining all core widget classes for py_cui."},{"location":"DocstringGenerated/Widgets/#widget","text":"class Widget Top Level Widget Base Clas. Extended by all widgets. Contains base classes for handling key presses, drawing, and setting status bar text. Parameters Type Doc id int Id of the widget title str Widget title grid py_cui.grid.Grid The parent grid object of the widget renderer py_cui.renderer.Renderer The renderer object that draws the widget row, column int row and column position of the widget row_span, column_span int number of rows or columns spanned by the widget padx, pady int Padding size in terminal characters start_x, start_y int The position on the terminal of the top left corner of the widget width, height int The width/height of the widget color int Color code combination selected_color int color code combination for when widget is selected selected bool Flag that says if widget is selected is_selectable bool Flag that says if a widget can be selected help_text str text displayed in status bar when selected key_commands dict Dictionary mapping key codes to functions text_color_rules list of py_cui.ColorRule color rules to load into renderer when drawing widget Attributes Type Doc","title":"Widget"},{"location":"DocstringGenerated/Widgets/#methods","text":"method Doc set_focus_text Function that sets the text of the status bar on focus for a particular widge. add_key_command Maps a keycode to a function that will be executed when in focus mod. add_text_color_rule Forces renderer to draw text using given color if text_condition_function returns Tru. set_standard_color Sets the standard color for the widge. set_selected_color Sets the selected color for the widge. assign_renderer Function that assigns a renderer object to the widge. get_absolute_position Gets the absolute position of the widget in character. get_absolute_dims Gets the absolute dimensions of the widget in character. is_row_col_inside Checks if a particular row + column is inside the widget are. update_height_width Function that refreshes position and dimensons on resize.. get_help_text Returns help tex. handle_key_press Base class function that handles all assigned key presses. draw Base class draw class that checks if renderer is valid.","title":"Methods"},{"location":"DocstringGenerated/Widgets/#set_focus_text","text":"set_focus_text(text) Function that sets the text of the status bar on focus for a particular widge. Parameters Type Doc text str text to write to status bar when in focus mode.","title":"set_focus_text"},{"location":"DocstringGenerated/Widgets/#add_key_command","text":"add_key_command(key, command) Maps a keycode to a function that will be executed when in focus mod. Parameters Type Doc key py_cui.keys.KEY ascii keycode used to map the key command function without args a non-argument function or lambda function to execute if in focus mode and key is pressed","title":"add_key_command"},{"location":"DocstringGenerated/Widgets/#add_text_color_rule","text":"add_text_color_rule(regex, color, rule_type, match_type='line', region=[0,1], include_whitespace=False) Forces renderer to draw text using given color if text_condition_function returns Tru. Parameters Type Doc regex str A string to check against the line for a given rule type color int a supported py_cui color value rule_type string A supported color rule type match_type='line' str sets match type. Can be 'line', 'regex', or 'region' region [int, int] A specified region to color if using match_type='region' include_whitespace bool if false, strip string before checking for match","title":"add_text_color_rule"},{"location":"DocstringGenerated/Widgets/#set_standard_color","text":"set_standard_color(color) Sets the standard color for the widge. Parameters Type Doc color int Color code for widegt","title":"set_standard_color"},{"location":"DocstringGenerated/Widgets/#set_selected_color","text":"set_selected_color(color) Sets the selected color for the widge. Parameters Type Doc color int Color code for widegt when selected","title":"set_selected_color"},{"location":"DocstringGenerated/Widgets/#assign_renderer","text":"assign_renderer(renderer) Function that assigns a renderer object to the widge. (Meant for internal usage only) Parameters Type Doc renderer py_cui.renderer.Renderer Renderer for drawing widget","title":"assign_renderer"},{"location":"DocstringGenerated/Widgets/#get_absolute_position","text":"get_absolute_position() Gets the absolute position of the widget in character. Returns Type Doc x_pos, y_pos int position of widget in terminal","title":"get_absolute_position"},{"location":"DocstringGenerated/Widgets/#get_absolute_dims","text":"get_absolute_dims() Gets the absolute dimensions of the widget in character. Returns Type Doc width, height int dimensions of widget in terminal","title":"get_absolute_dims"},{"location":"DocstringGenerated/Widgets/#is_row_col_inside","text":"is_row_col_inside(row, col) Checks if a particular row + column is inside the widget are. Parameters Type Doc row, col int row and column position to check Returns Type Doc is_inside bool True if row, col is within widget bounds, false otherwise","title":"is_row_col_inside"},{"location":"DocstringGenerated/Widgets/#update_height_width","text":"update_height_width() Function that refreshes position and dimensons on resize.. If necessary, make sure required widget attributes updated here as well.","title":"update_height_width"},{"location":"DocstringGenerated/Widgets/#get_help_text","text":"get_help_text() Returns help tex. Returns Type Doc help_text str Status bar text","title":"get_help_text"},{"location":"DocstringGenerated/Widgets/#handle_key_press","text":"handle_key_press(key_pressed) Base class function that handles all assigned key presses. When overwriting this function, make sure to add a super().handle_key_press(key_pressed) call, as this is required for user defined key command support Parameters Type Doc key_pressed int key code of key pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Widgets/#draw","text":"draw() Base class draw class that checks if renderer is valid. Should be called with super().draw() in overrides","title":"draw"},{"location":"DocstringGenerated/Widgets/#label","text":"class Label(Widget) The most basic subclass of Widget. Simply displays one centered row of text. Has no unique attributes or methods","title":"Label"},{"location":"DocstringGenerated/Widgets/#methods_1","text":"method Doc toggle_border Function that gives option to draw border around labe. draw Override base draw class.","title":"Methods"},{"location":"DocstringGenerated/Widgets/#toggle_border","text":"toggle_border() Function that gives option to draw border around labe.","title":"toggle_border"},{"location":"DocstringGenerated/Widgets/#draw_1","text":"draw() Override base draw class. Center text and draw it","title":"draw"},{"location":"DocstringGenerated/Widgets/#blocklabel","text":"class BlockLabel(Widget) A Variation of the label widget that renders a block of text. Attributes Type Doc lines list of str list of lines that make up block text center bool Decides whether or not label should be centered","title":"BlockLabel"},{"location":"DocstringGenerated/Widgets/#methods_2","text":"method Doc draw Override base draw class.","title":"Methods"},{"location":"DocstringGenerated/Widgets/#draw_2","text":"draw() Override base draw class.","title":"draw"},{"location":"DocstringGenerated/Widgets/#scrollmenu","text":"class ScrollMenu(Widget) A scroll menu widget. Allows for creating a scrollable list of items of which one is selectable. Analogous to a RadioButton Attributes Type Doc top_view int the uppermost menu element in view selected_item int the currently highlighted menu item view_items list of str list of menu items","title":"ScrollMenu"},{"location":"DocstringGenerated/Widgets/#methods_3","text":"method Doc clear Clears all items from the Scroll Men. scroll_up Function that scrolls the view up in the scroll men. scroll_down Function that scrolls the view down in the scroll men. add_item Adds an item to the menu. add_item_list Adds a list of items to the scroll menu. remove_selected_item Function that removes the selected item from the scroll menu. get_item_list Function that gets list of items in a scroll men. get Function that gets the selected item from the scroll men. handle_key_press Override base class function. draw Overrides base class draw functio.","title":"Methods"},{"location":"DocstringGenerated/Widgets/#clear","text":"clear() Clears all items from the Scroll Men.","title":"clear"},{"location":"DocstringGenerated/Widgets/#scroll_up","text":"scroll_up() Function that scrolls the view up in the scroll men.","title":"scroll_up"},{"location":"DocstringGenerated/Widgets/#scroll_down","text":"scroll_down() Function that scrolls the view down in the scroll men.","title":"scroll_down"},{"location":"DocstringGenerated/Widgets/#add_item","text":"add_item(item_text) Adds an item to the menu. Parameters Type Doc item_text str The text for the item","title":"add_item"},{"location":"DocstringGenerated/Widgets/#add_item_list","text":"add_item_list(item_list) Adds a list of items to the scroll menu. Parameters Type Doc item_list list of str list of strings to add as items to the scrollmenu","title":"add_item_list"},{"location":"DocstringGenerated/Widgets/#remove_selected_item","text":"remove_selected_item() Function that removes the selected item from the scroll menu.","title":"remove_selected_item"},{"location":"DocstringGenerated/Widgets/#get_item_list","text":"get_item_list() Function that gets list of items in a scroll men. Returns Type Doc item_list list of str list of items in the scrollmenu","title":"get_item_list"},{"location":"DocstringGenerated/Widgets/#get","text":"get() Function that gets the selected item from the scroll men. Returns Type Doc item str selected item, or None if there are no items in the menu","title":"get"},{"location":"DocstringGenerated/Widgets/#handle_key_press_1","text":"handle_key_press(key_pressed) Override base class function. UP_ARROW scrolls up, DOWN_ARROW scrolls down. Parameters Type Doc key_pressed int key code of key pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Widgets/#draw_3","text":"draw() Overrides base class draw functio.","title":"draw"},{"location":"DocstringGenerated/Widgets/#checkboxmenu","text":"class CheckBoxMenu(ScrollMenu) Extension of ScrollMenu that allows for multiple items to be selected at once. Attributes Type Doc selected_item_list list of str List of checked items checked_char char Character to represent a checked item","title":"CheckBoxMenu"},{"location":"DocstringGenerated/Widgets/#methods_4","text":"method Doc add_item_list Adds list of items to the checkbo. get Gets list of selected items from the checkbo. mark_item_as_checked Function that marks an item as selecte. handle_key_press Override of key presses.","title":"Methods"},{"location":"DocstringGenerated/Widgets/#add_item_list_1","text":"add_item_list(item_list) Adds list of items to the checkbo. Parameters Type Doc item_list list of str Menu item list to add","title":"add_item_list"},{"location":"DocstringGenerated/Widgets/#get_1","text":"get() Gets list of selected items from the checkbo. Returns Type Doc selected_items list of str list of checked items","title":"get"},{"location":"DocstringGenerated/Widgets/#mark_item_as_checked","text":"mark_item_as_checked(text) Function that marks an item as selecte. Parameters Type Doc text str Mark item with text = text as checked","title":"mark_item_as_checked"},{"location":"DocstringGenerated/Widgets/#handle_key_press_2","text":"handle_key_press(key_pressed) Override of key presses. First, run the superclass function, scrolling should still work. Adds Enter command to toggle selection Parameters Type Doc key_pressed int key code of pressed key","title":"handle_key_press"},{"location":"DocstringGenerated/Widgets/#button","text":"class Button(Widget) Basic button widget. Allows for running a command function on Enter Attributes Type Doc command function A no-args function to run when the button is pressed.","title":"Button"},{"location":"DocstringGenerated/Widgets/#methods_5","text":"method Doc draw Override of base class draw functio.","title":"Methods"},{"location":"DocstringGenerated/Widgets/#draw_4","text":"draw() Override of base class draw functio.","title":"draw"},{"location":"DocstringGenerated/Widgets/#textbox","text":"class TextBox(Widget) Widget for entering small single lines of tex. Attributes Type Doc text str The text in the text box cursor_x, cursor_y int The absolute positions of the cursor in the terminal window cursor_text_pos int the cursor position relative to the text cursor_max_left, cursor_max_right int The cursor bounds of the text box viewport_width int The width of the textbox viewport","title":"TextBox"},{"location":"DocstringGenerated/Widgets/#methods_6","text":"method Doc set_text Sets the value of the text. Overwrites existing tex. get Gets value of the text in the textbo. clear Clears the text in the textbo. move_left Shifts the cursor the the left. Internal use onl. move_right Shifts the cursor the the right. Internal use onl. insert_char Inserts char at cursor position. jump_to_start Jumps to the start of the textbo. jump_to_end Jumps to the end to the textbo. erase_char Erases character at textbox curso. handle_key_press Override of base handle key press functio. draw Override of base draw functio.","title":"Methods"},{"location":"DocstringGenerated/Widgets/#set_text","text":"set_text(text) Sets the value of the text. Overwrites existing tex. Parameters Type Doc text str The text to write to the textbox","title":"set_text"},{"location":"DocstringGenerated/Widgets/#get_2","text":"get() Gets value of the text in the textbo. Returns Type Doc text str The current textbox test","title":"get"},{"location":"DocstringGenerated/Widgets/#clear_1","text":"clear() Clears the text in the textbo.","title":"clear"},{"location":"DocstringGenerated/Widgets/#move_left","text":"move_left() Shifts the cursor the the left. Internal use onl.","title":"move_left"},{"location":"DocstringGenerated/Widgets/#move_right","text":"move_right() Shifts the cursor the the right. Internal use onl.","title":"move_right"},{"location":"DocstringGenerated/Widgets/#insert_char","text":"insert_char(key_pressed) Inserts char at cursor position. Internal use only Parameters Type Doc key_pressed int key code of key pressed","title":"insert_char"},{"location":"DocstringGenerated/Widgets/#jump_to_start","text":"jump_to_start() Jumps to the start of the textbo.","title":"jump_to_start"},{"location":"DocstringGenerated/Widgets/#jump_to_end","text":"jump_to_end() Jumps to the end to the textbo.","title":"jump_to_end"},{"location":"DocstringGenerated/Widgets/#erase_char","text":"erase_char() Erases character at textbox curso.","title":"erase_char"},{"location":"DocstringGenerated/Widgets/#handle_key_press_3","text":"handle_key_press(key_pressed) Override of base handle key press functio. Parameters Type Doc key_pressed int key code of key pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Widgets/#draw_5","text":"draw() Override of base draw functio.","title":"draw"},{"location":"DocstringGenerated/Widgets/#scrolltextblock","text":"class ScrollTextBlock(Widget) Widget for editing large multi-line blocks of tex. Attributes Type Doc text_lines list of str The lines of text in the text box cursor_x, cursor_y int The absolute positions of the cursor in the terminal window cursor_text_pos_x, cursor_text_pos_y int the cursor position relative to the text cursor_max_left, cursor_max_right int The cursor bounds of the text box cursor_max_up, cursor_max_down int The cursor bounds of the text box viewport_x_start, viewport_y_start int upper left corner of the viewport viewport_width int The width of the textbox viewport","title":"ScrollTextBlock"},{"location":"DocstringGenerated/Widgets/#methods_7","text":"method Doc get Gets all of the text in the textblock and returns i. write Function used for writing text to the text bloc. clear Function that clears the text bloc. get_current_line Returns the line on which the cursor currently reside. set_text Function that sets the text for the textblock.. set_text_line Function that sets the current line's text. move_left Function that moves the cursor/text position one location to the lef. move_right Function that moves the cursor/text position one location to the righ. move_up Function that moves the cursor/text position one location u. move_down Function that moves the cursor/text position one location dow. handle_newline Function that handles recieving newline characters in the tex. handle_backspace Function that handles recieving backspace characters in the tex. handle_home Function that handles recieving a home keypres. handle_end Function that handles recieving an end keypres. handle_delete Function that handles recieving a delete keypres. insert_char Function that handles recieving a characte. handle_key_press Override of base class handle key press functio. draw Override of base class draw functio.","title":"Methods"},{"location":"DocstringGenerated/Widgets/#get_3","text":"get() Gets all of the text in the textblock and returns i. Returns Type Doc text str The current text in the text block","title":"get"},{"location":"DocstringGenerated/Widgets/#write","text":"write(text) Function used for writing text to the text bloc. Parameters Type Doc text str Text to write to the text block","title":"write"},{"location":"DocstringGenerated/Widgets/#clear_2","text":"clear() Function that clears the text bloc.","title":"clear"},{"location":"DocstringGenerated/Widgets/#get_current_line","text":"get_current_line() Returns the line on which the cursor currently reside. Returns Type Doc current_line str The current line of text that the cursor is on","title":"get_current_line"},{"location":"DocstringGenerated/Widgets/#set_text_1","text":"set_text(text) Function that sets the text for the textblock.. Note that this will overwrite any existing text Parameters Type Doc text str text to write into text block","title":"set_text"},{"location":"DocstringGenerated/Widgets/#set_text_line","text":"set_text_line(text) Function that sets the current line's text. Meant only for internal use Parameters Type Doc text str text line to write into text block","title":"set_text_line"},{"location":"DocstringGenerated/Widgets/#move_left_1","text":"move_left() Function that moves the cursor/text position one location to the lef.","title":"move_left"},{"location":"DocstringGenerated/Widgets/#move_right_1","text":"move_right() Function that moves the cursor/text position one location to the righ.","title":"move_right"},{"location":"DocstringGenerated/Widgets/#move_up","text":"move_up() Function that moves the cursor/text position one location u.","title":"move_up"},{"location":"DocstringGenerated/Widgets/#move_down","text":"move_down() Function that moves the cursor/text position one location dow.","title":"move_down"},{"location":"DocstringGenerated/Widgets/#handle_newline","text":"handle_newline() Function that handles recieving newline characters in the tex.","title":"handle_newline"},{"location":"DocstringGenerated/Widgets/#handle_backspace","text":"handle_backspace() Function that handles recieving backspace characters in the tex.","title":"handle_backspace"},{"location":"DocstringGenerated/Widgets/#handle_home","text":"handle_home() Function that handles recieving a home keypres.","title":"handle_home"},{"location":"DocstringGenerated/Widgets/#handle_end","text":"handle_end() Function that handles recieving an end keypres.","title":"handle_end"},{"location":"DocstringGenerated/Widgets/#handle_delete","text":"handle_delete() Function that handles recieving a delete keypres.","title":"handle_delete"},{"location":"DocstringGenerated/Widgets/#insert_char_1","text":"insert_char(key_pressed) Function that handles recieving a characte. Parameters Type Doc key_pressed int key code of key pressed","title":"insert_char"},{"location":"DocstringGenerated/Widgets/#handle_key_press_4","text":"handle_key_press(key_pressed) Override of base class handle key press functio. Parameters Type Doc key_pressed int key code of key pressed","title":"handle_key_press"},{"location":"DocstringGenerated/Widgets/#draw_6","text":"draw() Override of base class draw functio.","title":"draw"},{"location":"scripts/markdoc/","text":"MarkDoc This piece of code can be used to convert NumPy-styled Python docstrings ( example ), such as those used in scikit-learn , to Markdown with minimum dependencies. In this way, only the code-contained documentation needs to be editted, and your documentation on for example readthedocs can be automatically updated thereafter with some configuration. Example The converted documentation for this particular code can be found here . Before Use The format assumes that your code (or at least your docstring documentation) is in line with the styleguides of both PEP8 and PEP257. There are two ways to go about making sure this is the case: Fast Just check the example here to get a quick overview of how the docstrings would have to look in order for them to parse correctly. Better The styleguides are incorporated into two libraries that can be used to check the Python files for style errors in terminal, like so: pip install pep8 pip install pep257 pep8 yourpythonfile.py pep257 yourpythonfile.py These are more conveniently implemented in linter plugins such as linter-pep8 and linter-pep257 for the linter package in Atom , and Flake8Lint for Sublime Text (and pretty much every other IDE). Usage First clone from GitHub: git clone https://www.github.com/cmry/markdoc To use the script within terminal, simply type: python3 markdoc.py /dir/to/somefile.py /dir/to/somedoc.md If you want to automatically generate a bunch of documentation and are not comfortable with writing .sh scripts, you can use the code in Python as well: from markdoc import MarkDoc md = MarkDoc('/dir/to/somefile.py', '/dir/to/somedoc.md') You can access the converted markdown string in: # print markdown from class attribute print(md.markdown) The class runs itself on initialization (calls self.read ). If you do not want this, you can add cold=True to the class initialization, like so: md = MarkDoc('file.py', 'doc.md', cold=True) Planned Fixes Handle consecutive classes within the same file. Fix inherrited classes being handled correctly (no __init__ , no object ). Link class methods from table to their documentation. Might not handle decorators neatly. Docstring Issues Some caveats: Do not use \"\"\" for anything other than docstrings. First line of any docstring has to contain the first short title ( example ). Classes have to be structured new-style: class SomeClass(object): . Codeblocks in examples have to be vanilla Python ( >>> and ... ). Please do not use class as a parameter name! Notes Script has only been tested with Python 3.4 on Ubuntu.","title":"MarkDoc"},{"location":"scripts/markdoc/#markdoc","text":"This piece of code can be used to convert NumPy-styled Python docstrings ( example ), such as those used in scikit-learn , to Markdown with minimum dependencies. In this way, only the code-contained documentation needs to be editted, and your documentation on for example readthedocs can be automatically updated thereafter with some configuration.","title":"MarkDoc"},{"location":"scripts/markdoc/#example","text":"The converted documentation for this particular code can be found here .","title":"Example"},{"location":"scripts/markdoc/#before-use","text":"The format assumes that your code (or at least your docstring documentation) is in line with the styleguides of both PEP8 and PEP257. There are two ways to go about making sure this is the case:","title":"Before Use"},{"location":"scripts/markdoc/#fast","text":"Just check the example here to get a quick overview of how the docstrings would have to look in order for them to parse correctly.","title":"Fast"},{"location":"scripts/markdoc/#better","text":"The styleguides are incorporated into two libraries that can be used to check the Python files for style errors in terminal, like so: pip install pep8 pip install pep257 pep8 yourpythonfile.py pep257 yourpythonfile.py These are more conveniently implemented in linter plugins such as linter-pep8 and linter-pep257 for the linter package in Atom , and Flake8Lint for Sublime Text (and pretty much every other IDE).","title":"Better"},{"location":"scripts/markdoc/#usage","text":"First clone from GitHub: git clone https://www.github.com/cmry/markdoc To use the script within terminal, simply type: python3 markdoc.py /dir/to/somefile.py /dir/to/somedoc.md If you want to automatically generate a bunch of documentation and are not comfortable with writing .sh scripts, you can use the code in Python as well: from markdoc import MarkDoc md = MarkDoc('/dir/to/somefile.py', '/dir/to/somedoc.md') You can access the converted markdown string in: # print markdown from class attribute print(md.markdown) The class runs itself on initialization (calls self.read ). If you do not want this, you can add cold=True to the class initialization, like so: md = MarkDoc('file.py', 'doc.md', cold=True)","title":"Usage"},{"location":"scripts/markdoc/#planned-fixes","text":"Handle consecutive classes within the same file. Fix inherrited classes being handled correctly (no __init__ , no object ). Link class methods from table to their documentation. Might not handle decorators neatly.","title":"Planned Fixes"},{"location":"scripts/markdoc/#docstring-issues","text":"Some caveats: Do not use \"\"\" for anything other than docstrings. First line of any docstring has to contain the first short title ( example ). Classes have to be structured new-style: class SomeClass(object): . Codeblocks in examples have to be vanilla Python ( >>> and ... ). Please do not use class as a parameter name!","title":"Docstring Issues"},{"location":"scripts/markdoc/#notes","text":"Script has only been tested with Python 3.4 on Ubuntu.","title":"Notes"},{"location":"scripts/markdoc/markdoc/","text":"Docstring to Markdown This piece of code is used within Shed (https://www.github.com/cmry/shed) to convert sklearn-styled python docstrings to markdown. In this way, only the code documentation needs to be editted, and the readthedocs is automatically updated thereafter. To use it, simply type python3 markdoc.py somefile.py somedoc.md . Check class help for python usage. Don't forget to also check the class notes (they are important for docstring format guidelines). MarkDoc class MarkDoc(file_in, file_out, cold=False) Documentation to Markdown. This class converts a python file with properly formed sklearn-style docstrings to a markdown file that can be used in for example Readthedocs or jekyll. Parameters Type Doc file_in str Python (.py) file from where the docstrings should be taken. file_out str Markdown (.md) file where the documentation should be written. cold boolean, optional, default False If you want to start the class without starting the reader, set True. Attributes Type Doc markdown str The entire markdown file that will be appended to and written out. Examples Use of the package should just be from commandline with python3 markdoc.py in.py out.md . However, if for some reason it is required to load it as a class, you can just do: >>> from markdoc import MarkDoc >>> d2m = MarkDoc('some/dir/file.py', '/some/otherdir/doc.md') The string of the markdown can be accessed by: >>> print(d2m.markdown) Notes List of common errors and styleguide conflicts: list index out of range? \"\"\" used for non-docstring strings. First Class or method Documentation line has newline after \"\"\". Fix with: \"\"\"This is the first line. Here comes the rest. \"\"\" Class parameters not showing in code blocks? Class is not structed new-style (object after class). Code blocks not showing? Code is ipython style rather than vanilla (i.e. In [1]: instead of >>>). tuple index out of range? Mistake in var : type lists (for example var: type). Description also contains a :. some table parts are not showing? Probably included some seperators in there such as : or -----. methods are garbled? Did you name a parameter 'class' or any other matches? Methods method Doc read Open python code file, spit out markdown file. handle_classes Given class docs only, write out their docs and methods. find_declaration Find class Bla(object): or def method(params): across lines. structure_doc Produce a structured dictionary from docstring. md_title Handle title and text parts for main and class-specific. md_table Place parameters and attributes in a table overview. md_code_text Section text and/or code in the example part of the doc. md_class_method Replace class ...(object) with __init__ arguments. md_methods_doc Merge all method elements in one string. md_class_doc Merge all class section elements in one string. read read(file_in, file_out) Open python code file, spit out markdown file. handle_classes handle_classes(classes) Given class docs only, write out their docs and methods. find_declaration find_declaration(lines) Find class Bla(object): or def method(params): across lines. structure_doc structure_doc(doc) Produce a structured dictionary from docstring. The key is the part of the documentation (name, title, params, attributes, etc.), and value is a list of lines that make up this part. Is used to handle the order and different parses of different sections. Parameters Type Doc doc str Flat string structure of a docstring block. Returns Type Doc X_doc dict Class or method doc, a structure dict with section; lines. md_title md_title(title_part, class_line=False) Handle title and text parts for main and class-specific. Pretty convoluted but delicate method that seperates the top part that should not be part of the title docstring off the document, handles correct punctuation of titles, for both classes and methods. Also detects if there's a description under the first line. Parameters Type Doc title_part str Part of the document that starts with triple qutoes and is below any line seperators. class_line bool, optional, default False The first line of the docstring by default servers as a title header. However, for classes it should be formed into a normal description. Thefefore, the # marker is removed and a . is added. Returns Type Doc line_buffer str Correctly formated markdown from the buffer. md_table md_table(doc, name) Place parameters and attributes in a table overview. The documentation parts that are typed by 'var : type \\n description' can be splitted into a table. The same holds true for a list of class methods. These are handled by this method. Table structures are on the top of this python file. Parameters Type Doc doc str Flat string structure of a docstring block. name str Indicator for the table, can be for example Parameters or Attributes. Returns Type Doc table str Markdown-type table with filled rows and formatted name. md_code_text md_code_text(doc, name, flat=False) Section text and/or code in the example part of the doc. If some code related beginnings (>>>, ...) is founds buffer to code, else we regard it as text. Record order so that multiple consecutive blocks of text and code are possible. Parameters Type Doc doc str Flat string structure of a docstring block. name str Name of the section (Examples, Notes). flat bool, optional, default False If there are no code blocks, flat can be used to stop parsing them. Returns Type Doc code str Formatted block of fenced markdown code-snippets and flat text. Notes Please note that this method assumes markdown is uses so-called fenced codeblocks that are commonly accepted by Readthedocs, Github, Bitbucket, and Jekyll (for example with Redcarpet). This current implementation does NOT allow for ipython styled code examples. (In [1]: Out[1]: etc.) md_class_method md_class_method(doc, class_parts) Replace class ...(object) with __init__ arguments. In sklearn-style, each class is represented as it's name, along with the parameters accepted in __init__ as its parameters, as you would call the method in python. The markdown therefore needs to fill the (object) tag that is assigned to classes with the __init__ params. Parameters Type Doc doc str Flat string structure of a docstring block. class_parts list List with parts that the docstring constituted of. First line should be the class name and can therefore be replaced. Returns Type Doc doc str Same as doc, only now (object) has been replaced with __init__ parameters. Notes Please note that this implementation assumes you're using new-style class declarations where for example class SomeClass: should be written as class SomeClass(object): . md_methods_doc md_methods_doc(method_doc) Merge all method elements in one string. This method will scan each method docstring and extract parameters, returns and descriptions. It will append them to the method table and link them in the doc (TODO). Parameters Type Doc method_doc list Lower part of the class docstrings that holds a method docstring per entry. Returns Type Doc methods str Formatted markdown string with all method information. Notes On the bottom, dict calls are being done to order several parts of the docstring. If you use more than Parameters and Returns, please make sure they are added in the code there. md_class_doc md_class_doc(class_doc) Merge all class section elements in one string. This will piece together the descriptions contained in the docstring of the class. Currently, they are written below the top of the python file, and not put into any subfiles per class. Parameters Type Doc class_doc str Flat text containing the class docstring part. Returns Type Doc mark_doc str Markdown formatted class docstring, including all subsections. Notes On the bottom, dict calls are being done to order several parts of the docstring. If you use more than Parameters, Attributes, Examples, and Notes, please make sure they are added in the code there.","title":"Docstring to Markdown"},{"location":"scripts/markdoc/markdoc/#docstring-to-markdown","text":"This piece of code is used within Shed (https://www.github.com/cmry/shed) to convert sklearn-styled python docstrings to markdown. In this way, only the code documentation needs to be editted, and the readthedocs is automatically updated thereafter. To use it, simply type python3 markdoc.py somefile.py somedoc.md . Check class help for python usage. Don't forget to also check the class notes (they are important for docstring format guidelines).","title":"Docstring to Markdown"},{"location":"scripts/markdoc/markdoc/#markdoc","text":"class MarkDoc(file_in, file_out, cold=False) Documentation to Markdown. This class converts a python file with properly formed sklearn-style docstrings to a markdown file that can be used in for example Readthedocs or jekyll. Parameters Type Doc file_in str Python (.py) file from where the docstrings should be taken. file_out str Markdown (.md) file where the documentation should be written. cold boolean, optional, default False If you want to start the class without starting the reader, set True. Attributes Type Doc markdown str The entire markdown file that will be appended to and written out.","title":"MarkDoc"},{"location":"scripts/markdoc/markdoc/#examples","text":"Use of the package should just be from commandline with python3 markdoc.py in.py out.md . However, if for some reason it is required to load it as a class, you can just do: >>> from markdoc import MarkDoc >>> d2m = MarkDoc('some/dir/file.py', '/some/otherdir/doc.md') The string of the markdown can be accessed by: >>> print(d2m.markdown)","title":"Examples"},{"location":"scripts/markdoc/markdoc/#notes","text":"List of common errors and styleguide conflicts:","title":"Notes"},{"location":"scripts/markdoc/markdoc/#list-index-out-of-range","text":"\"\"\" used for non-docstring strings. First Class or method Documentation line has newline after \"\"\". Fix with: \"\"\"This is the first line. Here comes the rest. \"\"\"","title":"list index out of range?"},{"location":"scripts/markdoc/markdoc/#class-parameters-not-showing-in-code-blocks","text":"Class is not structed new-style (object after class).","title":"Class parameters not showing in code blocks?"},{"location":"scripts/markdoc/markdoc/#code-blocks-not-showing","text":"Code is ipython style rather than vanilla (i.e. In [1]: instead of >>>).","title":"Code blocks not showing?"},{"location":"scripts/markdoc/markdoc/#tuple-index-out-of-range","text":"Mistake in var : type lists (for example var: type). Description also contains a :.","title":"tuple index out of range?"},{"location":"scripts/markdoc/markdoc/#some-table-parts-are-not-showing","text":"Probably included some seperators in there such as : or -----.","title":"some table parts are not showing?"},{"location":"scripts/markdoc/markdoc/#methods-are-garbled","text":"Did you name a parameter 'class' or any other matches?","title":"methods are garbled?"},{"location":"scripts/markdoc/markdoc/#methods","text":"method Doc read Open python code file, spit out markdown file. handle_classes Given class docs only, write out their docs and methods. find_declaration Find class Bla(object): or def method(params): across lines. structure_doc Produce a structured dictionary from docstring. md_title Handle title and text parts for main and class-specific. md_table Place parameters and attributes in a table overview. md_code_text Section text and/or code in the example part of the doc. md_class_method Replace class ...(object) with __init__ arguments. md_methods_doc Merge all method elements in one string. md_class_doc Merge all class section elements in one string.","title":"Methods"},{"location":"scripts/markdoc/markdoc/#read","text":"read(file_in, file_out) Open python code file, spit out markdown file.","title":"read"},{"location":"scripts/markdoc/markdoc/#handle_classes","text":"handle_classes(classes) Given class docs only, write out their docs and methods.","title":"handle_classes"},{"location":"scripts/markdoc/markdoc/#find_declaration","text":"find_declaration(lines) Find class Bla(object): or def method(params): across lines.","title":"find_declaration"},{"location":"scripts/markdoc/markdoc/#structure_doc","text":"structure_doc(doc) Produce a structured dictionary from docstring. The key is the part of the documentation (name, title, params, attributes, etc.), and value is a list of lines that make up this part. Is used to handle the order and different parses of different sections. Parameters Type Doc doc str Flat string structure of a docstring block. Returns Type Doc X_doc dict Class or method doc, a structure dict with section; lines.","title":"structure_doc"},{"location":"scripts/markdoc/markdoc/#md_title","text":"md_title(title_part, class_line=False) Handle title and text parts for main and class-specific. Pretty convoluted but delicate method that seperates the top part that should not be part of the title docstring off the document, handles correct punctuation of titles, for both classes and methods. Also detects if there's a description under the first line. Parameters Type Doc title_part str Part of the document that starts with triple qutoes and is below any line seperators. class_line bool, optional, default False The first line of the docstring by default servers as a title header. However, for classes it should be formed into a normal description. Thefefore, the # marker is removed and a . is added. Returns Type Doc line_buffer str Correctly formated markdown from the buffer.","title":"md_title"},{"location":"scripts/markdoc/markdoc/#md_table","text":"md_table(doc, name) Place parameters and attributes in a table overview. The documentation parts that are typed by 'var : type \\n description' can be splitted into a table. The same holds true for a list of class methods. These are handled by this method. Table structures are on the top of this python file. Parameters Type Doc doc str Flat string structure of a docstring block. name str Indicator for the table, can be for example Parameters or Attributes. Returns Type Doc table str Markdown-type table with filled rows and formatted name.","title":"md_table"},{"location":"scripts/markdoc/markdoc/#md_code_text","text":"md_code_text(doc, name, flat=False) Section text and/or code in the example part of the doc. If some code related beginnings (>>>, ...) is founds buffer to code, else we regard it as text. Record order so that multiple consecutive blocks of text and code are possible. Parameters Type Doc doc str Flat string structure of a docstring block. name str Name of the section (Examples, Notes). flat bool, optional, default False If there are no code blocks, flat can be used to stop parsing them. Returns Type Doc code str Formatted block of fenced markdown code-snippets and flat text.","title":"md_code_text"},{"location":"scripts/markdoc/markdoc/#notes_1","text":"Please note that this method assumes markdown is uses so-called fenced codeblocks that are commonly accepted by Readthedocs, Github, Bitbucket, and Jekyll (for example with Redcarpet). This current implementation does NOT allow for ipython styled code examples. (In [1]: Out[1]: etc.)","title":"Notes"},{"location":"scripts/markdoc/markdoc/#md_class_method","text":"md_class_method(doc, class_parts) Replace class ...(object) with __init__ arguments. In sklearn-style, each class is represented as it's name, along with the parameters accepted in __init__ as its parameters, as you would call the method in python. The markdown therefore needs to fill the (object) tag that is assigned to classes with the __init__ params. Parameters Type Doc doc str Flat string structure of a docstring block. class_parts list List with parts that the docstring constituted of. First line should be the class name and can therefore be replaced. Returns Type Doc doc str Same as doc, only now (object) has been replaced with __init__ parameters.","title":"md_class_method"},{"location":"scripts/markdoc/markdoc/#notes_2","text":"Please note that this implementation assumes you're using new-style class declarations where for example class SomeClass: should be written as class SomeClass(object): .","title":"Notes"},{"location":"scripts/markdoc/markdoc/#md_methods_doc","text":"md_methods_doc(method_doc) Merge all method elements in one string. This method will scan each method docstring and extract parameters, returns and descriptions. It will append them to the method table and link them in the doc (TODO). Parameters Type Doc method_doc list Lower part of the class docstrings that holds a method docstring per entry. Returns Type Doc methods str Formatted markdown string with all method information.","title":"md_methods_doc"},{"location":"scripts/markdoc/markdoc/#notes_3","text":"On the bottom, dict calls are being done to order several parts of the docstring. If you use more than Parameters and Returns, please make sure they are added in the code there.","title":"Notes"},{"location":"scripts/markdoc/markdoc/#md_class_doc","text":"md_class_doc(class_doc) Merge all class section elements in one string. This will piece together the descriptions contained in the docstring of the class. Currently, they are written below the top of the python file, and not put into any subfiles per class. Parameters Type Doc class_doc str Flat text containing the class docstring part. Returns Type Doc mark_doc str Markdown formatted class docstring, including all subsections.","title":"md_class_doc"},{"location":"scripts/markdoc/markdoc/#notes_4","text":"On the bottom, dict calls are being done to order several parts of the docstring. If you use more than Parameters, Attributes, Examples, and Notes, please make sure they are added in the code there.","title":"Notes"}]}