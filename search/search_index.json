{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"py_cui A py thon library for creating c ommand line u ser i nterfaces. What is py_cui? py_cui is a python library meant to simplify writing command line user interfaces in python. It relies on the curses module, which is traditionally a unix-specific python module, however, I was able to use the windows-curses module to run py_cui on windows. The main advantage py_cui has over traditional command line user interfaces is that it relies on widgets and a grid layout manager like most traditional Graphical User Interfaces. You may define a grid size, and then drop predefined widgets onto it into specific grid locations. Widgets can also be stretched accross multiple grid rows and columns. If you've ever made a Tkinter GUI, you will feel right at home. Writing a PyCUI Basic usage of py_cui starts with creating a PyCUI object, and specifiying it's grid size. Keep in mind that grid cell height and width will be measured in terminal characters, not pixels, so there is a lower limit on legal grid size, and heights will be smaller values than widths. Create this object with: root = py_cui.PyCUI(7, 9) The above line will create a UI with 7 rows and 9 columns. Then, add widgets with the different add commands: label = root.add_label('Label Text', 0, 0) button = root.add_button('Button Text', 1, 2, column_span=2, command=my_function) ... Finally, start the CUI with root.start() py_cui has support for custom key bindings for both the overview mode and focused mode, popup windows and prompts, color rendering rules, and several useful widgets. For more details on writing py_cui based interfaces, be sure to check on the examples and the documentation here . Using a PyCUI There are some basic rules that apply to all py_cui based interfaces. There are three key operating modes - overview mode, focus mode, and popup mode. Overview Mode Overview mode is the main control view of the interface. In this mode you use the arrow keys to move between widgets, and you may select widgets with the Enter key. By default, you may also press buttons in this mode, unless auto_focus_buttons is set to false when the CUI was created. Focus Mode When in focus mode, you enter into a particular widget (For example a text box.). Each widget has some predefined basic controls, such as arrow keys to scroll in a ScrollMenu . You may also add keybindings to functions for each particular widget. These keybindings will only apply to a widget if it is in focus mode. Enter focus mode by navigating to a widget in overview mode and hitting the Enter key. Return to overview mode from focus mode by pressing Escape . Popup Mode Popup mode simply displays a popup over the rest of the UI. Each popup type behaves slightly differently. For example, you may exit an info popup mode by pressing Space , Enter , or Escape , while a loading popup will remain onscreen until whatever operation is being run is terminated.","title":"Home"},{"location":"#py_cui","text":"A py thon library for creating c ommand line u ser i nterfaces.","title":"py_cui"},{"location":"#what-is-py_cui","text":"py_cui is a python library meant to simplify writing command line user interfaces in python. It relies on the curses module, which is traditionally a unix-specific python module, however, I was able to use the windows-curses module to run py_cui on windows. The main advantage py_cui has over traditional command line user interfaces is that it relies on widgets and a grid layout manager like most traditional Graphical User Interfaces. You may define a grid size, and then drop predefined widgets onto it into specific grid locations. Widgets can also be stretched accross multiple grid rows and columns. If you've ever made a Tkinter GUI, you will feel right at home.","title":"What is py_cui?"},{"location":"#writing-a-pycui","text":"Basic usage of py_cui starts with creating a PyCUI object, and specifiying it's grid size. Keep in mind that grid cell height and width will be measured in terminal characters, not pixels, so there is a lower limit on legal grid size, and heights will be smaller values than widths. Create this object with: root = py_cui.PyCUI(7, 9) The above line will create a UI with 7 rows and 9 columns. Then, add widgets with the different add commands: label = root.add_label('Label Text', 0, 0) button = root.add_button('Button Text', 1, 2, column_span=2, command=my_function) ... Finally, start the CUI with root.start() py_cui has support for custom key bindings for both the overview mode and focused mode, popup windows and prompts, color rendering rules, and several useful widgets. For more details on writing py_cui based interfaces, be sure to check on the examples and the documentation here .","title":"Writing a PyCUI"},{"location":"#using-a-pycui","text":"There are some basic rules that apply to all py_cui based interfaces. There are three key operating modes - overview mode, focus mode, and popup mode. Overview Mode Overview mode is the main control view of the interface. In this mode you use the arrow keys to move between widgets, and you may select widgets with the Enter key. By default, you may also press buttons in this mode, unless auto_focus_buttons is set to false when the CUI was created. Focus Mode When in focus mode, you enter into a particular widget (For example a text box.). Each widget has some predefined basic controls, such as arrow keys to scroll in a ScrollMenu . You may also add keybindings to functions for each particular widget. These keybindings will only apply to a widget if it is in focus mode. Enter focus mode by navigating to a widget in overview mode and hitting the Enter key. Return to overview mode from focus mode by pressing Escape . Popup Mode Popup mode simply displays a popup over the rest of the UI. Each popup type behaves slightly differently. For example, you may exit an info popup mode by pressing Space , Enter , or Escape , while a loading popup will remain onscreen until whatever operation is being run is terminated.","title":"Using a PyCUI"},{"location":"about/","text":"About csplit Primary Author Jakub Wlodek Created on August 12, 2019 Contributing Authors Maciej Wlodek License BSD 3-Clause License Copyright (c) 2019, Jakub Wlodek All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"About"},{"location":"about/#about-csplit","text":"","title":"About csplit"},{"location":"about/#primary-author","text":"Jakub Wlodek Created on August 12, 2019","title":"Primary Author"},{"location":"about/#contributing-authors","text":"Maciej Wlodek","title":"Contributing Authors"},{"location":"about/#license","text":"BSD 3-Clause License Copyright (c) 2019, Jakub Wlodek All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"developers/","text":"Documentation for py_cui Developers This page contains information on writing new widgets and popups, as well as anything else required for developers and contributors for py_cui. Adding a new Widget We will walk through the steps of adding a new widget to py_cui (in this case a scroll menu) in order to demonstrate this process. Step One - Extend the Widget Class Your first step when writing a new widget is to create a class in py_cui/widgets.py that extends the base Widget class. For our ScrollMenu example: class ScrollMenu(Widget): def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) def draw(self): super().draw() The handle_key_press and draw functions must be extended for your new widget. You may leave the handle_key_press as above, if you don't require any keybindings for the widget. The draw function must extended, as the base class does no drawing itself, instead just setting up color rules. Step Two - Add additional class variables Next, add any variables that your widget may require on top of the base Widget class variables. In our case, it will be the selected item index, a list of menu items, and an integer representing the top item visible (in case the menu scrolls down). We also add some functions for getting and setting these variables. def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) self.top_view = 0 self.selected_item = 0 self.view_items = [] def clear(self): \"\"\" Clears all items from the Scroll Menu \"\"\" self.view_items = [] self.selected_item = 0 self.top_view = 0 def add_item_list(self, item_list): for item in item_list: self.add_item(item) def remove_selected_item(self): if len(self.view_items) == 0: return del self.view_items[self.selected_item] if self.selected_item >= len(self.view_items): self.selected_item = self.selected_item - 1 def get_item_list(self): return self.view_items def get(self): if len(self.view_items) > 0: return self.view_items[self.selected_item] return None Step 3 - Add Key Bindings Next, add any default key bindings you wish to have for the widget when in focus mode. In the case of the scroll menu, we wish for the arrow keys to scroll up and down, so we extend the handle_key_press function: def scroll_up(self): if self.selected: if self.top_view > 0: self.top_view = self.top_view - 1 if self.selected_item > 0: self.selected_item = self.selected_item - 1 def scroll_down(self): if self.selected: if self.selected_item < len(self.view_items) - 1: self.selected_item = self.selected_item + 1 if self.selected_item > self.top_view + self.height - (2 * self.pady) - 3: self.top_view = self.top_view + 1 def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) if key_pressed == py_cui.keys.KEY_UP_ARROW: self.scroll_up() if key_pressed == py_cui.keys.KEY_DOWN_ARROW: self.scroll_down() Note that the way default key bindings are added are simply if statements, which happen after the super() call. The scroll_up() and scroll_down() functions simply contain the logic for editing the viewport for the menu. Step 4 - implement the Draw function In the draw function, you must use the self.renderer object to render your widget to the screen. In our case, we want a border around the menu widget, and we also want to draw menu items that are within our viewport. The key renderer functions we will use are: self.renderer.draw_border(self) which will draw a border around the widget space, and self.renderer.draw_text(self, text, y_position) which will draw the text in the y_position. For our scroll menu, we would write the following: def draw(self): super().draw() # sets the color mode self.renderer.set_color_mode(self.color) # draws border around widget self.renderer.draw_border(self) # will store the current y-position counter = self.pady + 1 line_counter = 0 for line in self.view_items: # Until we reach viewport start, increment counter if line_counter < self.top_view: line_counter = line_counter + 1 else: if counter >= self.height - self.pady - 1: break if line_counter == self.selected_item: self.renderer.draw_text(self, line, self.start_y + counter, selected=True) else: self.renderer.draw_text(self, line, self.start_y + counter) counter = counter + 1 line_counter = line_counter + 1 # reset default colors self.renderer.unset_color_mode(self.color) # reset cursor should be called at the end of every draw function self.renderer.reset_cursor(self) Step 5 - add a function to __init__.py to add the widget Finally, add a function to __init__.py that will add the widget to the CUI. In our case we write the following: def add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0): id = 'Widget{}'.format(len(self.widgets.keys())) new_scroll_menu = widgets.ScrollMenu(id, title, self.grid, row, column, row_span, column_span, padx, pady) self.widgets[id] = new_scroll_menu if self.selected_widget is None: self.set_selected_widget(id) return new_scroll_menu The function must: * Create an id titled 'Widget####' where #### is replaced with the number of widget * Add the widget to the PyCUI widgets dict with the ID as a key * If there is no selected widget, make this new widget the selected one * Return a reference to the widget That's it! Your widget is now ready to be added to the CUI! Adding a new Popup This documentation section is incomplete. Feel free to expand me . Working on the renderer This documentation section is incomplete. Feel free to expand me . Working on color rules This documentation section is incomplete. Feel free to expand me .","title":"For py_cui developers"},{"location":"developers/#documentation-for-py_cui-developers","text":"This page contains information on writing new widgets and popups, as well as anything else required for developers and contributors for py_cui.","title":"Documentation for py_cui Developers"},{"location":"developers/#adding-a-new-widget","text":"We will walk through the steps of adding a new widget to py_cui (in this case a scroll menu) in order to demonstrate this process. Step One - Extend the Widget Class Your first step when writing a new widget is to create a class in py_cui/widgets.py that extends the base Widget class. For our ScrollMenu example: class ScrollMenu(Widget): def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) def draw(self): super().draw() The handle_key_press and draw functions must be extended for your new widget. You may leave the handle_key_press as above, if you don't require any keybindings for the widget. The draw function must extended, as the base class does no drawing itself, instead just setting up color rules. Step Two - Add additional class variables Next, add any variables that your widget may require on top of the base Widget class variables. In our case, it will be the selected item index, a list of menu items, and an integer representing the top item visible (in case the menu scrolls down). We also add some functions for getting and setting these variables. def __init__(self, id, title, grid, row, column, row_span, column_span, padx, pady): super().__init__(id, title, grid, row, column, row_span, column_span, padx, pady) self.top_view = 0 self.selected_item = 0 self.view_items = [] def clear(self): \"\"\" Clears all items from the Scroll Menu \"\"\" self.view_items = [] self.selected_item = 0 self.top_view = 0 def add_item_list(self, item_list): for item in item_list: self.add_item(item) def remove_selected_item(self): if len(self.view_items) == 0: return del self.view_items[self.selected_item] if self.selected_item >= len(self.view_items): self.selected_item = self.selected_item - 1 def get_item_list(self): return self.view_items def get(self): if len(self.view_items) > 0: return self.view_items[self.selected_item] return None Step 3 - Add Key Bindings Next, add any default key bindings you wish to have for the widget when in focus mode. In the case of the scroll menu, we wish for the arrow keys to scroll up and down, so we extend the handle_key_press function: def scroll_up(self): if self.selected: if self.top_view > 0: self.top_view = self.top_view - 1 if self.selected_item > 0: self.selected_item = self.selected_item - 1 def scroll_down(self): if self.selected: if self.selected_item < len(self.view_items) - 1: self.selected_item = self.selected_item + 1 if self.selected_item > self.top_view + self.height - (2 * self.pady) - 3: self.top_view = self.top_view + 1 def handle_key_press(self, key_pressed): super().handle_key_press(key_pressed) if key_pressed == py_cui.keys.KEY_UP_ARROW: self.scroll_up() if key_pressed == py_cui.keys.KEY_DOWN_ARROW: self.scroll_down() Note that the way default key bindings are added are simply if statements, which happen after the super() call. The scroll_up() and scroll_down() functions simply contain the logic for editing the viewport for the menu. Step 4 - implement the Draw function In the draw function, you must use the self.renderer object to render your widget to the screen. In our case, we want a border around the menu widget, and we also want to draw menu items that are within our viewport. The key renderer functions we will use are: self.renderer.draw_border(self) which will draw a border around the widget space, and self.renderer.draw_text(self, text, y_position) which will draw the text in the y_position. For our scroll menu, we would write the following: def draw(self): super().draw() # sets the color mode self.renderer.set_color_mode(self.color) # draws border around widget self.renderer.draw_border(self) # will store the current y-position counter = self.pady + 1 line_counter = 0 for line in self.view_items: # Until we reach viewport start, increment counter if line_counter < self.top_view: line_counter = line_counter + 1 else: if counter >= self.height - self.pady - 1: break if line_counter == self.selected_item: self.renderer.draw_text(self, line, self.start_y + counter, selected=True) else: self.renderer.draw_text(self, line, self.start_y + counter) counter = counter + 1 line_counter = line_counter + 1 # reset default colors self.renderer.unset_color_mode(self.color) # reset cursor should be called at the end of every draw function self.renderer.reset_cursor(self) Step 5 - add a function to __init__.py to add the widget Finally, add a function to __init__.py that will add the widget to the CUI. In our case we write the following: def add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0): id = 'Widget{}'.format(len(self.widgets.keys())) new_scroll_menu = widgets.ScrollMenu(id, title, self.grid, row, column, row_span, column_span, padx, pady) self.widgets[id] = new_scroll_menu if self.selected_widget is None: self.set_selected_widget(id) return new_scroll_menu The function must: * Create an id titled 'Widget####' where #### is replaced with the number of widget * Add the widget to the PyCUI widgets dict with the ID as a key * If there is no selected widget, make this new widget the selected one * Return a reference to the widget That's it! Your widget is now ready to be added to the CUI!","title":"Adding a new Widget"},{"location":"developers/#adding-a-new-popup","text":"This documentation section is incomplete. Feel free to expand me .","title":"Adding a new Popup"},{"location":"developers/#working-on-the-renderer","text":"This documentation section is incomplete. Feel free to expand me .","title":"Working on the renderer"},{"location":"developers/#working-on-color-rules","text":"This documentation section is incomplete. Feel free to expand me .","title":"Working on color rules"},{"location":"examples/","text":"py_cui Examples There are several examples of simple py_cui programs you can find in the examples directory of the github repository. In addition, a larger python module pyautogit was written with py_cui , and is available for download using pip or from github. In this section of the documentation we will explain the source code for some of the supplied examples in more detail. Hello py_cui! As is tradition with programming, we start with our Hello World example. Here we simply create a PyCUI object with a grid size of 3 x 3, and we add a Label into the center grid space. This is the most basic py_cui you can create. # Import the lib import py_cui # create the CUI object. Will have a 3 by 3 grid with indexes from 0,0 to 2,2 root = py_cui.PyCUI(3,3) # Add a label to the center of the CUI in the 1,1 grid position root.add_label('Hello py_cui!!!', 1, 1) # Start/Render the CUI root.start() Simple Todo List A simple usage of py_cui for creating a terminal todo list. We use keybindings to get control of each of our lists as well as our text entry import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Keybindings for controlling our CUI. # We bind the enter key for each of the widgets self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Popups Example This example will demonstrate the usage for using all supported popups. # imports import py_cui import time import os import threading # We will need the threading library when we want to use the loading popups class PopupExample: def __init__(self, master): # This is a reference to our top level CUI object self.master = master # buttons for control - each simply spawns the linked popup self.show_message_popup = self.master.add_button('Show Message Popup', 0, 0, command=self.show_message) self.show_yes_no_popup = self.master.add_button('Show Yes No Popup', 1, 0, command=self.show_yes_no) self.show_loading_icon_popup = self.master.add_button('Show Loading Icon Popup', 2, 0, command=self.show_loading_icon) self.show_loading_bar_popup = self.master.add_button('Show Loading Bar Popup', 0,1, command = self.show_loading_bar) self.show_text_box_popup = self.master.add_button('Show Text Box Popup', 1,1, command = self.show_text_box) self.show_menu_popup = self.master.add_button('Show Scroll Menu Popup', 2,1, command = self.show_menu_popup_fun) def show_message(self): \"\"\" Displays a simple message popup \"\"\" self.master.show_message_popup('Hello!', 'This is a message popup. You can also spawn warnings and errors.') ################################################ # YES NO POPUP def quit_cui(self, to_quit): # THis is the function given to the yes no popup. The to_quit parameter will be true if y is pressed, or False if n is pressed if to_quit: exit() else: self.master.show_message_popup('Cancelled', 'The quit operation was cancelled.') def show_yes_no(self): \"\"\" Displays a yes no popup asking if the user would like to quit \"\"\" # For the yes/no popup, the 'command' parameter must take a function that requires a single boolean parameter self.master.show_yes_no_popup('Are you sure you want to quit?', self.quit_cui) ################################################ ################################################ # TEXTBOX POPUP def reset_title(self, new_title): self.master.title = new_title def show_text_box(self): \"\"\" Displays a textbox popup asking the user for a new window title \"\"\" # A textbox popup requires a prompt and a function reference. The function must take a single string parameter that will return # whatever is within the text box when the ENTER key is pressed self.master.show_text_box_popup('Please enter a new window title', self.reset_title) ################################################ ################################################ # SCROLL MENU POPUP def change_button_color(self, new_color): \"\"\" Function called when ENTER pressed in menu popup. Takes string as parameter \"\"\" color = py_cui.WHITE_ON_BLACK if new_color == \"RED\": color = py_cui.RED_ON_BLACK elif new_color == \"CYAN\": color = py_cui.CYAN_ON_BLACK elif new_color == \"MAGENTA\": color = py_cui.MAGENTA_ON_BLACK for key in self.master.widgets.keys(): if isinstance(self.master.widgets[key], py_cui.widgets.Button): self.master.widgets[key].color = color def show_menu_popup_fun(self): \"\"\" Opens scroll menu for selecting button colors \"\"\" # Spawning a menu popup must recieve a list of strings as menu options, and a function reference that takes a string parameter menu_choices = ['RED', 'CYAN', 'MAGENTA'] self.master.show_menu_popup('Please select a new button color', menu_choices, self.change_button_color) ################################################ def show_loading_icon(self): \"\"\" Function that shows the usage for spwaning a loading icon popup \"\"\" # The loading popup will remain onscreen until the stop loading function is called. Call this before a large operation, and call # stop after the operation is finished. Note that for these long operations, you must use a different thread # to not block the draw calls. self.master.show_loading_icon_popup('Please Wait', 'Loading') operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def show_loading_bar(self): \"\"\" Function that shows the usage for spawning a loading bar popup \"\"\" self.master.show_loading_bar_popup('Incrementing a counter...', 100) operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def long_operation(self): \"\"\" A simple function that demonstrates a long callback operation performed while loading popup is open \"\"\" counter = 0 for i in range(0, 100): time.sleep(0.1) counter= counter +1 self.master.status_bar.set_text(str(counter)) # When using a bar indicator, we will increment the completed counter. Will be ignored for loading icon popup self.master.increment_loading_bar() # This is what stops the loading popup and reenters overview mode self.master.stop_loading_popup() # Create the CUI, pass it to the wrapper object, and start it root = py_cui.PyCUI(3, 2) root.set_title('CUI Popups Example') s = PopupExample(root) root.start() Other examples Other examples are available in the examples directory in the repository on github. For a larger example of a project using py_cui , see pyautogit .","title":"Examples"},{"location":"examples/#py_cui-examples","text":"There are several examples of simple py_cui programs you can find in the examples directory of the github repository. In addition, a larger python module pyautogit was written with py_cui , and is available for download using pip or from github. In this section of the documentation we will explain the source code for some of the supplied examples in more detail.","title":"py_cui Examples"},{"location":"examples/#hello-py_cui","text":"As is tradition with programming, we start with our Hello World example. Here we simply create a PyCUI object with a grid size of 3 x 3, and we add a Label into the center grid space. This is the most basic py_cui you can create. # Import the lib import py_cui # create the CUI object. Will have a 3 by 3 grid with indexes from 0,0 to 2,2 root = py_cui.PyCUI(3,3) # Add a label to the center of the CUI in the 1,1 grid position root.add_label('Hello py_cui!!!', 1, 1) # Start/Render the CUI root.start()","title":"Hello py_cui!"},{"location":"examples/#simple-todo-list","text":"A simple usage of py_cui for creating a terminal todo list. We use keybindings to get control of each of our lists as well as our text entry import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Keybindings for controlling our CUI. # We bind the enter key for each of the widgets self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start()","title":"Simple Todo List"},{"location":"examples/#popups-example","text":"This example will demonstrate the usage for using all supported popups. # imports import py_cui import time import os import threading # We will need the threading library when we want to use the loading popups class PopupExample: def __init__(self, master): # This is a reference to our top level CUI object self.master = master # buttons for control - each simply spawns the linked popup self.show_message_popup = self.master.add_button('Show Message Popup', 0, 0, command=self.show_message) self.show_yes_no_popup = self.master.add_button('Show Yes No Popup', 1, 0, command=self.show_yes_no) self.show_loading_icon_popup = self.master.add_button('Show Loading Icon Popup', 2, 0, command=self.show_loading_icon) self.show_loading_bar_popup = self.master.add_button('Show Loading Bar Popup', 0,1, command = self.show_loading_bar) self.show_text_box_popup = self.master.add_button('Show Text Box Popup', 1,1, command = self.show_text_box) self.show_menu_popup = self.master.add_button('Show Scroll Menu Popup', 2,1, command = self.show_menu_popup_fun) def show_message(self): \"\"\" Displays a simple message popup \"\"\" self.master.show_message_popup('Hello!', 'This is a message popup. You can also spawn warnings and errors.') ################################################ # YES NO POPUP def quit_cui(self, to_quit): # THis is the function given to the yes no popup. The to_quit parameter will be true if y is pressed, or False if n is pressed if to_quit: exit() else: self.master.show_message_popup('Cancelled', 'The quit operation was cancelled.') def show_yes_no(self): \"\"\" Displays a yes no popup asking if the user would like to quit \"\"\" # For the yes/no popup, the 'command' parameter must take a function that requires a single boolean parameter self.master.show_yes_no_popup('Are you sure you want to quit?', self.quit_cui) ################################################ ################################################ # TEXTBOX POPUP def reset_title(self, new_title): self.master.title = new_title def show_text_box(self): \"\"\" Displays a textbox popup asking the user for a new window title \"\"\" # A textbox popup requires a prompt and a function reference. The function must take a single string parameter that will return # whatever is within the text box when the ENTER key is pressed self.master.show_text_box_popup('Please enter a new window title', self.reset_title) ################################################ ################################################ # SCROLL MENU POPUP def change_button_color(self, new_color): \"\"\" Function called when ENTER pressed in menu popup. Takes string as parameter \"\"\" color = py_cui.WHITE_ON_BLACK if new_color == \"RED\": color = py_cui.RED_ON_BLACK elif new_color == \"CYAN\": color = py_cui.CYAN_ON_BLACK elif new_color == \"MAGENTA\": color = py_cui.MAGENTA_ON_BLACK for key in self.master.widgets.keys(): if isinstance(self.master.widgets[key], py_cui.widgets.Button): self.master.widgets[key].color = color def show_menu_popup_fun(self): \"\"\" Opens scroll menu for selecting button colors \"\"\" # Spawning a menu popup must recieve a list of strings as menu options, and a function reference that takes a string parameter menu_choices = ['RED', 'CYAN', 'MAGENTA'] self.master.show_menu_popup('Please select a new button color', menu_choices, self.change_button_color) ################################################ def show_loading_icon(self): \"\"\" Function that shows the usage for spwaning a loading icon popup \"\"\" # The loading popup will remain onscreen until the stop loading function is called. Call this before a large operation, and call # stop after the operation is finished. Note that for these long operations, you must use a different thread # to not block the draw calls. self.master.show_loading_icon_popup('Please Wait', 'Loading') operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def show_loading_bar(self): \"\"\" Function that shows the usage for spawning a loading bar popup \"\"\" self.master.show_loading_bar_popup('Incrementing a counter...', 100) operation_thread = threading.Thread(target=self.long_operation) operation_thread.start() def long_operation(self): \"\"\" A simple function that demonstrates a long callback operation performed while loading popup is open \"\"\" counter = 0 for i in range(0, 100): time.sleep(0.1) counter= counter +1 self.master.status_bar.set_text(str(counter)) # When using a bar indicator, we will increment the completed counter. Will be ignored for loading icon popup self.master.increment_loading_bar() # This is what stops the loading popup and reenters overview mode self.master.stop_loading_popup() # Create the CUI, pass it to the wrapper object, and start it root = py_cui.PyCUI(3, 2) root.set_title('CUI Popups Example') s = PopupExample(root) root.start()","title":"Popups Example"},{"location":"examples/#other-examples","text":"Other examples are available in the examples directory in the repository on github. For a larger example of a project using py_cui , see pyautogit .","title":"Other examples"},{"location":"functions/","text":"Functions supported in py_cui This documentation section is incomplete. Feel free to expand me .","title":"Functions"},{"location":"functions/#functions-supported-in-py_cui","text":"This documentation section is incomplete. Feel free to expand me .","title":"Functions supported in py_cui"},{"location":"install/","text":"Installation The easiest way to install py_cui is to use pip . You may simply run: pip install py_cui and the library should install along with all dependancies. If you are working on a machine where pip defaults to the Python 2 version, replace pip with pip3 . There is no Python 2 support for py_cui , you will need a version of Python 3.4+ in order to use it. It may function with lower versions of Python 3, but it has not been tested on them. Alternatively, if you wish to avoid using pip, you may install from this repository: git clone https://github.com/jwlodek/py_cui cd py_cui pip install . This will use pip to install from the sources in the git repository. If you wish to avoid installing altogether, you may copy an example from the examples/ directory into the root py_cui directory, and run it with python3. Note that in this case you are required to install the dependancies yourself, which are curses on UNIX (should be included with python3) and windows-curses on windows, which can be installed with pip . Running Unit Tests Unit tests for py_cui are written for pytest. Simply clone the repository, and run pytest in the root directory: git clone https://github.com/jwlodek/py_cui cd py_cui pytest These tests are also run on Travis-CI each time a new commit is pushed to the upstream repository. Running Examples To run examples, install py_cui, enter the examples/ directory, and run them with python3. For example, to run todo_list_example.py : cd examples python3 todo_list_example.py Feel free to take a look at the Examples section of this documentation for more details.","title":"Installation"},{"location":"install/#installation","text":"The easiest way to install py_cui is to use pip . You may simply run: pip install py_cui and the library should install along with all dependancies. If you are working on a machine where pip defaults to the Python 2 version, replace pip with pip3 . There is no Python 2 support for py_cui , you will need a version of Python 3.4+ in order to use it. It may function with lower versions of Python 3, but it has not been tested on them. Alternatively, if you wish to avoid using pip, you may install from this repository: git clone https://github.com/jwlodek/py_cui cd py_cui pip install . This will use pip to install from the sources in the git repository. If you wish to avoid installing altogether, you may copy an example from the examples/ directory into the root py_cui directory, and run it with python3. Note that in this case you are required to install the dependancies yourself, which are curses on UNIX (should be included with python3) and windows-curses on windows, which can be installed with pip .","title":"Installation"},{"location":"install/#running-unit-tests","text":"Unit tests for py_cui are written for pytest. Simply clone the repository, and run pytest in the root directory: git clone https://github.com/jwlodek/py_cui cd py_cui pytest These tests are also run on Travis-CI each time a new commit is pushed to the upstream repository.","title":"Running Unit Tests"},{"location":"install/#running-examples","text":"To run examples, install py_cui, enter the examples/ directory, and run them with python3. For example, to run todo_list_example.py : cd examples python3 todo_list_example.py Feel free to take a look at the Examples section of this documentation for more details.","title":"Running Examples"},{"location":"keybindings/","text":"Keybindings Almost all CUI elements in py_cui support some degree of keybindings. The order in which these keybindings are executed depend on the order they are added, however, user keybindings are always executed prior to default keybindings, so make sure you don't unintentionally override an already bound key. Lists of default keybindings for each widget are available in the Widgets section of this documentation, and a list of default keybindings for overview mode is found in the Usage section. Adding a Keybinding For all keybindings, you must pass a py_cui key and a function with no arguments. This function will be fired when the key bound to it is detected. The function may also be a class funciton, with self.FUNCTION being passed into the add keybinding function. Make sure to take a look at the examples for more uses of keybindings. Overview Mode To add a keybinding to overview mode, you need to add it to the PyCUI object itself. For example, if I wanted to add a binding for the c key to clear all text fields in my cui : # import the library import py_cui # Create the PyCUI and add a text field root = py_cui.PyCUI(3, 3) text_field = root.add_text_box('Text Field', 1, 1) # This function simply clears the text in the text field def clear_text_field(): text_field.clear() # Add the key binding to the PyCUI object itself for overview mode. root.add_key_binding(py_cui.keys.KEY_C_LOWER, clear_text_field) # Start the CUI root.start() Focus Mode Adding keybindings to focus mode is done at a widget by widget basis. When a widget is added to the PyCUI , the returned object is used to add a key command. Once again, make sure to check default key bindings that should only be overridden if the user specifically desires to replace their functionality. For example, in a menu widget, if we wish to set the window title to the selected menu item with the t key, we could write the following: # import the library import py_cui # Create the CUI object root = py_cui.PyCUI(3,3) # Add the scroll menu with the three menu items menu_items = ['Item1', 'Item2', 'Item3'] menu = root.add_scroll_menu('Test Menu', 1, 1) menu.add_item_list(menu_items) # Function that sets the root window title def set_title_from_menu(): root.set_title(menu.get()) # Bind the 't' key to the above function menu.add_key_command(py_cui.keys.KEY_T_LOWER, set_title_from_menu) # start the CUI root.start() Supported Keys Below is a table of all keys supported by py_cui . Each key is accessed within your program with py_cui.keys.YOUR_KEY_CODE . There are some differences in the way keycodes are handled on win32 vs. UNIX, though this is abstracted away by py_cui. Key Code Key Presses KEY_ENTER Enter (newline) Key KEY_ESCAPE Escape Key KEY_SPACE Space Key KEY_DELETE Delete Key KEY_TAB Tab Key KEY_UP_ARROW Up Arrow Key KEY_DOWN_ARROW Down Arrow Key KEY_LEFT_ARROW Left Arrow Key KEY_RIGHT_ARROW Right Arrow Key KEY_PAGE_UP Page Up Key KEY_PAGE_DOWN Page Down Key KEY_F1 F1 Function Key KEY_F2 F2 Function Key KEY_F3 F3 Function Key KEY_F4 F4 Function Key KEY_F5 F5 Function Key KEY_F6 F6 Function Key KEY_F7 F7 Function Key KEY_F8 F8 Function Key KEY_HOME Home Key KEY_END End Key KEY_A_LOWER a Key KEY_B_LOWER b Key KEY_C_LOWER c Key KEY_D_LOWER d Key KEY_E_LOWER e Key KEY_F_LOWER f Key KEY_G_LOWER g Key KEY_H_LOWER h Key KEY_I_LOWER i Key KEY_J_LOWER j Key KEY_K_LOWER k Key KEY_L_LOWER l Key KEY_M_LOWER m Key KEY_N_LOWER n Key KEY_O_LOWER o Key KEY_P_LOWER p Key KEY_Q_LOWER q Key KEY_R_LOWER r Key KEY_S_LOWER s Key KEY_T_LOWER t Key KEY_U_LOWER u Key KEY_V_LOWER v Key KEY_W_LOWER w Key KEY_X_LOWER x Key KEY_Y_LOWER y Key KEY_Z_LOWER z Key KEY_A_UPPER a Key + Shift Key KEY_B_UPPER b Key + Shift Key KEY_C_UPPER c Key + Shift Key KEY_D_UPPER d Key + Shift Key KEY_E_UPPER e Key + Shift Key KEY_F_UPPER f Key + Shift Key KEY_G_UPPER g Key + Shift Key KEY_H_UPPER h Key + Shift Key KEY_I_UPPER i Key + Shift Key KEY_J_UPPER j Key + Shift Key KEY_K_UPPER k Key + Shift Key KEY_L_UPPER l Key + Shift Key KEY_M_UPPER m Key + Shift Key KEY_N_UPPER n Key + Shift Key KEY_O_UPPER o Key + Shift Key KEY_P_UPPER p Key + Shift Key KEY_Q_UPPER q Key + Shift Key KEY_R_UPPER r Key + Shift Key KEY_S_UPPER s Key + Shift Key KEY_T_UPPER t Key + Shift Key KEY_U_UPPER u Key + Shift Key KEY_V_UPPER v Key + Shift Key KEY_W_UPPER w Key + Shift Key KEY_X_UPPER x Key + Shift Key KEY_Y_UPPER y Key + Shift Key KEY_Z_UPPER z Key + Shift Key KEY_BACKSPACE Backspace Key","title":"Keys"},{"location":"keybindings/#keybindings","text":"Almost all CUI elements in py_cui support some degree of keybindings. The order in which these keybindings are executed depend on the order they are added, however, user keybindings are always executed prior to default keybindings, so make sure you don't unintentionally override an already bound key. Lists of default keybindings for each widget are available in the Widgets section of this documentation, and a list of default keybindings for overview mode is found in the Usage section.","title":"Keybindings"},{"location":"keybindings/#adding-a-keybinding","text":"For all keybindings, you must pass a py_cui key and a function with no arguments. This function will be fired when the key bound to it is detected. The function may also be a class funciton, with self.FUNCTION being passed into the add keybinding function. Make sure to take a look at the examples for more uses of keybindings. Overview Mode To add a keybinding to overview mode, you need to add it to the PyCUI object itself. For example, if I wanted to add a binding for the c key to clear all text fields in my cui : # import the library import py_cui # Create the PyCUI and add a text field root = py_cui.PyCUI(3, 3) text_field = root.add_text_box('Text Field', 1, 1) # This function simply clears the text in the text field def clear_text_field(): text_field.clear() # Add the key binding to the PyCUI object itself for overview mode. root.add_key_binding(py_cui.keys.KEY_C_LOWER, clear_text_field) # Start the CUI root.start() Focus Mode Adding keybindings to focus mode is done at a widget by widget basis. When a widget is added to the PyCUI , the returned object is used to add a key command. Once again, make sure to check default key bindings that should only be overridden if the user specifically desires to replace their functionality. For example, in a menu widget, if we wish to set the window title to the selected menu item with the t key, we could write the following: # import the library import py_cui # Create the CUI object root = py_cui.PyCUI(3,3) # Add the scroll menu with the three menu items menu_items = ['Item1', 'Item2', 'Item3'] menu = root.add_scroll_menu('Test Menu', 1, 1) menu.add_item_list(menu_items) # Function that sets the root window title def set_title_from_menu(): root.set_title(menu.get()) # Bind the 't' key to the above function menu.add_key_command(py_cui.keys.KEY_T_LOWER, set_title_from_menu) # start the CUI root.start()","title":"Adding a Keybinding"},{"location":"keybindings/#supported-keys","text":"Below is a table of all keys supported by py_cui . Each key is accessed within your program with py_cui.keys.YOUR_KEY_CODE . There are some differences in the way keycodes are handled on win32 vs. UNIX, though this is abstracted away by py_cui. Key Code Key Presses KEY_ENTER Enter (newline) Key KEY_ESCAPE Escape Key KEY_SPACE Space Key KEY_DELETE Delete Key KEY_TAB Tab Key KEY_UP_ARROW Up Arrow Key KEY_DOWN_ARROW Down Arrow Key KEY_LEFT_ARROW Left Arrow Key KEY_RIGHT_ARROW Right Arrow Key KEY_PAGE_UP Page Up Key KEY_PAGE_DOWN Page Down Key KEY_F1 F1 Function Key KEY_F2 F2 Function Key KEY_F3 F3 Function Key KEY_F4 F4 Function Key KEY_F5 F5 Function Key KEY_F6 F6 Function Key KEY_F7 F7 Function Key KEY_F8 F8 Function Key KEY_HOME Home Key KEY_END End Key KEY_A_LOWER a Key KEY_B_LOWER b Key KEY_C_LOWER c Key KEY_D_LOWER d Key KEY_E_LOWER e Key KEY_F_LOWER f Key KEY_G_LOWER g Key KEY_H_LOWER h Key KEY_I_LOWER i Key KEY_J_LOWER j Key KEY_K_LOWER k Key KEY_L_LOWER l Key KEY_M_LOWER m Key KEY_N_LOWER n Key KEY_O_LOWER o Key KEY_P_LOWER p Key KEY_Q_LOWER q Key KEY_R_LOWER r Key KEY_S_LOWER s Key KEY_T_LOWER t Key KEY_U_LOWER u Key KEY_V_LOWER v Key KEY_W_LOWER w Key KEY_X_LOWER x Key KEY_Y_LOWER y Key KEY_Z_LOWER z Key KEY_A_UPPER a Key + Shift Key KEY_B_UPPER b Key + Shift Key KEY_C_UPPER c Key + Shift Key KEY_D_UPPER d Key + Shift Key KEY_E_UPPER e Key + Shift Key KEY_F_UPPER f Key + Shift Key KEY_G_UPPER g Key + Shift Key KEY_H_UPPER h Key + Shift Key KEY_I_UPPER i Key + Shift Key KEY_J_UPPER j Key + Shift Key KEY_K_UPPER k Key + Shift Key KEY_L_UPPER l Key + Shift Key KEY_M_UPPER m Key + Shift Key KEY_N_UPPER n Key + Shift Key KEY_O_UPPER o Key + Shift Key KEY_P_UPPER p Key + Shift Key KEY_Q_UPPER q Key + Shift Key KEY_R_UPPER r Key + Shift Key KEY_S_UPPER s Key + Shift Key KEY_T_UPPER t Key + Shift Key KEY_U_UPPER u Key + Shift Key KEY_V_UPPER v Key + Shift Key KEY_W_UPPER w Key + Shift Key KEY_X_UPPER x Key + Shift Key KEY_Y_UPPER y Key + Shift Key KEY_Z_UPPER z Key + Shift Key KEY_BACKSPACE Backspace Key","title":"Supported Keys"},{"location":"popups/","text":"Popups This page contains information regarding all popups supported by py_cui . Please see the popups_example.py in the examples/ directory in the repository. Message/Warning/Error Popup Spawn Command show_message_popup(title, text) show_warning_popup(title, text) show_error_popup(title, text) Usage Used to show a simple message, with a different color depending on warning level. Keys Exit from the popup with KEY_ENTER , KEY_ESCAPE , or KEY_SPACE . Yes/No Popup Spawn Command show_yes_no_popup(self, title, command) Usage Ask user yes/no question. The command parameter passed to the spawn function must be a function that takes a single boolean parameter. Keys If KEY_Y_LOWER is pressed, the command will be run with True passed in, otherwise False is passed in. Loading Icon/Bar Popup Spawn Command show_loading_icon_popup(title, message) show_loading_bar_popup(title, num_items) Usage The loading popups must be used in conjunction with some sort of async/threading. First, spawn the popup and then start a thread performing the long operation. At the end of the long operation, call: stop_loading_popup() Which will escape the loading popup. When using the loading bar popup, increment yout item counter with: increment_loading_bar() Keys None TextBox Popup Spawn Command show_text_box_popup(title, command) Usage Spawn a text box, and on KEY_ENTER pressed, the command function is triggered with the text from the popup as the parameter. Keys The letter keys will write the text, and KEY_ENTER submits. Menu Popup Spawn Command show_menu_popup(title, menu_items, command, run_command_if_none=False) Usage Use as an overall menu system for your application. Gives user option to select from list. Fires the command with the selected menu item as a parameter on KEY_ENTER Keys Arrow keys scroll up and down, enter key submits.","title":"Popups"},{"location":"popups/#popups","text":"This page contains information regarding all popups supported by py_cui . Please see the popups_example.py in the examples/ directory in the repository.","title":"Popups"},{"location":"popups/#messagewarningerror-popup","text":"Spawn Command show_message_popup(title, text) show_warning_popup(title, text) show_error_popup(title, text) Usage Used to show a simple message, with a different color depending on warning level. Keys Exit from the popup with KEY_ENTER , KEY_ESCAPE , or KEY_SPACE .","title":"Message/Warning/Error Popup"},{"location":"popups/#yesno-popup","text":"Spawn Command show_yes_no_popup(self, title, command) Usage Ask user yes/no question. The command parameter passed to the spawn function must be a function that takes a single boolean parameter. Keys If KEY_Y_LOWER is pressed, the command will be run with True passed in, otherwise False is passed in.","title":"Yes/No Popup"},{"location":"popups/#loading-iconbar-popup","text":"Spawn Command show_loading_icon_popup(title, message) show_loading_bar_popup(title, num_items) Usage The loading popups must be used in conjunction with some sort of async/threading. First, spawn the popup and then start a thread performing the long operation. At the end of the long operation, call: stop_loading_popup() Which will escape the loading popup. When using the loading bar popup, increment yout item counter with: increment_loading_bar() Keys None","title":"Loading Icon/Bar Popup"},{"location":"popups/#textbox-popup","text":"Spawn Command show_text_box_popup(title, command) Usage Spawn a text box, and on KEY_ENTER pressed, the command function is triggered with the text from the popup as the parameter. Keys The letter keys will write the text, and KEY_ENTER submits.","title":"TextBox Popup"},{"location":"popups/#menu-popup","text":"Spawn Command show_menu_popup(title, menu_items, command, run_command_if_none=False) Usage Use as an overall menu system for your application. Gives user option to select from list. Fires the command with the selected menu item as a parameter on KEY_ENTER Keys Arrow keys scroll up and down, enter key submits.","title":"Menu Popup"},{"location":"usage/","text":"Usage In this section we discuss some universal usage rules common to all py_cui based interfaces.","title":"Usage"},{"location":"usage/#usage","text":"In this section we discuss some universal usage rules common to all py_cui based interfaces.","title":"Usage"},{"location":"widgets/","text":"Widgets Below are details on each widget supported by py_cui including how to add them to a CUI, and their supported functions. Base Widget Class This base class contains all shared functionality. Label Widget Specific Class Variables None Widget Specific Functions None Usage Labels only display text. You cannot enter focus mode on labels, and thus keybindings will have no effect. Add labels for single lines to text to the center of a grid cell. Adding to CUI add_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title in the center of the grid location it is placed in. Default Keybindings None Block Label Widget Specific Class Variables self.lines - represents the title passed in split on newline characters Widget Specific Functions None Usage Block Labels only display text. You cannot enter focus mode on block labels, and thus keybindings will have no effect. Add block labels for multi line text that will be drawn in the center of the grid cell. One example for this is to display ASCII-Art. Adding to CUI add_block_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title.splitlines() in the center of the grid location it is placed in. Default Keybindings None Button Widget Specific Class Variables self.command - represents the command executed when Enter key pressed on button Widget Specific Functions None Usage Buttons execute a no-args function when enter pressed. By default, pressing enter when hovering over a button executes the command instead of entering focus mode. To disable this behavior, add the auto_focus_buttons=False to the creation of the PyCUI object. Adding to CUI add_button(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Draw Behavior Draws self.title centered in the grid cell, with a border. By default, buttons have a magenta color. Default Keybindings KEY_ENTER - runs the command passed into the button Scroll Menu Widget Specific Class Variables self.top_view - Uppermost menu item in viewport self.selected_item - currently selected item index self.view_items - list of menu items Widget Specific Functions clear() - removes all selected items scroll_up() - Internal use only, scrolls up in menu scroll_down() - Internal use only, scrolls down in menu add_item(item) - Takes in a string, adds it as an item to the menu add_item_list(item_list) - Takes a list of strings, adds them all to the menu remove_selected_item() - Removes the currently selected item from the menu get() - Returns the currently selected item get_item_list() - gets current list of menu items Usage Scroll Menus are very useful for having multiple option menus or for showing a list of information. The most common usage is to add a keybinding for the ENTER which processes some function depending on the selected item. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list Checkbox Menu The checkbox menu extends from the scrollmenu, and so shares many functions with it. Widget Specific Class Variables self.selected_item_list - list of selected items self.checked_char - character to mark item as checked Widget Specific Functions mark_item_as_checked(text) - marks item matching text as checked get() - overrides the ScrollMenu function. Returns the selected item list All functions included from ScrollMenu are also available. Usage Checkbox Menus are very useful for selecting several options. They should be used for having the user to select multiple items. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_checkbox_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list Text Box Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left() - Shifts the cursor the the left. Internal use only move_right() - Shifts the cursor the the right. Internal use only insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only Usage Used for user entering text into CUI. For prompts, it is suggested to use the Textbox popup instead. Adding to CUI add_text_box(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry field centered in the grid cell assigned Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text Text Block Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left(current_line) - Shifts the cursor to the left. Internal use only move_right(current_line) - Shifts the cursor to the right. Internal use only move_down(current_line) - Shifts the cursor down. Internal use only move_up(current_line) - Shifts the cursor up. Internal use only write(text) - writes text to the textblock insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only handle_delete(current_line) - Handles deleting characters. Internal use only handle_end(current_line) - handles end key. Internal use only handle_home(current_line) - handles home key. Internal use only handle_backspace(current_line) - handles backspace key. Internal use only handle_newline(current_line) - handles newline key. Internal use only Usage TextBoxes have two key uses: * For editing larger blocks of text, such as if you wish to create a CUI text editor (see snano example) * For displaying large amounts of text, such as statuses, logs etc. (see pyautogit example) Adding to CUI add_text_block(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry box that fills the grid cells. Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right KEY_DOWN_ARROW - Shifts cursor down KEY_UP_ARROW - Shifts cursor up Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text KEY_TAB - Enters 4 space characters (Sorry tab people) KEY_DELETE - Deletes next character KEY_ENTER - Inserts newline character","title":"Widgets"},{"location":"widgets/#widgets","text":"Below are details on each widget supported by py_cui including how to add them to a CUI, and their supported functions.","title":"Widgets"},{"location":"widgets/#base-widget-class","text":"This base class contains all shared functionality.","title":"Base Widget Class"},{"location":"widgets/#label","text":"Widget Specific Class Variables None Widget Specific Functions None Usage Labels only display text. You cannot enter focus mode on labels, and thus keybindings will have no effect. Add labels for single lines to text to the center of a grid cell. Adding to CUI add_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title in the center of the grid location it is placed in. Default Keybindings None","title":"Label"},{"location":"widgets/#block-label","text":"Widget Specific Class Variables self.lines - represents the title passed in split on newline characters Widget Specific Functions None Usage Block Labels only display text. You cannot enter focus mode on block labels, and thus keybindings will have no effect. Add block labels for multi line text that will be drawn in the center of the grid cell. One example for this is to display ASCII-Art. Adding to CUI add_block_label(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) Draw Behavior Draws self.title.splitlines() in the center of the grid location it is placed in. Default Keybindings None","title":"Block Label"},{"location":"widgets/#button","text":"Widget Specific Class Variables self.command - represents the command executed when Enter key pressed on button Widget Specific Functions None Usage Buttons execute a no-args function when enter pressed. By default, pressing enter when hovering over a button executes the command instead of entering focus mode. To disable this behavior, add the auto_focus_buttons=False to the creation of the PyCUI object. Adding to CUI add_button(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, command=None) Draw Behavior Draws self.title centered in the grid cell, with a border. By default, buttons have a magenta color. Default Keybindings KEY_ENTER - runs the command passed into the button","title":"Button"},{"location":"widgets/#scroll-menu","text":"Widget Specific Class Variables self.top_view - Uppermost menu item in viewport self.selected_item - currently selected item index self.view_items - list of menu items Widget Specific Functions clear() - removes all selected items scroll_up() - Internal use only, scrolls up in menu scroll_down() - Internal use only, scrolls down in menu add_item(item) - Takes in a string, adds it as an item to the menu add_item_list(item_list) - Takes a list of strings, adds them all to the menu remove_selected_item() - Removes the currently selected item from the menu get() - Returns the currently selected item get_item_list() - gets current list of menu items Usage Scroll Menus are very useful for having multiple option menus or for showing a list of information. The most common usage is to add a keybinding for the ENTER which processes some function depending on the selected item. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_scroll_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list","title":"Scroll Menu"},{"location":"widgets/#checkbox-menu","text":"The checkbox menu extends from the scrollmenu, and so shares many functions with it. Widget Specific Class Variables self.selected_item_list - list of selected items self.checked_char - character to mark item as checked Widget Specific Functions mark_item_as_checked(text) - marks item matching text as checked get() - overrides the ScrollMenu function. Returns the selected item list All functions included from ScrollMenu are also available. Usage Checkbox Menus are very useful for selecting several options. They should be used for having the user to select multiple items. Adding to CUI menu_item_list = [\"Item1\", \"Item2\", ...] menu = add_checkbox_menu(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0) menu.add_item_list(menu_item_list) Draw Behavior Draws all menu items starting with self.top_view down, along with a border. self.title is drawn inline with the top of the border Default Keybindings KEY_UP_ARROW - Scrolls up if self.selected_item is greater than 0 KEY_DOWN_ARROW - Scrolls down if self.selected_item is not at the end of the list","title":"Checkbox Menu"},{"location":"widgets/#text-box","text":"Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left() - Shifts the cursor the the left. Internal use only move_right() - Shifts the cursor the the right. Internal use only insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only Usage Used for user entering text into CUI. For prompts, it is suggested to use the Textbox popup instead. Adding to CUI add_text_box(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry field centered in the grid cell assigned Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text","title":"Text Box"},{"location":"widgets/#text-block","text":"Widget Specific Class Variables self.text - text currently in the text box self.cursor_x - cursor x location in terms of terminal characters self.cursor_text_pos - cursor position relative to the text self.cursor_max_left - maximum terminal position for the cursor on the left self.cursor_max_right - maximum terminal position for the cursor on the right self.cursor_y - cursor y location in terms of terminal characters self.viewport_width - Width of the text viewport Widget Specific Functions update_height_width() - Updates the height/width of the textbox. Internal use only set_text(, text) - Sets the textbox text get() - Gets text from textbox clear() - Clears text in textbox move_left(current_line) - Shifts the cursor to the left. Internal use only move_right(current_line) - Shifts the cursor to the right. Internal use only move_down(current_line) - Shifts the cursor down. Internal use only move_up(current_line) - Shifts the cursor up. Internal use only write(text) - writes text to the textblock insert_char(key_pressed) - Inserts char at cursor position. Internal use only jump_to_start() - Jumps to the start to the textbox. Internal use only jump_to_end() - Jumps to the end to the textbox. Internal use only erase_char() - Erases character at textbox cursor. Internal use only handle_delete(current_line) - Handles deleting characters. Internal use only handle_end(current_line) - handles end key. Internal use only handle_home(current_line) - handles home key. Internal use only handle_backspace(current_line) - handles backspace key. Internal use only handle_newline(current_line) - handles newline key. Internal use only Usage TextBoxes have two key uses: * For editing larger blocks of text, such as if you wish to create a CUI text editor (see snano example) * For displaying large amounts of text, such as statuses, logs etc. (see pyautogit example) Adding to CUI add_text_block(self, title, row, column, row_span = 1, column_span = 1, padx = 1, pady = 0, initial_text = '') Draw Behavior Draws self.title above a bordered entry box that fills the grid cells. Default Keybindings KEY_END - Jumps to the end of the text KEY_HOME - Jumps to start of the text KEY_LEFT_ARROW - Shifts cursor to left KEY_RIGHT_ARROW - Shifts cursor to right KEY_DOWN_ARROW - Shifts cursor down KEY_UP_ARROW - Shifts cursor up Letter Keys - writes the appropriate letter to the text KEY_BACKSPACE - Erases character in text KEY_TAB - Enters 4 space characters (Sorry tab people) KEY_DELETE - Deletes next character KEY_ENTER - Inserts newline character","title":"Text Block"},{"location":"writing/","text":"Writing a py_cui, step by step On this page, we will create a simple py_cui program, step by step. We will create something similar to the todo list example that can be seen in the examples directory in the repository. Step 1 - Create PyCUI and wrapper class The recommended way to create py_cui programs is to create a wrapper class that takes the PyCUI object as an argument, similar to how Tk objects are often passed as an argument to a wrapper class. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Step 2 - Add your widgets Next, we want to add widgets to the CUI. We will add 3 scroll menus to represent our lists of TODO, In Progress, and Done, a text field for adding new items for now. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note how we set the row_span and column_span values, so that even though the grid is 7x6, our widgets will actually be larger than that size. The reason we define these sizes is becaue we wish to have the text field fill a narrow row, meaning that we must subdivide the window into many rows. Step 3 - Add key commands Next, add keybindings to your widgets. We want buttons that send items into the next list, and the items get removed if theyre in the \"Done\" list. Also, we need to make the text field send its contents into the \"TODO\" list. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note that in the mark_as_in_progress and mark_as_done functions spawn an error popup if the lists are empty. Step 4 - You're done! That's it! our simple example is complete, and you can test it with: python3 simple_todo.py You should see something similar to this: Feel free to play around with this CUI, and note how the keybindings we assigned perform the tasks we wanted them to.","title":"Writing a PyCUI step-by-step"},{"location":"writing/#writing-a-py_cui-step-by-step","text":"On this page, we will create a simple py_cui program, step by step. We will create something similar to the todo list example that can be seen in the examples directory in the repository. Step 1 - Create PyCUI and wrapper class The recommended way to create py_cui programs is to create a wrapper class that takes the PyCUI object as an argument, similar to how Tk objects are often passed as an argument to a wrapper class. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Step 2 - Add your widgets Next, we want to add widgets to the CUI. We will add 3 scroll menus to represent our lists of TODO, In Progress, and Done, a text field for adding new items for now. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note how we set the row_span and column_span values, so that even though the grid is 7x6, our widgets will actually be larger than that size. The reason we define these sizes is becaue we wish to have the text field fill a narrow row, meaning that we must subdivide the window into many rows. Step 3 - Add key commands Next, add keybindings to your widgets. We want buttons that send items into the next list, and the items get removed if theyre in the \"Done\" list. Also, we need to make the text field send its contents into the \"TODO\" list. import py_cui class SimpleTodoList: def __init__(self, master): self.master = master # The scrolled list cells that will contain our tasks in each of the three categories self.todo_scroll_cell = self.master.add_scroll_menu('TODO', 0, 0, row_span=6, column_span=2) self.in_progress_scroll_cell = self.master.add_scroll_menu('In Progress', 0, 2, row_span=7, column_span=2) self.done_scroll_cell = self.master.add_scroll_menu('Done', 0, 4, row_span=7, column_span=2) # Textbox for entering new items self.new_todo_textbox = self.master.add_text_box('TODO Item', 6, 0, column_span=2) self.new_todo_textbox.add_key_command( py_cui.keys.KEY_ENTER, self.add_item) self.todo_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_in_progress) self.in_progress_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.mark_as_done) self.done_scroll_cell.add_key_command( py_cui.keys.KEY_ENTER, self.remove_item) def add_item(self): \"\"\" Add a todo item \"\"\" self.todo_scroll_cell.add_item('{}'.format(self.new_todo_textbox.get())) self.new_todo_textbox.clear() def mark_as_in_progress(self): \"\"\" Mark a todo item as inprogress. Remove it from todo scroll list, add it to in progress list, or show error popup if no tasks \"\"\" in_prog = self.todo_scroll_cell.get() if in_prog is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as in progress') return self.todo_scroll_cell.remove_selected_item() self.in_progress_scroll_cell.add_item(in_prog) def mark_as_done(self): \"\"\" Mark a inprogress item as done. Remove it from inprogress scroll list, add it to done list, or show error popup if no tasks \"\"\" done = self.in_progress_scroll_cell.get() if done is None: self.master.show_error_popup('No Item', 'There is no item in the list to mark as done') return self.in_progress_scroll_cell.remove_selected_item() self.done_scroll_cell.add_item(done) def remove_item(self): \"\"\" Remove a todo item \"\"\" self.done_scroll_cell.remove_selected_item() # Create the CUI with 7 rows 6 columns, pass it to the wrapper object, and start it root = py_cui.PyCUI(7, 6) root.set_title('CUI TODO List') s = SimpleTodoList(root) root.start() Note that in the mark_as_in_progress and mark_as_done functions spawn an error popup if the lists are empty. Step 4 - You're done! That's it! our simple example is complete, and you can test it with: python3 simple_todo.py You should see something similar to this: Feel free to play around with this CUI, and note how the keybindings we assigned perform the tasks we wanted them to.","title":"Writing a py_cui, step by step"}]}